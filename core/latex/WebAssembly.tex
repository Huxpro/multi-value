%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{WebAssembly Specification}
\date{Apr 15, 2019}
\release{1.0}
\author{WebAssembly Community Group}
\newcommand{\sphinxlogo}{\sphinxincludegraphics{webassembly.png}\par}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction}
\label{\detokenize{intro/index:introduction}}\label{\detokenize{intro/index:intro}}\label{\detokenize{intro/index:webassembly-specification}}\label{\detokenize{intro/index::doc}}

\section{Introduction}
\label{\detokenize{intro/introduction:introduction}}\label{\detokenize{intro/introduction::doc}}
WebAssembly (abbreviated Wasm %
\begin{footnote}[2]\sphinxAtStartFootnote
A contraction of “WebAssembly”, not an acronym, hence not using all-caps.
%
\end{footnote}) is a \sphinxstyleemphasis{safe, portable, low-level code format}
designed for efficient execution and compact representation.
Its main goal is to enable high performance applications on the Web, but it does not make any Web-specific assumptions or provide Web-specific features, so it can be employed in other environments as well.

WebAssembly is an open standard developed by a \sphinxhref{https://www.w3.org/community/webassembly/}{W3C Community Group}%
\begin{footnote}[1]\sphinxAtStartFootnote
\sphinxnolinkurl{https://www.w3.org/community/webassembly/}
%
\end{footnote}.

This document describes version 1.0 of the {\hyperref[\detokenize{intro/introduction:scope}]{\sphinxcrossref{\DUrole{std,std-ref}{core}}}} WebAssembly standard.
It is intended that it will be superseded by new incremental releases with additional features in the future.


\subsection{Design Goals}
\label{\detokenize{intro/introduction:goals}}\label{\detokenize{intro/introduction:design-goals}}
\index{design goals}\index{portability}\ignorespaces 
The design goals of WebAssembly are the following:
\begin{itemize}
\item {} 
Fast, safe, and portable \sphinxstyleemphasis{semantics}:
\begin{itemize}
\item {} 
\sphinxstylestrong{Fast}: executes with near native code performance, taking advantage of capabilities common to all contemporary hardware.

\item {} 
\sphinxstylestrong{Safe}: code is validated and executes in a memory-safe %
\begin{footnote}[3]\sphinxAtStartFootnote
No program can break WebAssembly’s memory model. Of course, it cannot guarantee that an unsafe language compiling to WebAssembly does not corrupt its own memory layout, e.g. inside WebAssembly’s linear memory.
%
\end{footnote}, sandboxed environment preventing data corruption or security breaches.

\item {} 
\sphinxstylestrong{Well-defined}: fully and precisely defines valid programs and their behavior in a way that is easy to reason about informally and formally.

\item {} 
\sphinxstylestrong{Hardware-independent}: can be compiled on all modern architectures, desktop or mobile devices and embedded systems alike.

\item {} 
\sphinxstylestrong{Language-independent}: does not privilege any particular language, programming model, or object model.

\item {} 
\sphinxstylestrong{Platform-independent}: can be embedded in browsers, run as a stand-alone VM, or integrated in other environments.

\item {} 
\sphinxstylestrong{Open}: programs can interoperate with their environment in a simple and universal manner.

\end{itemize}

\item {} 
Efficient and portable \sphinxstyleemphasis{representation}:
\begin{itemize}
\item {} 
\sphinxstylestrong{Compact}: has a binary format that is fast to transmit by being smaller than typical text or native code formats.

\item {} 
\sphinxstylestrong{Modular}: programs can be split up in smaller parts that can be transmitted, cached, and consumed separately.

\item {} 
\sphinxstylestrong{Efficient}: can be decoded, validated, and compiled in a fast single pass, equally with either just-in-time (JIT) or ahead-of-time (AOT) compilation.

\item {} 
\sphinxstylestrong{Streamable}: allows decoding, validation, and compilation to begin as soon as possible, before all data has been seen.

\item {} 
\sphinxstylestrong{Parallelizable}: allows decoding, validation, and compilation to be split into many independent parallel tasks.

\item {} 
\sphinxstylestrong{Portable}: makes no architectural assumptions that are not broadly supported across modern hardware.

\end{itemize}

\end{itemize}

WebAssembly code is also intended to be easy to inspect and debug, especially in environments like web browsers, but such features are beyond the scope of this specification.


\subsection{Scope}
\label{\detokenize{intro/introduction:scope}}\label{\detokenize{intro/introduction:id3}}
At its core, WebAssembly is a \sphinxstyleemphasis{virtual instruction set architecture (virtual ISA)}.
As such, it has many use cases and can be embedded in many different environments.
To encompass their variety and enable maximum reuse, the WebAssembly specification is split and layered into several documents.

This document is concerned with the core ISA layer of WebAssembly.
It defines the instruction set, binary encoding, validation, and execution semantics, as well as a textual representation.
It does not, however, define how WebAssembly programs can interact with a specific environment they execute in, nor how they are invoked from such an environment.

Instead, this specification is complemented by additional documents defining interfaces to specific embedding environments such as the Web.
These will each define a WebAssembly \sphinxstyleemphasis{application programming interface (API)} suitable for a given environment.

\index{IEEE 754}\index{floating point}\index{Unicode}\index{name}\index{text format}\index{UTF-8}\index{code point}\ignorespaces 

\subsection{Dependencies}
\label{\detokenize{intro/introduction:id4}}\label{\detokenize{intro/introduction:index-1}}\label{\detokenize{intro/introduction:dependencies}}
WebAssembly depends on two existing standards:
\begin{itemize}
\item {} 
\sphinxhref{http://ieeexplore.ieee.org/document/4610935/}{IEEE 754-2008}%
\begin{footnote}[4]\sphinxAtStartFootnote
\sphinxnolinkurl{http://ieeexplore.ieee.org/document/4610935/}
%
\end{footnote}, for the representation of {\hyperref[\detokenize{syntax/values:syntax-float}]{\sphinxcrossref{\DUrole{std,std-ref}{floating-point data}}}} and the semantics of respective {\hyperref[\detokenize{exec/numerics:float-ops}]{\sphinxcrossref{\DUrole{std,std-ref}{numeric operations}}}}.

\item {} 
\sphinxhref{http://www.unicode.org/versions/latest/}{Unicode}%
\begin{footnote}[5]\sphinxAtStartFootnote
\sphinxnolinkurl{http://www.unicode.org/versions/latest/}
%
\end{footnote}, for the representation of import/export {\hyperref[\detokenize{syntax/values:syntax-name}]{\sphinxcrossref{\DUrole{std,std-ref}{names}}}} and the {\hyperref[\detokenize{text/index:text}]{\sphinxcrossref{\DUrole{std,std-ref}{text format}}}}.

\end{itemize}

However, to make this specification self-contained, relevant aspects of the aforementioned standards are defined and formalized as part of this specification,
such as the {\hyperref[\detokenize{exec/numerics:aux-fbits}]{\sphinxcrossref{\DUrole{std,std-ref}{binary representation}}}} and {\hyperref[\detokenize{exec/numerics:aux-ieee}]{\sphinxcrossref{\DUrole{std,std-ref}{rounding}}}} of floating-point values, and the {\hyperref[\detokenize{syntax/values:syntax-codepoint}]{\sphinxcrossref{\DUrole{std,std-ref}{value range}}}} and {\hyperref[\detokenize{binary/values:binary-utf8}]{\sphinxcrossref{\DUrole{std,std-ref}{UTF-8 encoding}}}} of Unicode characters.

\begin{sphinxadmonition}{note}{Note:}
The aforementioned standards are the authoritative source of all respective definitions.
Formalizations given in this specification are intended to match these definitions.
Any discrepancy in the syntax or semantics described is to be considered an error.
\end{sphinxadmonition}


\section{Overview}
\label{\detokenize{intro/overview:overview}}\label{\detokenize{intro/overview::doc}}
\index{concepts}\index{value}\index{instruction}\index{trap}\index{function}\index{table}\index{memory}\index{linear memory}\index{module}\index{embedder|textbf}\index{integer}\index{floating-point}\index{IEEE 754}\index{Boolean}\index{two's complement}\ignorespaces 

\subsection{Concepts}
\label{\detokenize{intro/overview:id1}}\label{\detokenize{intro/overview:index-0}}\label{\detokenize{intro/overview:concepts}}
WebAssembly encodes a low-level, assembly-like programming language.
This language is structured around the following concepts.

\phantomsection\label{\detokenize{intro/overview:value}}\begin{description}
\item[{\sphinxstylestrong{Values}}] \leavevmode
WebAssembly provides only four basic \sphinxstyleemphasis{value types}.
These are integers and \sphinxhref{http://ieeexplore.ieee.org/document/4610935/}{IEEE 754-2008}%
\begin{footnote}[6]\sphinxAtStartFootnote
\sphinxnolinkurl{http://ieeexplore.ieee.org/document/4610935/}
%
\end{footnote} numbers,
each in 32 and 64 bit width.
32 bit integers also serve as Booleans and as memory addresses.
The usual operations on these types are available,
including the full matrix of conversions between them.
There is no distinction between signed and unsigned integer types.
Instead, integers are interpreted by respective operations
as either unsigned or signed in two’s complement representation.

\end{description}
\phantomsection\label{\detokenize{intro/overview:instruction}}\begin{description}
\item[{\sphinxstylestrong{Instructions}}] \leavevmode
The computational model of WebAssembly is based on a \sphinxstyleemphasis{stack machine}.
Code consists of sequences of \sphinxstyleemphasis{instructions} that are executed in order.
Instructions manipulate values on an implicit \sphinxstyleemphasis{operand stack} %
\begin{footnote}[7]\sphinxAtStartFootnote
In practice, implementations need not maintain an actual operand stack. Instead, the stack can be viewed as a set of anonymous registers that are implicitly referenced by instructions. The {\hyperref[\detokenize{intro/overview:validation}]{\sphinxcrossref{\DUrole{std,std-ref}{type system}}}} ensures that the stack height, and thus any referenced register, is always known statically.
%
\end{footnote}
and fall into two main categories.
\sphinxstyleemphasis{Simple} instructions perform basic operations on data.
They pop arguments from the operand stack and push results back to it.
\sphinxstyleemphasis{Control} instructions alter control flow.
Control flow is \sphinxstyleemphasis{structured}, meaning it is expressed with well-nested constructs such as blocks, loops, and conditionals.
Branches can only target such constructs.

\end{description}
\phantomsection\label{\detokenize{intro/overview:trap}}\begin{description}
\item[{\sphinxstylestrong{Traps}}] \leavevmode
Under some conditions, certain instructions may produce a \sphinxstyleemphasis{trap},
which immediately aborts execution.
Traps cannot be handled by WebAssembly code,
but are reported to the outside environment,
where they typically can be caught.

\end{description}
\phantomsection\label{\detokenize{intro/overview:function}}\begin{description}
\item[{\sphinxstylestrong{Functions}}] \leavevmode
Code is organized into separate \sphinxstyleemphasis{functions}.
Each function takes a sequence of values as parameters
and returns a sequence of values as results. %
\begin{footnote}[8]\sphinxAtStartFootnote
In the current version of WebAssembly, there may be at most one result value.
%
\end{footnote}
Functions can call each other, including recursively,
resulting in an implicit call stack that cannot be accessed directly.
Functions may also declare mutable \sphinxstyleemphasis{local variables} that are usable as virtual registers.

\end{description}
\phantomsection\label{\detokenize{intro/overview:table}}\begin{description}
\item[{\sphinxstylestrong{Tables}}] \leavevmode
A \sphinxstyleemphasis{table} is an array of opaque values of a particular \sphinxstyleemphasis{element type}.
It allows programs to select such values indirectly through a dynamic index operand.
Currently, the only available element type is an untyped function reference.
Thereby, a program can call functions indirectly through a dynamic index into a table.
For example, this allows emulating function pointers by way of table indices.

\end{description}
\phantomsection\label{\detokenize{intro/overview:memory}}\begin{description}
\item[{\sphinxstylestrong{Linear Memory}}] \leavevmode
A \sphinxstyleemphasis{linear memory} is a contiguous, mutable array of raw bytes.
Such a memory is created with an initial size but can be grown dynamically.
A program can load and store values from/to a linear memory at any byte address (including unaligned).
Integer loads and stores can specify a \sphinxstyleemphasis{storage size} which is smaller than the size of the respective value type.
A trap occurs if an access is not within the bounds of the current memory size.

\end{description}
\phantomsection\label{\detokenize{intro/overview:module}}\begin{description}
\item[{\sphinxstylestrong{Modules}}] \leavevmode
A WebAssembly binary takes the form of a \sphinxstyleemphasis{module}
that contains definitions for functions, tables, and linear memories,
as well as mutable or immutable \sphinxstyleemphasis{global variables}.
Definitions can also be \sphinxstyleemphasis{imported}, specifying a module/name pair and a suitable type.
Each definition can optionally be \sphinxstyleemphasis{exported} under one or more names.
In addition to definitions, modules can define initialization data for their memories or tables
that takes the form of \sphinxstyleemphasis{segments} copied to given offsets.
They can also define a \sphinxstyleemphasis{start function} that is automatically executed.

\end{description}
\phantomsection\label{\detokenize{intro/overview:embedder}}\begin{description}
\item[{\sphinxstylestrong{Embedder}}] \leavevmode
A WebAssembly implementation will typically be \sphinxstyleemphasis{embedded} into a \sphinxstyleemphasis{host} environment.
This environment defines how loading of modules is initiated,
how imports are provided (including host-side definitions), and how exports can be accessed.
However, the details of any particular embedding are beyond the scope of this specification, and will instead be provided by complementary, environment-specific API definitions.

\end{description}

\index{phases}\index{decoding}\index{validation}\index{execution}\index{instantiation}\index{invocation}\ignorespaces 

\subsection{Semantic Phases}
\label{\detokenize{intro/overview:semantic-phases}}\label{\detokenize{intro/overview:index-1}}
Conceptually, the semantics of WebAssembly is divided into three phases.
For each part of the language, the specification specifies each of them.

\phantomsection\label{\detokenize{intro/overview:decoding}}\begin{description}
\item[{\sphinxstylestrong{Decoding}}] \leavevmode
WebAssembly modules are distributed in a \sphinxstyleemphasis{binary format}.
\sphinxstyleemphasis{Decoding} processes that format and converts it into an internal representation of a module.
In this specification, this representation is modelled by \sphinxstyleemphasis{abstract syntax}, but a real implementation could compile directly to machine code instead.

\end{description}
\phantomsection\label{\detokenize{intro/overview:validation}}\begin{description}
\item[{\sphinxstylestrong{Validation}}] \leavevmode
A decoded module has to be \sphinxstyleemphasis{valid}.
Validation checks a number of well-formedness conditions to guarantee that the module is meaningful and safe.
In particular, it performs \sphinxstyleemphasis{type checking} of functions and the instruction sequences in their bodies, ensuring for example that the operand stack is used consistently.

\end{description}
\phantomsection\label{\detokenize{intro/overview:execution}}\phantomsection\label{\detokenize{intro/overview:instantiation}}\phantomsection\label{\detokenize{intro/overview:invocation}}\begin{description}
\item[{\sphinxstylestrong{Execution}}] \leavevmode
Finally, a valid module can be \sphinxstyleemphasis{executed}.
Execution can be further divided into two phases:

\sphinxstylestrong{Instantiation}.
A module \sphinxstyleemphasis{instance} is the dynamic representation of a module,
complete with its own state and execution stack.
Instantiation executes the module body itself, given definitions for all its imports.
It initializes globals, memories and tables and invokes the module’s start function if defined.
It returns the instances of the module’s exports.

\sphinxstylestrong{Invocation}.
Once instantiated, further WebAssembly computations can be initiated by \sphinxstyleemphasis{invoking} an exported function on a module instance.
Given the required arguments, that executes the respective function and returns its results.

Instantiation and invocation are operations within the embedding environment.

\end{description}


\chapter{Structure}
\label{\detokenize{syntax/index::doc}}\label{\detokenize{syntax/index:syntax}}\label{\detokenize{syntax/index:structure}}
\index{abstract syntax|textbf}\ignorespaces 

\section{Conventions}
\label{\detokenize{syntax/conventions:conventions}}\label{\detokenize{syntax/conventions::doc}}\label{\detokenize{syntax/conventions:index-0}}
WebAssembly is a programming language that has multiple concrete representations
(its {\hyperref[\detokenize{binary/index:binary}]{\sphinxcrossref{\DUrole{std,std-ref}{binary format}}}} and the {\hyperref[\detokenize{text/index:text}]{\sphinxcrossref{\DUrole{std,std-ref}{text format}}}}).
Both map to a common structure.
For conciseness, this structure is described in the form of an \sphinxstyleemphasis{abstract syntax}.
All parts of this specification are defined in terms of this abstract syntax.

\index{grammar notation|textbf}\index{notation}\index{abstract syntax!grammar}\index{abstract syntax!notation}\index{notation!abstract syntax}\ignorespaces 

\subsection{Grammar Notation}
\label{\detokenize{syntax/conventions:grammar}}\label{\detokenize{syntax/conventions:grammar-notation}}\label{\detokenize{syntax/conventions:index-1}}
The following conventions are adopted in defining grammar rules for abstract syntax.
\begin{itemize}
\item {} 
Terminal symbols (atoms) are written in sans-serif font: \(\mathsf{i32}, \mathsf{end}\).

\item {} 
Nonterminal symbols are written in italic font: \(\mathit{valtype}, \mathit{instr}\).

\item {} 
\(A^n\) is a sequence of \(n\geq 0\) iterations  of \(A\).

\item {} 
\(A^\ast\) is a possibly empty sequence of iterations of \(A\).
(This is a shorthand for \(A^n\) used where \(n\) is not relevant.)

\item {} 
\(A^+\) is a non-empty sequence of iterations of \(A\).
(This is a shorthand for \(A^n\) where \(n \geq 1\).)

\item {} 
\(A^?\) is an optional occurrence of \(A\).
(This is a shorthand for \(A^n\) where \(n \leq 1\).)

\item {} 
Productions are written \(\mathit{sym} ::= A_1 ~|~ \dots ~|~ A_n\).

\item {} 
Large productions may be split into multiple definitions, indicated by ending the first one with explicit ellipses, \(\mathit{sym} ::= A_1 ~|~ \dots\), and starting continuations with ellipses, \(\mathit{sym} ::= \dots ~|~ A_2\).

\item {} 
Some productions are augmented with side conditions in parentheses, “\((\mathrel{\mbox{if}} \mathit{condition})\)”, that provide a shorthand for a combinatorial expansion of the production into many separate cases.

\end{itemize}
\phantomsection\label{\detokenize{syntax/conventions:notation-epsilon}}\phantomsection\label{\detokenize{syntax/conventions:notation-length}}\phantomsection\label{\detokenize{syntax/conventions:notation-index}}\phantomsection\label{\detokenize{syntax/conventions:notation-slice}}\phantomsection\label{\detokenize{syntax/conventions:notation-replace}}\phantomsection\label{\detokenize{syntax/conventions:notation-record}}\phantomsection\label{\detokenize{syntax/conventions:notation-project}}\phantomsection\label{\detokenize{syntax/conventions:notation-concat}}

\subsection{Auxiliary Notation}
\label{\detokenize{syntax/conventions:auxiliary-notation}}\label{\detokenize{syntax/conventions:notation-concat}}\label{\detokenize{syntax/conventions:notation-index}}\label{\detokenize{syntax/conventions:notation-epsilon}}\label{\detokenize{syntax/conventions:notation-slice}}\label{\detokenize{syntax/conventions:notation-project}}\label{\detokenize{syntax/conventions:notation-replace}}\label{\detokenize{syntax/conventions:notation-length}}\label{\detokenize{syntax/conventions:notation-record}}\label{\detokenize{syntax/conventions:notation-compose}}
When dealing with syntactic constructs the following notation is also used:
\begin{itemize}
\item {} 
\(\epsilon\) denotes the empty sequence.

\item {} 
\(|s|\) denotes the length of a sequence \(s\).

\item {} 
\(s[i]\) denotes the \(i\)-th element of a sequence \(s\), starting from \(0\).

\item {} 
\(s[i \hyperref[syntax/conventions:notation-slice]{\mathrel{\mathbf{:}}} n]\) denotes the sub-sequence \(s[i]~\dots~s[i+n-1]\) of a sequence \(s\).

\item {} 
\(s \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} [i] = A\) denotes the same sequence as \(s\),
except that the \(i\)-th element is replaced with \(A\).

\item {} 
\(s \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} [i \hyperref[syntax/conventions:notation-slice]{\mathrel{\mathbf{:}}} n] = A^n\) denotes the same sequence as \(s\),
except that the sub-sequence \(s[i \hyperref[syntax/conventions:notation-slice]{\mathrel{\mathbf{:}}} n]\) is replaced with \(A^n\).

\item {} 
\(\hyperref[syntax/conventions:notation-concat]{\mathrm{concat}}(s^\ast)\) denotes the flat sequence formed by concatenating all sequences \(s_i\) in \(s^\ast\).

\end{itemize}

Moreover, the following conventions are employed:
\begin{itemize}
\item {} 
The notation \(x^n\), where \(x\) is a non-terminal symbol, is treated as a meta variable ranging over respective sequences of \(x\) (similarly for \(x^\ast\), \(x^+\), \(x^?\)).

\item {} 
When given a sequence \(x^n\),
then the occurrences of \(x\) in a sequence written \((A_1~x~A_2)^n\) are assumed to be in point-wise correspondence with \(x^n\)
(similarly for \(x^\ast\), \(x^+\), \(x^?\)).
This implicitly expresses a form of mapping syntactic constructions over a sequence.

\end{itemize}

Productions of the following form are interpreted as \sphinxstyleemphasis{records} that map a fixed set of fields \(\mathsf{field}_i\) to “values” \(A_i\), respectively:
\begin{equation*}
\begin{split}\mathit{r} ~::=~ \{ \mathsf{field}_1~A_1, \mathsf{field}_2~A_2, \dots \}\end{split}
\end{equation*}
The following notation is adopted for manipulating such records:
\begin{itemize}
\item {} 
\(r.\mathsf{field}\) denotes the contents of the \(\mathsf{field}\) component of \(r\).

\item {} 
\(r \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \mathsf{field} = A\) denotes the same record as \(r\),
except that the contents of the \(\mathsf{field}\) component is replaced with \(A\).

\item {} 
\(r_1 \hyperref[syntax/conventions:notation-compose]{\oplus} r_2\) denotes the composition of two records with the same fields of sequences by appending each sequence point-wise:
\begin{equation*}
\begin{split}\{ \mathsf{field}_1\,A_1^\ast, \mathsf{field}_2\,A_2^\ast, \dots \} \hyperref[syntax/conventions:notation-compose]{\oplus} \{ \mathsf{field}_1\,B_1^\ast, \mathsf{field}_2\,B_2^\ast, \dots \} = \{ \mathsf{field}_1\,A_1^\ast~B_1^\ast, \mathsf{field}_2\,A_2^\ast~B_2^\ast, \dots \}\end{split}
\end{equation*}
\item {} 
\(\hyperref[syntax/conventions:notation-compose]{\bigoplus} r^\ast\) denotes the composition of a sequence of records, respectively; if the sequence is empty, then all fields of the resulting record are empty.

\end{itemize}

The update notation for sequences and records generalizes recursively to nested components accessed by “paths” \(\mathit{pth} ::= ([\dots] \;| \;.\mathsf{field})^+\):
\begin{itemize}
\item {} 
\(s \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} [i]\,\mathit{pth} = A\) is short for \(s \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} [i] = (s[i] \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \mathit{pth} = A)\).

\item {} 
\(r \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \mathsf{field}\,\mathit{pth} = A\) is short for \(r \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \mathsf{field} = (r.\mathsf{field} \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \mathit{pth} = A)\).

\end{itemize}

where \(r \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}}~.\mathsf{field} = A\) is shortened to \(r \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \mathsf{field} = A\).

\index{vector|textbf}\index{abstract syntax!vector}\index{vector!abstract syntax}\ignorespaces 

\subsection{Vectors}
\label{\detokenize{syntax/conventions:index-2}}\label{\detokenize{syntax/conventions:vectors}}\label{\detokenize{syntax/conventions:syntax-vec}}
\sphinxstyleemphasis{Vectors} are bounded sequences of the form \(A^n\) (or \(A^\ast\)),
where the \(A\) can either be values or complex constructions.
A vector can have at most \(2^{32}-1\) elements.
\begin{equation*}
\begin{split}\begin{array}{lllll}
\def\mathdef1953#1{{}}\mathdef1953{vector} & \hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(A) &::=&
  A^n
  & (\mathrel{\mbox{if}} n < 2^{32})\\
\end{array}\end{split}
\end{equation*}
\index{value|textbf}\index{abstract syntax!value}\index{value!abstract syntax}\ignorespaces 

\section{Values}
\label{\detokenize{syntax/values:syntax-value}}\label{\detokenize{syntax/values:values}}\label{\detokenize{syntax/values::doc}}\label{\detokenize{syntax/values:index-0}}
WebAssembly programs operate on primitive numeric \sphinxstyleemphasis{values}.
Moreover, in the definition of programs, immutable sequences of values occur to represent more complex data, such as text strings or other vectors.

\index{byte|textbf}\index{abstract syntax!byte}\index{byte!abstract syntax}\ignorespaces 

\subsection{Bytes}
\label{\detokenize{syntax/values:syntax-byte}}\label{\detokenize{syntax/values:index-1}}\label{\detokenize{syntax/values:bytes}}
The simplest form of value are raw uninterpreted \sphinxstyleemphasis{bytes}.
In the abstract syntax they are represented as hexadecimal literals.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2250#1{{}}\mathdef2250{byte} & \hyperref[syntax/values:syntax-byte]{\mathit{byte}} &::=&
  \def\mathdef2309#1{\mathtt{0x#1}}\mathdef2309{00} ~|~ \dots ~|~ \def\mathdef2310#1{\mathtt{0x#1}}\mathdef2310{FF} \\
\end{array}\end{split}
\end{equation*}

\subsubsection{Conventions}
\label{\detokenize{syntax/values:conventions}}\begin{itemize}
\item {} 
The meta variable \(b\) ranges over bytes.

\item {} 
Bytes are sometimes interpreted as natural numbers \(n < 256\).

\end{itemize}

\index{integer|textbf}\index{unsigned integer|textbf}\index{signed integer|textbf}\index{uninterpreted integer|textbf}\index{bit width}\index{two's complement}\index{abstract syntax!integer}\index{integer!abstract syntax}\index{abstract syntax!unsigned integer}\index{unsigned integer!abstract syntax}\index{abstract syntax!signed integer}\index{signed integer!abstract syntax}\index{abstract syntax!uninterpreted integer}\index{uninterpreted integer!abstract syntax}\index{integer!unsigned}\index{integer!signed}\index{integer!uninterpreted}\ignorespaces \phantomsection\label{\detokenize{syntax/values:syntax-sint}}\phantomsection\label{\detokenize{syntax/values:syntax-uint}}

\subsection{Integers}
\label{\detokenize{syntax/values:syntax-int}}\label{\detokenize{syntax/values:syntax-sint}}\label{\detokenize{syntax/values:syntax-uint}}\label{\detokenize{syntax/values:integers}}\label{\detokenize{syntax/values:index-2}}
Different classes of \sphinxstyleemphasis{integers} with different value ranges are distinguished by their \sphinxstyleemphasis{bit width} \(N\) and by whether they are \sphinxstyleemphasis{unsigned} or \sphinxstyleemphasis{signed}.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2250#1{{}}\mathdef2250{unsigned integer} & \hyperref[syntax/values:syntax-int]{\def\mathdef2251#1{{\mathit{u}#1}}\mathdef2251{N}} &::=&
  0 ~|~ 1 ~|~ \dots ~|~ 2^N{-}1 \\
\def\mathdef2250#1{{}}\mathdef2250{signed integer} & \hyperref[syntax/values:syntax-int]{\def\mathdef2258#1{{\mathit{s}#1}}\mathdef2258{N}} &::=&
  -2^{N-1} ~|~ \dots ~|~ {-}1 ~|~ 0 ~|~ 1 ~|~ \dots ~|~ 2^{N-1}{-}1 \\
\def\mathdef2250#1{{}}\mathdef2250{uninterpreted integer} & \hyperref[syntax/values:syntax-int]{\def\mathdef2264#1{{\mathit{i}#1}}\mathdef2264{N}} &::=&
  \hyperref[syntax/values:syntax-int]{\def\mathdef2251#1{{\mathit{u}#1}}\mathdef2251{N}} \\
\end{array}\end{split}
\end{equation*}
The latter class defines \sphinxstyleemphasis{uninterpreted} integers, whose signedness interpretation can vary depending on context.
In the abstract syntax, they are represented as unsigned values.
However, some operations {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{convert}}}} them to signed based on a two’s complement interpretation.

\begin{sphinxadmonition}{note}{Note:}
The main integer types occurring in this specification are \(\hyperref[syntax/values:syntax-int]{\def\mathdef2256#1{{\mathit{u}#1}}\mathdef2256{\mathit{32}}}\), \(\hyperref[syntax/values:syntax-int]{\def\mathdef2257#1{{\mathit{u}#1}}\mathdef2257{\mathit{64}}}\), \(\hyperref[syntax/values:syntax-int]{\def\mathdef2261#1{{\mathit{s}#1}}\mathdef2261{\mathit{32}}}\), \(\hyperref[syntax/values:syntax-int]{\def\mathdef2263#1{{\mathit{s}#1}}\mathdef2263{\mathit{64}}}\), \(\hyperref[syntax/values:syntax-int]{\def\mathdef2265#1{{\mathit{i}#1}}\mathdef2265{\mathit{8}}}\), \(\hyperref[syntax/values:syntax-int]{\def\mathdef2266#1{{\mathit{i}#1}}\mathdef2266{\mathit{16}}}\), \(\hyperref[syntax/values:syntax-int]{\def\mathdef2267#1{{\mathit{i}#1}}\mathdef2267{\mathit{32}}}\), \(\hyperref[syntax/values:syntax-int]{\def\mathdef2268#1{{\mathit{i}#1}}\mathdef2268{\mathit{64}}}\).
However, other sizes occur as auxiliary constructions, e.g., in the definition of {\hyperref[\detokenize{syntax/values:syntax-float}]{\sphinxcrossref{\DUrole{std,std-ref}{floating-point}}}} numbers.
\end{sphinxadmonition}


\subsubsection{Conventions}
\label{\detokenize{syntax/values:id1}}\begin{itemize}
\item {} 
The meta variables \(m, n, i\) range over integers.

\item {} 
Numbers may be denoted by simple arithmetics, as in the grammar above.
In order to distinguish arithmetics like \(2^N\) from sequences like \((1)^N\), the latter is distinguished with parentheses.

\end{itemize}

\index{floating-point|textbf}\index{NaN|textbf}\index{payload}\index{significand}\index{exponent}\index{magnitude}\index{canonical NaN}\index{arithmetic NaN}\index{bit width}\index{IEEE 754}\index{abstract syntax!floating-point number}\index{floating-point number!abstract syntax}\index{NaN!payload}\index{NaN!canonical}\index{NaN!arithmetic}\ignorespaces \phantomsection\label{\detokenize{syntax/values:syntax-nan}}\phantomsection\label{\detokenize{syntax/values:syntax-payload}}

\subsection{Floating-Point}
\label{\detokenize{syntax/values:floating-point}}\label{\detokenize{syntax/values:syntax-float}}\label{\detokenize{syntax/values:syntax-payload}}\label{\detokenize{syntax/values:index-3}}\label{\detokenize{syntax/values:syntax-nan}}
\sphinxstyleemphasis{Floating-point} data represents 32 or 64 bit values that correspond to the respective binary formats of the \sphinxhref{http://ieeexplore.ieee.org/document/4610935/}{IEEE 754-2008}%
\begin{footnote}[9]\sphinxAtStartFootnote
\sphinxnolinkurl{http://ieeexplore.ieee.org/document/4610935/}
%
\end{footnote} standard (Section 3.3).

Every value has a \sphinxstyleemphasis{sign} and a \sphinxstyleemphasis{magnitude}.
Magnitudes can either be expressed as \sphinxstyleemphasis{normal} numbers of the form \(m_0.m_1m_2\dots m_M \cdot2^e\), where \(e\) is the exponent and \(m\) is the \sphinxstyleemphasis{significand} whose most signifcant bit \(m_0\) is \(1\),
or as a \sphinxstyleemphasis{subnormal} number where the exponent is fixed to the smallest possible value and \(m_0\) is \(0\); among the subnormals are positive and negative zero values.
Since the significands are binary values, normals are represented in the form \((1 + m\cdot 2^{-M}) \cdot 2^e\), where \(M\) is the bit width of \(m\); similarly for subnormals.

Possible magnitudes also include the special values \(\infty\) (infinity) and \(\hyperref[syntax/values:syntax-float]{\mathsf{nan}}\) (\sphinxstyleemphasis{NaN}, not a number).
NaN values have a \sphinxstyleemphasis{payload} that describes the mantissa bits in the underlying {\hyperref[\detokenize{exec/numerics:aux-fbits}]{\sphinxcrossref{\DUrole{std,std-ref}{binary representation}}}}.
No distinction is made between signalling and quiet NaNs.
\begin{equation*}
\begin{split}\begin{array}{llcll}
\def\mathdef2250#1{{}}\mathdef2250{floating-point value} & \hyperref[syntax/values:syntax-float]{\def\mathdef2269#1{{\mathit{f}#1}}\mathdef2269{N}} &::=&
  {+} \hyperref[syntax/values:syntax-float]{\def\mathdef2270#1{{\mathit{f}#1}}\mathdef2270{\mathit{Nmag}}} ~|~ {-} \hyperref[syntax/values:syntax-float]{\def\mathdef2270#1{{\mathit{f}#1}}\mathdef2270{\mathit{Nmag}}} \\
\def\mathdef2250#1{{}}\mathdef2250{floating-point magnitude} & \hyperref[syntax/values:syntax-float]{\def\mathdef2270#1{{\mathit{f}#1}}\mathdef2270{\mathit{Nmag}}} &::=&
  (1 + \hyperref[syntax/values:syntax-int]{\def\mathdef2252#1{{\mathit{u}#1}}\mathdef2252{M}}\cdot 2^{-M}) \cdot 2^e & (\mathrel{\mbox{if}} -2^{E-1}+2 \leq e \leq 2^{E-1}-1) \\ &&|&
  (0 + \hyperref[syntax/values:syntax-int]{\def\mathdef2252#1{{\mathit{u}#1}}\mathdef2252{M}}\cdot 2^{-M}) \cdot 2^e & (\mathrel{\mbox{if}} e = -2^{E-1}+2) \\ &&|&
  \infty \\ &&|&
  \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n) & (\mathrel{\mbox{if}} 1 \leq n < 2^M) \\
\end{array}\end{split}
\end{equation*}
where \(M = \hyperref[syntax/values:aux-significand]{\mathrm{signif}}(N)\) and \(E = \hyperref[syntax/values:aux-exponent]{\mathrm{expon}}(N)\) with

\phantomsection\label{\detokenize{syntax/values:aux-significand}}\phantomsection\label{\detokenize{syntax/values:aux-exponent}}\begin{equation*}
\begin{split}\begin{array}{lclllllcl}
\hyperref[syntax/values:aux-significand]{\mathrm{signif}}(32) &=& 23 &&&&
\hyperref[syntax/values:aux-exponent]{\mathrm{expon}}(32) &=& 8 \\
\hyperref[syntax/values:aux-significand]{\mathrm{signif}}(64) &=& 52 &&&&
\hyperref[syntax/values:aux-exponent]{\mathrm{expon}}(64) &=& 11 \\
\end{array}\end{split}
\end{equation*}\phantomsection\label{\detokenize{syntax/values:canonical-nan}}\phantomsection\label{\detokenize{syntax/values:arithmetic-nan}}\phantomsection\label{\detokenize{syntax/values:aux-canon}}
A \sphinxstyleemphasis{canonical NaN} is a floating-point value \(\pm\hyperref[syntax/values:syntax-float]{\mathsf{nan}}(\hyperref[syntax/values:aux-canon]{\mathrm{canon}}_N)\) where \(\hyperref[syntax/values:aux-canon]{\mathrm{canon}}_N\) is a payload whose most significant bit is \(1\) while all others are \(0\):
\begin{equation*}
\begin{split}\hyperref[syntax/values:aux-canon]{\mathrm{canon}}_N = 2^{\hyperref[syntax/values:aux-significand]{\mathrm{signif}}(N)-1}\end{split}
\end{equation*}
An \sphinxstyleemphasis{arithmetic NaN}  is a floating-point value \(\pm\hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)\) with \(n \geq \hyperref[syntax/values:aux-canon]{\mathrm{canon}}_N\), such that the most significant bit is \(1\) while all others are arbitrary.

\begin{sphinxadmonition}{note}{Note:}
In the abstract syntax, subnormals are distinguished by the leading 0 of the significand. The exponent of subnormals has the same value as the smallest possible exponent of a normal number. Only in the {\hyperref[\detokenize{binary/values:binary-float}]{\sphinxcrossref{\DUrole{std,std-ref}{binary representation}}}} the exponent of a subnormal is encoded differently than the exponent of any normal number.
\end{sphinxadmonition}


\subsubsection{Conventions}
\label{\detokenize{syntax/values:id2}}\begin{itemize}
\item {} 
The meta variable \(z\) ranges over floating-point values where clear from context.

\end{itemize}

\index{name|textbf}\index{byte}\index{Unicode}\index{UTF-8}\index{code point}\index{binary format}\index{abstract syntax!name}\index{name!abstract syntax}\ignorespaces \phantomsection\label{\detokenize{syntax/values:syntax-codepoint}}

\subsection{Names}
\label{\detokenize{syntax/values:syntax-codepoint}}\label{\detokenize{syntax/values:index-4}}\label{\detokenize{syntax/values:names}}\label{\detokenize{syntax/values:syntax-name}}
\sphinxstyleemphasis{Names} are sequences of scalar \sphinxstyleemphasis{code points} as defined by \sphinxhref{http://www.unicode.org/versions/latest/}{Unicode}%
\begin{footnote}[10]\sphinxAtStartFootnote
\sphinxnolinkurl{http://www.unicode.org/versions/latest/}
%
\end{footnote} (Section 2.4).
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2250#1{{}}\mathdef2250{name} & \hyperref[syntax/values:syntax-name]{\mathit{name}} &::=&
  \hyperref[syntax/values:syntax-name]{\mathit{codepoint}}^\ast \qquad\qquad (\mathrel{\mbox{if}} |\hyperref[binary/values:binary-utf8]{\mathrm{utf8}}(\hyperref[syntax/values:syntax-name]{\mathit{codepoint}}^\ast)| < 2^{32}) \\
\def\mathdef2250#1{{}}\mathdef2250{code point} & \hyperref[syntax/values:syntax-name]{\mathit{codepoint}} &::=&
  \def\mathdef2311#1{\mathrm{U{+}#1}}\mathdef2311{00} ~|~ \dots ~|~ \def\mathdef2312#1{\mathrm{U{+}#1}}\mathdef2312{D7FF} ~|~
  \def\mathdef2313#1{\mathrm{U{+}#1}}\mathdef2313{E000} ~|~ \dots ~|~ \def\mathdef2314#1{\mathrm{U{+}#1}}\mathdef2314{10FFFF} \\
\end{array}\end{split}
\end{equation*}
Due to the limitations of the {\hyperref[\detokenize{binary/values:binary-name}]{\sphinxcrossref{\DUrole{std,std-ref}{binary format}}}},
the length of a name is bounded by the length of its {\hyperref[\detokenize{binary/values:binary-utf8}]{\sphinxcrossref{\DUrole{std,std-ref}{UTF-8}}}} encoding.


\subsubsection{Convention}
\label{\detokenize{syntax/values:convention}}\begin{itemize}
\item {} 
Code points are sometimes used interchangeably with natural numbers \(n < 1114112\).

\end{itemize}

\index{type|textbf}\index{validation}\index{instantiation}\index{execution}\index{abstract syntax!type}\index{type!abstract syntax}\ignorespaces 

\section{Types}
\label{\detokenize{syntax/types:syntax-type}}\label{\detokenize{syntax/types::doc}}\label{\detokenize{syntax/types:types}}\label{\detokenize{syntax/types:index-0}}
Various entities in WebAssembly are classified by types.
Types are checked during {\hyperref[\detokenize{valid/index:valid}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, {\hyperref[\detokenize{exec/modules:exec-instantiation}]{\sphinxcrossref{\DUrole{std,std-ref}{instantiation}}}}, and possibly {\hyperref[\detokenize{syntax/instructions:syntax-call-indirect}]{\sphinxcrossref{\DUrole{std,std-ref}{execution}}}}.

\index{value type|textbf}\index{integer}\index{floating-point}\index{IEEE 754}\index{bit width}\index{abstract syntax!value type}\index{value type!abstract syntax}\index{value!type}\index{type!value}\ignorespaces 

\subsection{Value Types}
\label{\detokenize{syntax/types:value-types}}\label{\detokenize{syntax/types:index-1}}\label{\detokenize{syntax/types:syntax-valtype}}
\sphinxstyleemphasis{Value types} classify the individual values that WebAssembly code can compute with and the values that a variable accepts.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2191#1{{}}\mathdef2191{value type} & \hyperref[syntax/types:syntax-valtype]{\mathit{valtype}} &::=&
  \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}} ~|~ \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}} ~|~ \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}} ~|~ \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}} \\
\end{array}\end{split}
\end{equation*}
The types \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\) and \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}\) classify 32 and 64 bit integers, respectively.
Integers are not inherently signed or unsigned, their interpretation is determined by individual operations.

The types \(\hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}\) and \(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}\) classify 32 and 64 bit floating-point data, respectively.
They correspond to the respective binary floating-point representations, also known as \sphinxstyleemphasis{single} and \sphinxstyleemphasis{double} precision, as defined by the \sphinxhref{http://ieeexplore.ieee.org/document/4610935/}{IEEE 754-2008}%
\begin{footnote}[11]\sphinxAtStartFootnote
\sphinxnolinkurl{http://ieeexplore.ieee.org/document/4610935/}
%
\end{footnote} standard (Section 3.3).


\subsubsection{Conventions}
\label{\detokenize{syntax/types:conventions}}\begin{itemize}
\item {} 
The meta variable \(t\) ranges over value types where clear from context.

\item {} 
The notation \(|t|\) denotes the \sphinxstyleemphasis{bit width} of a value type.
That is, \(|\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}| = |\hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}| = 32\) and \(|\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}| = |\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}| = 64\).

\end{itemize}

\index{result type|textbf}\index{value type}\index{instruction}\index{execution}\index{function}\index{abstract syntax!result type}\index{result type!abstract syntax}\index{result!type}\index{type!result}\ignorespaces 

\subsection{Result Types}
\label{\detokenize{syntax/types:result-types}}\label{\detokenize{syntax/types:index-2}}\label{\detokenize{syntax/types:syntax-resulttype}}
\sphinxstyleemphasis{Result types} classify the result of {\hyperref[\detokenize{exec/instructions:exec-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{executing}}}} {\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instructions}}}} or {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{functions}}}},
which is a sequence of values written with brackets.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2191#1{{}}\mathdef2191{result type} & \hyperref[syntax/types:syntax-resulttype]{\mathit{resulttype}} &::=&
  [\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/types:syntax-valtype]{\mathit{valtype}})] \\
\end{array}\end{split}
\end{equation*}
\index{function type|textbf}\index{value type}\index{vector}\index{function}\index{parameter}\index{result}\index{result type}\index{abstract syntax!function type}\index{function type!abstract syntax}\index{function!type}\index{type!function}\ignorespaces 

\subsection{Function Types}
\label{\detokenize{syntax/types:function-types}}\label{\detokenize{syntax/types:syntax-functype}}\label{\detokenize{syntax/types:index-3}}
\sphinxstyleemphasis{Function types} classify the signature of {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{functions}}}},
mapping a vector of parameters to a vector of results.
They are also used to classify the inputs and outputs of {\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instructions}}}}.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2191#1{{}}\mathdef2191{function type} & \hyperref[syntax/types:syntax-functype]{\mathit{functype}} &::=&
  \hyperref[syntax/types:syntax-resulttype]{\mathit{resulttype}} \hyperref[syntax/types:syntax-functype]{\rightarrow} \hyperref[syntax/types:syntax-resulttype]{\mathit{resulttype}} \\
\end{array}\end{split}
\end{equation*}
\index{limits|textbf}\index{memory type}\index{table type}\index{abstract syntax!limits}\index{limits!abstract syntax}\index{memory!limits}\index{table!limits}\ignorespaces 

\subsection{Limits}
\label{\detokenize{syntax/types:index-4}}\label{\detokenize{syntax/types:limits}}\label{\detokenize{syntax/types:syntax-limits}}
\sphinxstyleemphasis{Limits} classify the size range of resizeable storage associated with {\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory types}}}} and {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table types}}}}.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2191#1{{}}\mathdef2191{limits} & \hyperref[syntax/types:syntax-limits]{\mathit{limits}} &::=&
  \{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~\hyperref[syntax/values:syntax-int]{\def\mathdef2197#1{{\mathit{u}#1}}\mathdef2197{\mathit{32}}}, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~\hyperref[syntax/values:syntax-int]{\def\mathdef2197#1{{\mathit{u}#1}}\mathdef2197{\mathit{32}}}^? \} \\
\end{array}\end{split}
\end{equation*}
If no maximum is given, the respective storage can grow to any size.

\index{memory type|textbf}\index{limits}\index{page size}\index{memory}\index{abstract syntax!memory type}\index{memory type!abstract syntax}\index{memory!type}\index{type!memory}\index{memory!limits}\index{limits!memory}\ignorespaces 

\subsection{Memory Types}
\label{\detokenize{syntax/types:syntax-memtype}}\label{\detokenize{syntax/types:memory-types}}\label{\detokenize{syntax/types:index-5}}
\sphinxstyleemphasis{Memory types} classify linear {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memories}}}} and their size range.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2191#1{{}}\mathdef2191{memory type} & \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}} &::=&
  \hyperref[syntax/types:syntax-limits]{\mathit{limits}} \\
\end{array}\end{split}
\end{equation*}
The limits constrain the minimum and optionally the maximum size of a memory.
The limits are given in units of {\hyperref[\detokenize{exec/runtime:page-size}]{\sphinxcrossref{\DUrole{std,std-ref}{page size}}}}.

\index{table type|textbf}\index{element type|textbf}\index{limits}\index{table}\index{element}\index{abstract syntax!table type}\index{table type!abstract syntax}\index{abstract syntax!element type}\index{element type!abstract syntax}\index{table!type}\index{type!table}\index{table!limits}\index{limits!table}\index{element!type}\index{type!element}\ignorespaces \phantomsection\label{\detokenize{syntax/types:syntax-elemtype}}

\subsection{Table Types}
\label{\detokenize{syntax/types:index-6}}\label{\detokenize{syntax/types:syntax-elemtype}}\label{\detokenize{syntax/types:table-types}}\label{\detokenize{syntax/types:syntax-tabletype}}
\sphinxstyleemphasis{Table types} classify {\hyperref[\detokenize{syntax/modules:syntax-table}]{\sphinxcrossref{\DUrole{std,std-ref}{tables}}}} over elements of \sphinxstyleemphasis{element types} within a size range.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2191#1{{}}\mathdef2191{table type} & \hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}} &::=&
  \hyperref[syntax/types:syntax-limits]{\mathit{limits}}~\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}} \\
\def\mathdef2191#1{{}}\mathdef2191{element type} & \hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}} &::=&
  \hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}} \\
\end{array}\end{split}
\end{equation*}
Like memories, tables are constrained by limits for their minimum and optionally maximum size.
The limits are given in numbers of entries.

The element type \(\hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}}\) is the infinite union of all {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function types}}}}.
A table of that type thus contains references to functions of heterogeneous type.

\begin{sphinxadmonition}{note}{Note:}
In future versions of WebAssembly, additional element types may be introduced.
\end{sphinxadmonition}

\index{global type|textbf}\index{mutability|textbf}\index{value type}\index{global}\index{mutability}\index{abstract syntax!global type}\index{global type!abstract syntax}\index{abstract syntax!mutability}\index{mutability!abstract syntax}\index{global!type}\index{type!global}\index{global!mutability}\index{mutability!global}\ignorespaces \phantomsection\label{\detokenize{syntax/types:syntax-mut}}

\subsection{Global Types}
\label{\detokenize{syntax/types:syntax-globaltype}}\label{\detokenize{syntax/types:global-types}}\label{\detokenize{syntax/types:index-7}}\label{\detokenize{syntax/types:syntax-mut}}
\sphinxstyleemphasis{Global types} classify {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}} variables, which hold a value and can either be mutable or immutable.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2191#1{{}}\mathdef2191{global type} & \hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}} &::=&
  \hyperref[syntax/types:syntax-mut]{\mathit{mut}}~\hyperref[syntax/types:syntax-valtype]{\mathit{valtype}} \\
\def\mathdef2191#1{{}}\mathdef2191{mutability} & \hyperref[syntax/types:syntax-mut]{\mathit{mut}} &::=&
  \hyperref[syntax/types:syntax-mut]{\mathsf{const}} ~|~
  \hyperref[syntax/types:syntax-mut]{\mathsf{var}} \\
\end{array}\end{split}
\end{equation*}
\index{external type|textbf}\index{function type}\index{table type}\index{memory type}\index{global type}\index{import}\index{external value}\index{abstract syntax!external type}\index{external type!abstract syntax}\index{external!type}\index{type!external}\ignorespaces 

\subsection{External Types}
\label{\detokenize{syntax/types:syntax-externtype}}\label{\detokenize{syntax/types:external-types}}\label{\detokenize{syntax/types:index-8}}
\sphinxstyleemphasis{External types} classify {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}} and {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external values}}}} with their respective types.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2191#1{{}}\mathdef2191{external types} & \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}} &::=&
  \hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}} ~|~
  \hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}} ~|~
  \hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}} ~|~
  \hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}} \\
\end{array}\end{split}
\end{equation*}

\subsubsection{Conventions}
\label{\detokenize{syntax/types:id1}}
The following auxiliary notation is defined for sequences of external types.
It filters out entries of a specific kind in an order-preserving fashion:
\begin{itemize}
\item {} 
\(\hyperref[syntax/types:syntax-externtype]{\mathrm{funcs}}(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast) = [\hyperref[syntax/types:syntax-functype]{\mathit{functype}} ~|~ (\hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}) \in \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast]\)

\item {} 
\(\hyperref[syntax/types:syntax-externtype]{\mathrm{tables}}(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast) = [\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}} ~|~ (\hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}) \in \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast]\)

\item {} 
\(\hyperref[syntax/types:syntax-externtype]{\mathrm{mems}}(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast) = [\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}} ~|~ (\hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}) \in \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast]\)

\item {} 
\(\hyperref[syntax/types:syntax-externtype]{\mathrm{globals}}(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast) = [\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}} ~|~ (\hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}) \in \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast]\)

\end{itemize}

\index{instruction|textbf}\index{code}\index{stack machine}\index{operand}\index{operand stack}\index{abstract syntax!instruction}\index{instruction!abstract syntax}\ignorespaces 

\section{Instructions}
\label{\detokenize{syntax/instructions:instructions}}\label{\detokenize{syntax/instructions::doc}}\label{\detokenize{syntax/instructions:index-0}}\label{\detokenize{syntax/instructions:syntax-instr}}
WebAssembly code consists of sequences of \sphinxstyleemphasis{instructions}.
Its computational model is based on a \sphinxstyleemphasis{stack machine} in that instructions manipulate values on an implicit \sphinxstyleemphasis{operand stack},
consuming (popping) argument values and producing or returning (pushing) result values.

In addition to dynamic operands from the stack, some instructions also have static \sphinxstyleemphasis{immediate} arguments,
typically {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{indices}}}} or type annotations,
which are part of the instruction itself.

Some instructions are {\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{structured}}}} in that they bracket nested sequences of instructions.

The following sections group instructions into a number of different categories.

\index{numeric instruction|textbf}\index{value}\index{value type}\index{integer}\index{floating-point}\index{two's complement}\index{abstract syntax!instruction}\index{instruction!abstract syntax}\ignorespaces \phantomsection\label{\detokenize{syntax/instructions:syntax-sx}}\phantomsection\label{\detokenize{syntax/instructions:syntax-const}}\phantomsection\label{\detokenize{syntax/instructions:syntax-unop}}\phantomsection\label{\detokenize{syntax/instructions:syntax-binop}}\phantomsection\label{\detokenize{syntax/instructions:syntax-testop}}\phantomsection\label{\detokenize{syntax/instructions:syntax-relop}}\phantomsection\label{\detokenize{syntax/instructions:syntax-cvtop}}\phantomsection\label{\detokenize{syntax/instructions:syntax-iunop}}\phantomsection\label{\detokenize{syntax/instructions:syntax-ibinop}}\phantomsection\label{\detokenize{syntax/instructions:syntax-itestop}}\phantomsection\label{\detokenize{syntax/instructions:syntax-irelop}}\phantomsection\label{\detokenize{syntax/instructions:syntax-funop}}\phantomsection\label{\detokenize{syntax/instructions:syntax-fbinop}}\phantomsection\label{\detokenize{syntax/instructions:syntax-ftestop}}\phantomsection\label{\detokenize{syntax/instructions:syntax-frelop}}

\subsection{Numeric Instructions}
\label{\detokenize{syntax/instructions:syntax-instr-numeric}}\label{\detokenize{syntax/instructions:syntax-frelop}}\label{\detokenize{syntax/instructions:syntax-ibinop}}\label{\detokenize{syntax/instructions:syntax-cvtop}}\label{\detokenize{syntax/instructions:syntax-binop}}\label{\detokenize{syntax/instructions:syntax-fbinop}}\label{\detokenize{syntax/instructions:syntax-sx}}\label{\detokenize{syntax/instructions:syntax-funop}}\label{\detokenize{syntax/instructions:syntax-iunop}}\label{\detokenize{syntax/instructions:syntax-testop}}\label{\detokenize{syntax/instructions:index-1}}\label{\detokenize{syntax/instructions:numeric-instructions}}\label{\detokenize{syntax/instructions:syntax-unop}}\label{\detokenize{syntax/instructions:syntax-itestop}}\label{\detokenize{syntax/instructions:syntax-const}}\label{\detokenize{syntax/instructions:syntax-irelop}}\label{\detokenize{syntax/instructions:syntax-ftestop}}\label{\detokenize{syntax/instructions:syntax-relop}}
Numeric instructions provide basic operations over numeric {\hyperref[\detokenize{syntax/values:syntax-value}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} of specific {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{type}}}}.
These operations closely match respective operations available in hardware.
\begin{equation*}
\begin{split}\begin{array}{llcl}
\def\mathdef2071#1{{}}\mathdef2071{width} & \mathit{nn}, \mathit{mm} &::=&
  \mathsf{32} ~|~ \mathsf{64} \\
\def\mathdef2071#1{{}}\mathdef2071{signedness} & \hyperref[syntax/instructions:syntax-sx]{\mathit{sx}} &::=&
  \mathsf{u} ~|~ \mathsf{s} \\
\def\mathdef2071#1{{}}\mathdef2071{instruction} & \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}} &::=&
  \mathsf{i}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\hyperref[syntax/values:syntax-int]{\def\mathdef2130#1{{\mathit{i}#1}}\mathdef2130{\mathit{nn}}} ~|~
  \mathsf{f}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\hyperref[syntax/values:syntax-float]{\def\mathdef2131#1{{\mathit{f}#1}}\mathdef2131{\mathit{nn}}} \\&&|&
  \mathsf{i}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-iunop]{\mathit{iunop}} ~|~
  \mathsf{f}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-funop]{\mathit{funop}} \\&&|&
  \mathsf{i}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-ibinop]{\mathit{ibinop}} ~|~
  \mathsf{f}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-fbinop]{\mathit{fbinop}} \\&&|&
  \mathsf{i}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-itestop]{\mathit{itestop}} \\&&|&
  \mathsf{i}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-irelop]{\mathit{irelop}} ~|~
  \mathsf{f}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-frelop]{\mathit{frelop}} \\&&|&
  \mathsf{i32.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{wrap}}\mathsf{\_i64} ~|~
  \mathsf{i64.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{extend}}\mathsf{\_i32}\mathsf{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}} ~|~
  \mathsf{i}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_f}\mathit{mm}\mathsf{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}} \\&&|&
  \mathsf{f32.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{demote}}\mathsf{\_f64} ~|~
  \mathsf{f64.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{promote}}\mathsf{\_f32} ~|~
  \mathsf{f}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_i}\mathit{mm}\mathsf{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}} \\&&|&
  \mathsf{i}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{reinterpret}}\mathsf{\_f}\mathit{nn} ~|~
  \mathsf{f}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{reinterpret}}\mathsf{\_i}\mathit{nn} \\&&|&
  \dots \\
\def\mathdef2071#1{{}}\mathdef2071{integer unary operator} & \hyperref[syntax/instructions:syntax-iunop]{\mathit{iunop}} &::=&
  \mathsf{clz} ~|~
  \mathsf{ctz} ~|~
  \mathsf{popcnt} \\
\def\mathdef2071#1{{}}\mathdef2071{integer binary operator} & \hyperref[syntax/instructions:syntax-ibinop]{\mathit{ibinop}} &::=&
  \mathsf{add} ~|~
  \mathsf{sub} ~|~
  \mathsf{mul} ~|~
  \mathsf{div\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}} ~|~
  \mathsf{rem\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}} \\&&|&
  \mathsf{and} ~|~
  \mathsf{or} ~|~
  \mathsf{xor} ~|~
  \mathsf{shl} ~|~
  \mathsf{shr\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}} ~|~
  \mathsf{rotl} ~|~
  \mathsf{rotr} \\
\def\mathdef2071#1{{}}\mathdef2071{floating-point unary operator} & \hyperref[syntax/instructions:syntax-funop]{\mathit{funop}} &::=&
  \mathsf{abs} ~|~
  \mathsf{neg} ~|~
  \mathsf{sqrt} ~|~
  \mathsf{ceil} ~|~
  \mathsf{floor} ~|~
  \mathsf{trunc} ~|~
  \mathsf{nearest} \\
\def\mathdef2071#1{{}}\mathdef2071{floating-point binary operator} & \hyperref[syntax/instructions:syntax-fbinop]{\mathit{fbinop}} &::=&
  \mathsf{add} ~|~
  \mathsf{sub} ~|~
  \mathsf{mul} ~|~
  \mathsf{div} ~|~
  \mathsf{min} ~|~
  \mathsf{max} ~|~
  \mathsf{copysign} \\
\def\mathdef2071#1{{}}\mathdef2071{integer test operator} & \hyperref[syntax/instructions:syntax-itestop]{\mathit{itestop}} &::=&
  \mathsf{eqz} \\
\def\mathdef2071#1{{}}\mathdef2071{integer relational operator} & \hyperref[syntax/instructions:syntax-irelop]{\mathit{irelop}} &::=&
  \mathsf{eq} ~|~
  \mathsf{ne} ~|~
  \mathsf{lt\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}} ~|~
  \mathsf{gt\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}} ~|~
  \mathsf{le\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}} ~|~
  \mathsf{ge\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}} \\
\def\mathdef2071#1{{}}\mathdef2071{floating-point relational operator} & \hyperref[syntax/instructions:syntax-frelop]{\mathit{frelop}} &::=&
  \mathsf{eq} ~|~
  \mathsf{ne} ~|~
  \mathsf{lt} ~|~
  \mathsf{gt} ~|~
  \mathsf{le} ~|~
  \mathsf{ge} \\
\end{array}\end{split}
\end{equation*}
Numeric instructions are divided by {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}}.
For each type, several subcategories can be distinguished:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Constants}: return a static constant.

\item {} 
\sphinxstyleemphasis{Unary Operators}: consume one operand and produce one result of the respective type.

\item {} 
\sphinxstyleemphasis{Binary Operators}: consume two operands and produce one result of the respective type.

\item {} 
\sphinxstyleemphasis{Tests}: consume one operand of the respective type and produce a Boolean integer result.

\item {} 
\sphinxstyleemphasis{Comparisons}: consume two operands of the respective type and produce a Boolean integer result.

\item {} 
\sphinxstyleemphasis{Conversions}: consume a value of one type and produce a result of another
(the source type of the conversion is the one after the “\(\mathsf{/}\)”).

\end{itemize}

Some integer instructions come in two flavors,
where a signedness annotation \(\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}\) distinguishes whether the operands are to be {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{interpreted}}}} as {\hyperref[\detokenize{syntax/values:syntax-uint}]{\sphinxcrossref{\DUrole{std,std-ref}{unsigned}}}} or {\hyperref[\detokenize{syntax/values:syntax-sint}]{\sphinxcrossref{\DUrole{std,std-ref}{signed}}}} integers.
For the other integer instructions, the use of two’s complement for the signed interpretation means that they behave the same regardless of signedness.


\subsubsection{Conventions}
\label{\detokenize{syntax/instructions:conventions}}
Occasionally, it is convenient to group operators together according to the following grammar shorthands:
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2071#1{{}}\mathdef2071{unary operator} & \hyperref[syntax/instructions:syntax-unop]{\mathit{unop}} &::=& \hyperref[syntax/instructions:syntax-iunop]{\mathit{iunop}} ~|~ \hyperref[syntax/instructions:syntax-funop]{\mathit{funop}} \\
\def\mathdef2071#1{{}}\mathdef2071{binary operator} & \hyperref[syntax/instructions:syntax-binop]{\mathit{binop}} &::=& \hyperref[syntax/instructions:syntax-ibinop]{\mathit{ibinop}} ~|~ \hyperref[syntax/instructions:syntax-fbinop]{\mathit{fbinop}} \\
\def\mathdef2071#1{{}}\mathdef2071{test operator} & \hyperref[syntax/instructions:syntax-testop]{\mathit{testop}} &::=& \hyperref[syntax/instructions:syntax-itestop]{\mathit{itestop}} \\
\def\mathdef2071#1{{}}\mathdef2071{relational operator} & \hyperref[syntax/instructions:syntax-relop]{\mathit{relop}} &::=& \hyperref[syntax/instructions:syntax-irelop]{\mathit{irelop}} ~|~ \hyperref[syntax/instructions:syntax-frelop]{\mathit{frelop}} \\
\def\mathdef2071#1{{}}\mathdef2071{conversion operator} & \hyperref[syntax/instructions:syntax-cvtop]{\mathit{cvtop}} &::=&
  \hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{wrap}} ~|~
  \hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{extend}} ~|~
  \hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}} ~|~
  \hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}} ~|~
  \hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{demote}} ~|~
  \hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{promote}} ~|~
  \hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{reinterpret}} \\
\end{array}\end{split}
\end{equation*}
\index{parametric instruction|textbf}\index{value type}\index{abstract syntax!instruction}\index{instruction!abstract syntax}\ignorespaces 

\subsection{Parametric Instructions}
\label{\detokenize{syntax/instructions:syntax-instr-parametric}}\label{\detokenize{syntax/instructions:parametric-instructions}}\label{\detokenize{syntax/instructions:index-2}}
Instructions in this group can operate on operands of any {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}}.
\begin{equation*}
\begin{split}\begin{array}{llcl}
\def\mathdef2071#1{{}}\mathdef2071{instruction} & \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}} &::=&
  \dots \\&&|&
  \hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{drop}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}}
\end{array}\end{split}
\end{equation*}
The \(\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{drop}}\) operator simply throws away a single operand.

The \(\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}}\) operator selects one of its first two operands based on whether its third operand is zero or not.

\index{variable instruction|textbf}\index{local}\index{global}\index{local index}\index{global index}\index{abstract syntax!instruction}\index{instruction!abstract syntax}\ignorespaces 

\subsection{Variable Instructions}
\label{\detokenize{syntax/instructions:syntax-instr-variable}}\label{\detokenize{syntax/instructions:index-3}}\label{\detokenize{syntax/instructions:variable-instructions}}
Variable instructions are concerned with access to {\hyperref[\detokenize{syntax/modules:syntax-local}]{\sphinxcrossref{\DUrole{std,std-ref}{local}}}} or {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}} variables.
\begin{equation*}
\begin{split}\begin{array}{llcl}
\def\mathdef2071#1{{}}\mathdef2071{instruction} & \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}} &::=&
  \dots \\&&|&
  \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.get}}~\hyperref[syntax/modules:syntax-localidx]{\mathit{localidx}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.set}}~\hyperref[syntax/modules:syntax-localidx]{\mathit{localidx}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.tee}}~\hyperref[syntax/modules:syntax-localidx]{\mathit{localidx}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.get}}~\hyperref[syntax/modules:syntax-globalidx]{\mathit{globalidx}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.set}}~\hyperref[syntax/modules:syntax-globalidx]{\mathit{globalidx}} \\
\end{array}\end{split}
\end{equation*}
These instructions get or set the values of variables, respectively.
The \(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.tee}}\) instruction is like \(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.set}}\) but also returns its argument.

\index{memory instruction|textbf}\index{memory}\index{memory index}\index{page size}\index{little endian}\index{trap}\index{abstract syntax!instruction}\index{instruction!abstract syntax}\ignorespaces \phantomsection\label{\detokenize{syntax/instructions:syntax-loadn}}\phantomsection\label{\detokenize{syntax/instructions:syntax-storen}}\phantomsection\label{\detokenize{syntax/instructions:syntax-memarg}}

\subsection{Memory Instructions}
\label{\detokenize{syntax/instructions:syntax-memarg}}\label{\detokenize{syntax/instructions:syntax-loadn}}\label{\detokenize{syntax/instructions:index-4}}\label{\detokenize{syntax/instructions:syntax-storen}}\label{\detokenize{syntax/instructions:memory-instructions}}\label{\detokenize{syntax/instructions:syntax-instr-memory}}
Instructions in this group are concerned with linear {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memory}}}}.
\begin{equation*}
\begin{split}\begin{array}{llcl}
\def\mathdef2071#1{{}}\mathdef2071{memory immediate} & \hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} &::=&
  \{ \hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{offset}}~\hyperref[syntax/values:syntax-int]{\def\mathdef2077#1{{\mathit{u}#1}}\mathdef2077{\mathit{32}}}, \hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{align}}~\hyperref[syntax/values:syntax-int]{\def\mathdef2077#1{{\mathit{u}#1}}\mathdef2077{\mathit{32}}} \} \\
\def\mathdef2071#1{{}}\mathdef2071{instruction} & \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}} &::=&
  \dots \\&&|&
  \mathsf{i}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} ~|~
  \mathsf{f}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} \\&&|&
  \mathsf{i}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} ~|~
  \mathsf{f}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} \\&&|&
  \mathsf{i}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{8\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} ~|~
  \mathsf{i}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{16\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} ~|~
  \mathsf{i64.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{32\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} \\&&|&
  \mathsf{i}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}\mathsf{8}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} ~|~
  \mathsf{i}\mathit{nn}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}\mathsf{16}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} ~|~
  \mathsf{i64.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}\mathsf{32}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.size}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.grow}} \\
\end{array}\end{split}
\end{equation*}
Memory is accessed with \(\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\) and \(\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}\) instructions for the different {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}}.
They all take a \sphinxstyleemphasis{memory immediate} \(\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}\) that contains an address \sphinxstyleemphasis{offset} and an \sphinxstyleemphasis{alignment} hint (in base 2 logarithmic representation).
Integer loads and stores can optionally specify a \sphinxstyleemphasis{storage size} that is smaller than the {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{bit width}}}} of the respective value type.
In the case of loads, a sign extension mode \(\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}\) is then required to select appropriate behavior.

The static address offset is added to the dynamic address operand, yielding a 33 bit \sphinxstyleemphasis{effective address} that is the zero-based index at which the memory is accessed.
All values are read and written in \sphinxhref{https://en.wikipedia.org/wiki/Endianness\#Little-endian}{little endian}%
\begin{footnote}[12]\sphinxAtStartFootnote
\sphinxnolinkurl{https://en.wikipedia.org/wiki/Endianness\#Little-endian}
%
\end{footnote} byte order.
A {\hyperref[\detokenize{intro/overview:trap}]{\sphinxcrossref{\DUrole{std,std-ref}{trap}}}} results if any of the accessed memory bytes lies outside the address range implied by the memory’s current size.

\begin{sphinxadmonition}{note}{Note:}
Future version of WebAssembly might provide memory instructions with 64 bit address ranges.
\end{sphinxadmonition}

The \(\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.size}}\) instruction returns the current size of a memory.
The \(\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.grow}}\) instruction grows memory by a given delta and returns the previous size, or \(-1\) if enough memory cannot be allocated.
Both instructions operate in units of {\hyperref[\detokenize{exec/runtime:page-size}]{\sphinxcrossref{\DUrole{std,std-ref}{page size}}}}.

\begin{sphinxadmonition}{note}{Note:}
In the current version of WebAssembly,
all memory instructions implicitly operate on {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memory}}}} {\hyperref[\detokenize{syntax/modules:syntax-memidx}]{\sphinxcrossref{\DUrole{std,std-ref}{index}}}} \(0\).
This restriction may be lifted in future versions.
\end{sphinxadmonition}

\index{control instruction|textbf}\index{structured control|textbf}\index{label|textbf}\index{block|textbf}\index{block type|textbf}\index{branch|textbf}\index{unwinding|textbf}\index{result type}\index{label index}\index{function index}\index{type index}\index{vector}\index{trap}\index{function}\index{table}\index{function type}\index{value type}\index{type index}\index{abstract syntax!instruction}\index{instruction!abstract syntax}\index{abstract syntax!block type}\index{block type!abstract syntax}\index{block!type}\index{type!block}\ignorespaces \phantomsection\label{\detokenize{syntax/instructions:syntax-blocktype}}\phantomsection\label{\detokenize{syntax/instructions:syntax-nop}}\phantomsection\label{\detokenize{syntax/instructions:syntax-unreachable}}\phantomsection\label{\detokenize{syntax/instructions:syntax-block}}\phantomsection\label{\detokenize{syntax/instructions:syntax-loop}}\phantomsection\label{\detokenize{syntax/instructions:syntax-if}}\phantomsection\label{\detokenize{syntax/instructions:syntax-br}}\phantomsection\label{\detokenize{syntax/instructions:syntax-br-if}}\phantomsection\label{\detokenize{syntax/instructions:syntax-br-table}}\phantomsection\label{\detokenize{syntax/instructions:syntax-return}}\phantomsection\label{\detokenize{syntax/instructions:syntax-call}}\phantomsection\label{\detokenize{syntax/instructions:syntax-call-indirect}}\phantomsection\label{\detokenize{syntax/instructions:syntax-instr-seq}}

\subsection{Control Instructions}
\label{\detokenize{syntax/instructions:control-instructions}}\label{\detokenize{syntax/instructions:syntax-loop}}\label{\detokenize{syntax/instructions:syntax-unreachable}}\label{\detokenize{syntax/instructions:syntax-br-if}}\label{\detokenize{syntax/instructions:syntax-instr-seq}}\label{\detokenize{syntax/instructions:syntax-blocktype}}\label{\detokenize{syntax/instructions:syntax-br}}\label{\detokenize{syntax/instructions:syntax-call-indirect}}\label{\detokenize{syntax/instructions:syntax-nop}}\label{\detokenize{syntax/instructions:syntax-call}}\label{\detokenize{syntax/instructions:index-5}}\label{\detokenize{syntax/instructions:syntax-instr-control}}\label{\detokenize{syntax/instructions:syntax-return}}\label{\detokenize{syntax/instructions:syntax-br-table}}\label{\detokenize{syntax/instructions:syntax-block}}\label{\detokenize{syntax/instructions:syntax-if}}
Instructions in this group affect the flow of control.
\begin{equation*}
\begin{split}\begin{array}{llcl}
\def\mathdef2071#1{{}}\mathdef2071{block type} & \hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}} &::=&
  \hyperref[syntax/modules:syntax-typeidx]{\mathit{typeidx}} ~|~ \hyperref[syntax/types:syntax-valtype]{\mathit{valtype}}^? \\
\def\mathdef2071#1{{}}\mathdef2071{instruction} & \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}} &::=&
  \dots \\&&|&
  \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{nop}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}~\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{loop}}~\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}~\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{else}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}~\hyperref[syntax/modules:syntax-labelidx]{\mathit{labelidx}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_if}}~\hyperref[syntax/modules:syntax-labelidx]{\mathit{labelidx}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_table}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/modules:syntax-labelidx]{\mathit{labelidx}})~\hyperref[syntax/modules:syntax-labelidx]{\mathit{labelidx}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{return}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call}}~\hyperref[syntax/modules:syntax-funcidx]{\mathit{funcidx}} \\&&|&
  \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call\_indirect}}~\hyperref[syntax/modules:syntax-typeidx]{\mathit{typeidx}} \\
\end{array}\end{split}
\end{equation*}
The \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{nop}}\) instruction does nothing.

The \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}}\) instruction causes an unconditional {\hyperref[\detokenize{intro/overview:trap}]{\sphinxcrossref{\DUrole{std,std-ref}{trap}}}}.

The \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}\), \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{loop}}\) and \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}\) instructions are \sphinxstyleemphasis{structured} instructions.
They bracket nested sequences of instructions, called \sphinxstyleemphasis{blocks}, terminated with, or separated by, \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\) or \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{else}}\) pseudo-instructions.
As the grammar prescribes, they must be well-nested.

A structured instruction can consume \sphinxstyleemphasis{input} and produce \sphinxstyleemphasis{output} on the operand stack according to its annotated \sphinxstyleemphasis{block type}.
It is given either as a {\hyperref[\detokenize{syntax/modules:syntax-funcidx}]{\sphinxcrossref{\DUrole{std,std-ref}{type index}}}} that refers to a suitable {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}}, or as an optional {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} inline, which is a shorthand for the function type \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathit{valtype}}^?]\).

Each structured control instruction introduces an implicit \sphinxstyleemphasis{label}.
Labels are targets for branch instructions that reference them with {\hyperref[\detokenize{syntax/modules:syntax-labelidx}]{\sphinxcrossref{\DUrole{std,std-ref}{label indices}}}}.
Unlike with other {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{index spaces}}}}, indexing of labels is relative by nesting depth,
that is, label \(0\) refers to the innermost structured control instruction enclosing the referring branch instruction,
while increasing indices refer to those farther out.
Consequently, labels can only be referenced from \sphinxstyleemphasis{within} the associated structured control instruction.
This also implies that branches can only be directed outwards,
“breaking” from the block of the control construct they target.
The exact effect depends on that control construct.
In case of \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}\) or \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}\) it is a \sphinxstyleemphasis{forward jump},
resuming execution after the matching \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\).
In case of \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{loop}}\) it is a \sphinxstyleemphasis{backward jump} to the beginning of the loop.

\begin{sphinxadmonition}{note}{Note:}
This enforces \sphinxstyleemphasis{structured control flow}.
Intuitively, a branch targeting a \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}\) or \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}\) behaves like a \(\mathsf{break}\) statement,
while a branch targeting a \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{loop}}\) behaves like a \(\mathsf{continue}\) statement.
\end{sphinxadmonition}

Branch instructions come in several flavors:
\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}\) performs an unconditional branch,
\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_if}}\) performs a conditional branch,
and \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_table}}\) performs an indirect branch through an operand indexing into the label vector that is an immediate to the instruction, or to a default target if the operand is out of bounds.
The \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{return}}\) instruction is a shortcut for an unconditional branch to the outermost block, which implicitly is the body of the current function.
Taking a branch \sphinxstyleemphasis{unwinds} the operand stack up to the height where the targeted structured control instruction was entered.
However, branches may additionally consume operands themselves, which they push back on the operand stack after unwinding.
Forward branches require operands according to the output of the targeted block’s type, i.e., represent the values produced by the terminated block.
Backward branches require operands according to the input of the targeted block’s type, i.e., represent the values consumed by the restarted block.

The \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call}}\) instruction invokes another {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}}, consuming the necessary arguments from the stack and returning the result values of the call.
The \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call\_indirect}}\) instruction calls a function indirectly through an operand indexing into a {\hyperref[\detokenize{syntax/modules:syntax-table}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}}.
Since tables may contain function elements of heterogeneous type \(\hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}}\),
the callee is dynamically checked against the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} indexed by the instruction’s immediate, and the call aborted with a {\hyperref[\detokenize{intro/overview:trap}]{\sphinxcrossref{\DUrole{std,std-ref}{trap}}}} if it does not match.

\begin{sphinxadmonition}{note}{Note:}
In the current version of WebAssembly,
\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call\_indirect}}\) implicitly operates on {\hyperref[\detokenize{syntax/modules:syntax-table}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}} {\hyperref[\detokenize{syntax/modules:syntax-tableidx}]{\sphinxcrossref{\DUrole{std,std-ref}{index}}}} \(0\).
This restriction may be lifted in future versions.
\end{sphinxadmonition}

\index{expression|textbf}\index{constant}\index{global}\index{offset}\index{element}\index{data}\index{instruction}\index{abstract syntax!expression}\index{expression!abstract syntax}\index{expression!constant}\ignorespaces 

\subsection{Expressions}
\label{\detokenize{syntax/instructions:expressions}}\label{\detokenize{syntax/instructions:index-6}}\label{\detokenize{syntax/instructions:syntax-expr}}
{\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{Function}}}} bodies, initialization values for {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{globals}}}}, and offsets of {\hyperref[\detokenize{syntax/modules:syntax-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{element}}}} or {\hyperref[\detokenize{syntax/modules:syntax-data}]{\sphinxcrossref{\DUrole{std,std-ref}{data}}}} segments are given as expressions, which are sequences of {\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instructions}}}} terminated by an \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\) marker.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2071#1{{}}\mathdef2071{expression} & \hyperref[syntax/instructions:syntax-expr]{\mathit{expr}} &::=&
  \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \\
\end{array}\end{split}
\end{equation*}
In some places, validation {\hyperref[\detokenize{valid/instructions:valid-constant}]{\sphinxcrossref{\DUrole{std,std-ref}{restricts}}}} expressions to be \sphinxstyleemphasis{constant}, which limits the set of allowable instructions.

\index{module|textbf}\index{type definition}\index{function type}\index{function}\index{table}\index{memory}\index{global}\index{element}\index{data}\index{start function}\index{import}\index{export}\index{abstract syntax!module}\index{module!abstract syntax}\ignorespaces 

\section{Modules}
\label{\detokenize{syntax/modules::doc}}\label{\detokenize{syntax/modules:index-0}}\label{\detokenize{syntax/modules:modules}}\label{\detokenize{syntax/modules:syntax-module}}
WebAssembly programs are organized into \sphinxstyleemphasis{modules},
which are the unit of deployment, loading, and compilation.
A module collects definitions for {\hyperref[\detokenize{syntax/types:syntax-type}]{\sphinxcrossref{\DUrole{std,std-ref}{types}}}}, {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{functions}}}}, {\hyperref[\detokenize{syntax/modules:syntax-table}]{\sphinxcrossref{\DUrole{std,std-ref}{tables}}}}, {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memories}}}}, and {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{globals}}}}.
In addition, it can declare {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}} and {\hyperref[\detokenize{syntax/modules:syntax-export}]{\sphinxcrossref{\DUrole{std,std-ref}{exports}}}}
and provide initialization logic in the form of {\hyperref[\detokenize{syntax/modules:syntax-data}]{\sphinxcrossref{\DUrole{std,std-ref}{data}}}} and {\hyperref[\detokenize{syntax/modules:syntax-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{element}}}} segments or a {\hyperref[\detokenize{syntax/modules:syntax-start}]{\sphinxcrossref{\DUrole{std,std-ref}{start function}}}}.
\begin{equation*}
\begin{split}\begin{array}{lllll}
\def\mathdef2132#1{{}}\mathdef2132{module} & \hyperref[syntax/modules:syntax-module]{\mathit{module}} &::=& \{ &
  \hyperref[syntax/modules:syntax-module]{\mathsf{types}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/types:syntax-functype]{\mathit{functype}}), \\&&&&
  \hyperref[syntax/modules:syntax-module]{\mathsf{funcs}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/modules:syntax-func]{\mathit{func}}), \\&&&&
  \hyperref[syntax/modules:syntax-module]{\mathsf{tables}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/modules:syntax-table]{\mathit{table}}), \\&&&&
  \hyperref[syntax/modules:syntax-module]{\mathsf{mems}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/modules:syntax-mem]{\mathit{mem}}), \\&&&&
  \hyperref[syntax/modules:syntax-module]{\mathsf{globals}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/modules:syntax-global]{\mathit{global}}), \\&&&&
  \hyperref[syntax/modules:syntax-module]{\mathsf{elem}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}), \\&&&&
  \hyperref[syntax/modules:syntax-module]{\mathsf{data}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/modules:syntax-data]{\mathit{data}}), \\&&&&
  \hyperref[syntax/modules:syntax-module]{\mathsf{start}}~\hyperref[syntax/modules:syntax-start]{\mathit{start}}^?, \\&&&&
  \hyperref[syntax/modules:syntax-module]{\mathsf{imports}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/modules:syntax-import]{\mathit{import}}), \\&&&&
  \hyperref[syntax/modules:syntax-module]{\mathsf{exports}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/modules:syntax-export]{\mathit{export}}) \quad\} \\
\end{array}\end{split}
\end{equation*}
Each of the vectors \textendash{} and thus the entire module \textendash{} may be empty.

\index{index|textbf}\index{index space|textbf}\index{type index|textbf}\index{function index|textbf}\index{table index|textbf}\index{memory index|textbf}\index{global index|textbf}\index{local index|textbf}\index{label index|textbf}\index{function}\index{global}\index{table}\index{memory}\index{local}\index{parameter}\index{import}\index{abstract syntax!type index}\index{type index!abstract syntax}\index{abstract syntax!function index}\index{function index!abstract syntax}\index{abstract syntax!table index}\index{table index!abstract syntax}\index{abstract syntax!memory index}\index{memory index!abstract syntax}\index{abstract syntax!global index}\index{global index!abstract syntax}\index{abstract syntax!local index}\index{local index!abstract syntax}\index{abstract syntax!label index}\index{label index!abstract syntax}\index{type!index}\index{index!type}\index{function!index}\index{index!function}\index{table!index}\index{index!table}\index{memory!index}\index{index!memory}\index{global!index}\index{index!global}\index{local!index}\index{index!local}\index{label!index}\index{index!label}\ignorespaces \phantomsection\label{\detokenize{syntax/modules:syntax-typeidx}}\phantomsection\label{\detokenize{syntax/modules:syntax-funcidx}}\phantomsection\label{\detokenize{syntax/modules:syntax-tableidx}}\phantomsection\label{\detokenize{syntax/modules:syntax-memidx}}\phantomsection\label{\detokenize{syntax/modules:syntax-globalidx}}\phantomsection\label{\detokenize{syntax/modules:syntax-localidx}}\phantomsection\label{\detokenize{syntax/modules:syntax-labelidx}}

\subsection{Indices}
\label{\detokenize{syntax/modules:syntax-index}}\label{\detokenize{syntax/modules:syntax-funcidx}}\label{\detokenize{syntax/modules:index-1}}\label{\detokenize{syntax/modules:indices}}\label{\detokenize{syntax/modules:syntax-globalidx}}\label{\detokenize{syntax/modules:syntax-labelidx}}\label{\detokenize{syntax/modules:syntax-localidx}}\label{\detokenize{syntax/modules:syntax-tableidx}}\label{\detokenize{syntax/modules:syntax-memidx}}\label{\detokenize{syntax/modules:syntax-typeidx}}
Definitions are referenced with zero-based \sphinxstyleemphasis{indices}.
Each class of definition has its own \sphinxstyleemphasis{index space}, as distinguished by the following classes.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2132#1{{}}\mathdef2132{type index} & \hyperref[syntax/modules:syntax-typeidx]{\mathit{typeidx}} &::=& \hyperref[syntax/values:syntax-int]{\def\mathdef2138#1{{\mathit{u}#1}}\mathdef2138{\mathit{32}}} \\
\def\mathdef2132#1{{}}\mathdef2132{function index} & \hyperref[syntax/modules:syntax-funcidx]{\mathit{funcidx}} &::=& \hyperref[syntax/values:syntax-int]{\def\mathdef2138#1{{\mathit{u}#1}}\mathdef2138{\mathit{32}}} \\
\def\mathdef2132#1{{}}\mathdef2132{table index} & \hyperref[syntax/modules:syntax-tableidx]{\mathit{tableidx}} &::=& \hyperref[syntax/values:syntax-int]{\def\mathdef2138#1{{\mathit{u}#1}}\mathdef2138{\mathit{32}}} \\
\def\mathdef2132#1{{}}\mathdef2132{memory index} & \hyperref[syntax/modules:syntax-memidx]{\mathit{memidx}} &::=& \hyperref[syntax/values:syntax-int]{\def\mathdef2138#1{{\mathit{u}#1}}\mathdef2138{\mathit{32}}} \\
\def\mathdef2132#1{{}}\mathdef2132{global index} & \hyperref[syntax/modules:syntax-globalidx]{\mathit{globalidx}} &::=& \hyperref[syntax/values:syntax-int]{\def\mathdef2138#1{{\mathit{u}#1}}\mathdef2138{\mathit{32}}} \\
\def\mathdef2132#1{{}}\mathdef2132{local index} & \hyperref[syntax/modules:syntax-localidx]{\mathit{localidx}} &::=& \hyperref[syntax/values:syntax-int]{\def\mathdef2138#1{{\mathit{u}#1}}\mathdef2138{\mathit{32}}} \\
\def\mathdef2132#1{{}}\mathdef2132{label index} & \hyperref[syntax/modules:syntax-labelidx]{\mathit{labelidx}} &::=& \hyperref[syntax/values:syntax-int]{\def\mathdef2138#1{{\mathit{u}#1}}\mathdef2138{\mathit{32}}} \\
\end{array}\end{split}
\end{equation*}
The index space for {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{functions}}}}, {\hyperref[\detokenize{syntax/modules:syntax-table}]{\sphinxcrossref{\DUrole{std,std-ref}{tables}}}}, {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memories}}}} and {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{globals}}}} includes respective {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}} declared in the same module.
The indices of these imports precede the indices of other definitions in the same index space.

The index space for {\hyperref[\detokenize{syntax/modules:syntax-local}]{\sphinxcrossref{\DUrole{std,std-ref}{locals}}}} is only accessible inside a {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}} and includes the parameters of that function, which precede the local variables.

Label indices reference {\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{structured control instructions}}}} inside an instruction sequence.


\subsubsection{Conventions}
\label{\detokenize{syntax/modules:conventions}}\begin{itemize}
\item {} 
The meta variable \(l\) ranges over label indices.

\item {} 
The meta variables \(x, y\) range over indices in any of the other index spaces.

\end{itemize}

\index{type definition|textbf}\index{type index}\index{function type}\index{abstract syntax!type definition}\index{type definition!abstract syntax}\ignorespaces 

\subsection{Types}
\label{\detokenize{syntax/modules:types}}\label{\detokenize{syntax/modules:index-2}}\label{\detokenize{syntax/modules:syntax-typedef}}
The \(\hyperref[syntax/modules:syntax-module]{\mathsf{types}}\) component of a module defines a vector of {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function types}}}}.

All function types used in a module must be defined in this component.
They are referenced by {\hyperref[\detokenize{syntax/modules:syntax-typeidx}]{\sphinxcrossref{\DUrole{std,std-ref}{type indices}}}}.

\begin{sphinxadmonition}{note}{Note:}
Future versions of WebAssembly may add additional forms of type definitions.
\end{sphinxadmonition}

\index{function|textbf}\index{local|textbf}\index{function index}\index{local index}\index{type index}\index{value type}\index{expression}\index{import}\index{abstract syntax!function}\index{function!abstract syntax}\index{abstract syntax!local}\index{local!abstract syntax}\ignorespaces \phantomsection\label{\detokenize{syntax/modules:syntax-local}}

\subsection{Functions}
\label{\detokenize{syntax/modules:functions}}\label{\detokenize{syntax/modules:syntax-local}}\label{\detokenize{syntax/modules:syntax-func}}\label{\detokenize{syntax/modules:index-3}}
The \(\hyperref[syntax/modules:syntax-module]{\mathsf{funcs}}\) component of a module defines a vector of \sphinxstyleemphasis{functions} with the following structure:
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2132#1{{}}\mathdef2132{function} & \hyperref[syntax/modules:syntax-func]{\mathit{func}} &::=&
  \{ \hyperref[syntax/modules:syntax-func]{\mathsf{type}}~\hyperref[syntax/modules:syntax-typeidx]{\mathit{typeidx}}, \hyperref[syntax/modules:syntax-func]{\mathsf{locals}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/types:syntax-valtype]{\mathit{valtype}}), \hyperref[syntax/modules:syntax-func]{\mathsf{body}}~\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}} \} \\
\end{array}\end{split}
\end{equation*}
The \(\hyperref[syntax/modules:syntax-func]{\mathsf{type}}\) of a function declares its signature by reference to a {\hyperref[\detokenize{syntax/types:syntax-type}]{\sphinxcrossref{\DUrole{std,std-ref}{type}}}} defined in the module.
The parameters of the function are referenced through 0-based {\hyperref[\detokenize{syntax/modules:syntax-localidx}]{\sphinxcrossref{\DUrole{std,std-ref}{local indices}}}} in the function’s body; they are mutable.

The \(\hyperref[syntax/modules:syntax-func]{\mathsf{locals}}\) declare a vector of mutable local variables and their types.
These variables are referenced through {\hyperref[\detokenize{syntax/modules:syntax-localidx}]{\sphinxcrossref{\DUrole{std,std-ref}{local indices}}}} in the function’s body.
The index of the first local is the smallest index not referencing a parameter.

The \(\hyperref[syntax/modules:syntax-func]{\mathsf{body}}\) is an {\hyperref[\detokenize{syntax/instructions:syntax-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{instruction}}}} sequence that upon termination must produce a stack matching the function type’s {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}}.

Functions are referenced through {\hyperref[\detokenize{syntax/modules:syntax-funcidx}]{\sphinxcrossref{\DUrole{std,std-ref}{function indices}}}},
starting with the smallest index not referencing a function {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{import}}}}.

\index{table|textbf}\index{table index}\index{table type}\index{limits}\index{element}\index{import}\index{abstract syntax!table}\index{table!abstract syntax}\ignorespaces 

\subsection{Tables}
\label{\detokenize{syntax/modules:index-4}}\label{\detokenize{syntax/modules:syntax-table}}\label{\detokenize{syntax/modules:tables}}
The \(\hyperref[syntax/modules:syntax-module]{\mathsf{tables}}\) component of a module defines a vector of \sphinxstyleemphasis{tables} described by their {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table type}}}}:
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2132#1{{}}\mathdef2132{table} & \hyperref[syntax/modules:syntax-table]{\mathit{table}} &::=&
  \{ \hyperref[syntax/modules:syntax-table]{\mathsf{type}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}} \} \\
\end{array}\end{split}
\end{equation*}
A table is a vector of opaque values of a particular table {\hyperref[\detokenize{syntax/types:syntax-elemtype}]{\sphinxcrossref{\DUrole{std,std-ref}{element type}}}}.
The \(\hyperref[syntax/types:syntax-limits]{\mathsf{min}}\) size in the {\hyperref[\detokenize{syntax/types:syntax-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{limits}}}} of the table type specifies the initial size of that table, while its \(\hyperref[syntax/types:syntax-limits]{\mathsf{max}}\), if present, restricts the size to which it can grow later.

Tables can be initialized through {\hyperref[\detokenize{syntax/modules:syntax-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{element segments}}}}.

Tables are referenced through {\hyperref[\detokenize{syntax/modules:syntax-tableidx}]{\sphinxcrossref{\DUrole{std,std-ref}{table indices}}}},
starting with the smallest index not referencing a table {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{import}}}}.
Most constructs implicitly reference table index \(0\).

\begin{sphinxadmonition}{note}{Note:}
In the current version of WebAssembly, at most one table may be defined or imported in a single module,
and \sphinxstyleemphasis{all} constructs implicitly reference this table \(0\).
This restriction may be lifted in future versions.
\end{sphinxadmonition}

\index{memory|textbf}\index{memory index}\index{memory type}\index{limits}\index{page size}\index{data}\index{import}\index{abstract syntax!memory}\index{memory!abstract syntax}\ignorespaces 

\subsection{Memories}
\label{\detokenize{syntax/modules:syntax-mem}}\label{\detokenize{syntax/modules:memories}}\label{\detokenize{syntax/modules:index-5}}
The \(\hyperref[syntax/modules:syntax-module]{\mathsf{mems}}\) component of a module defines a vector of \sphinxstyleemphasis{linear memories} (or \sphinxstyleemphasis{memories} for short) as described by their {\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory type}}}}:
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2132#1{{}}\mathdef2132{memory} & \hyperref[syntax/modules:syntax-mem]{\mathit{mem}} &::=&
  \{ \hyperref[syntax/modules:syntax-mem]{\mathsf{type}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}} \} \\
\end{array}\end{split}
\end{equation*}
A memory is a vector of raw uninterpreted bytes.
The \(\hyperref[syntax/types:syntax-limits]{\mathsf{min}}\) size in the {\hyperref[\detokenize{syntax/types:syntax-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{limits}}}} of the memory type specifies the initial size of that memory, while its \(\hyperref[syntax/types:syntax-limits]{\mathsf{max}}\), if present, restricts the size to which it can grow later.
Both are in units of {\hyperref[\detokenize{exec/runtime:page-size}]{\sphinxcrossref{\DUrole{std,std-ref}{page size}}}}.

Memories can be initialized through {\hyperref[\detokenize{syntax/modules:syntax-data}]{\sphinxcrossref{\DUrole{std,std-ref}{data segments}}}}.

Memories are referenced through {\hyperref[\detokenize{syntax/modules:syntax-memidx}]{\sphinxcrossref{\DUrole{std,std-ref}{memory indices}}}},
starting with the smallest index not referencing a memory {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{import}}}}.
Most constructs implicitly reference memory index \(0\).

\begin{sphinxadmonition}{note}{Note:}
In the current version of WebAssembly, at most one memory may be defined or imported in a single module,
and \sphinxstyleemphasis{all} constructs implicitly reference this memory \(0\).
This restriction may be lifted in future versions.
\end{sphinxadmonition}

\index{global|textbf}\index{global index}\index{global type}\index{mutability}\index{expression}\index{constant}\index{value}\index{import}\index{abstract syntax!global}\index{global!abstract syntax}\ignorespaces 

\subsection{Globals}
\label{\detokenize{syntax/modules:syntax-global}}\label{\detokenize{syntax/modules:globals}}\label{\detokenize{syntax/modules:index-6}}
The \(\hyperref[syntax/modules:syntax-module]{\mathsf{globals}}\) component of a module defines a vector of \sphinxstyleemphasis{global variables} (or \sphinxstyleemphasis{globals} for short):
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2132#1{{}}\mathdef2132{global} & \hyperref[syntax/modules:syntax-global]{\mathit{global}} &::=&
  \{ \hyperref[syntax/modules:syntax-global]{\mathsf{type}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}, \hyperref[syntax/modules:syntax-global]{\mathsf{init}}~\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}} \} \\
\end{array}\end{split}
\end{equation*}
Each global stores a single value of the given {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global type}}}}.
Its \(\hyperref[syntax/modules:syntax-global]{\mathsf{type}}\) also specifies whether a global is immutable or mutable.
Moreover, each global is initialized with an \(\hyperref[syntax/modules:syntax-global]{\mathsf{init}}\) value given by a {\hyperref[\detokenize{valid/instructions:valid-constant}]{\sphinxcrossref{\DUrole{std,std-ref}{constant}}}} initializer {\hyperref[\detokenize{syntax/instructions:syntax-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{expression}}}}.

Globals are referenced through {\hyperref[\detokenize{syntax/modules:syntax-globalidx}]{\sphinxcrossref{\DUrole{std,std-ref}{global indices}}}},
starting with the smallest index not referencing a global {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{import}}}}.

\index{element|textbf}\index{table}\index{table index}\index{expression}\index{constant}\index{function index}\index{vector}\index{abstract syntax!element}\index{element!abstract syntax}\index{table!element}\index{element!segment}\ignorespaces 

\subsection{Element Segments}
\label{\detokenize{syntax/modules:element-segments}}\label{\detokenize{syntax/modules:syntax-elem}}\label{\detokenize{syntax/modules:index-7}}
The initial contents of a table is uninitialized.
The \(\hyperref[syntax/modules:syntax-module]{\mathsf{elem}}\) component of a module defines a vector of \sphinxstyleemphasis{element segments} that initialize a subrange of a table, at a given offset, from a static {\hyperref[\detokenize{syntax/conventions:syntax-vec}]{\sphinxcrossref{\DUrole{std,std-ref}{vector}}}} of elements.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2132#1{{}}\mathdef2132{element segment} & \hyperref[syntax/modules:syntax-elem]{\mathit{elem}} &::=&
  \{ \hyperref[syntax/modules:syntax-elem]{\mathsf{table}}~\hyperref[syntax/modules:syntax-tableidx]{\mathit{tableidx}}, \hyperref[syntax/modules:syntax-elem]{\mathsf{offset}}~\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}}, \hyperref[syntax/modules:syntax-elem]{\mathsf{init}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/modules:syntax-funcidx]{\mathit{funcidx}}) \} \\
\end{array}\end{split}
\end{equation*}
The \(\hyperref[syntax/modules:syntax-elem]{\mathsf{offset}}\) is given by a {\hyperref[\detokenize{valid/instructions:valid-constant}]{\sphinxcrossref{\DUrole{std,std-ref}{constant}}}} {\hyperref[\detokenize{syntax/instructions:syntax-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{expression}}}}.

\begin{sphinxadmonition}{note}{Note:}
In the current version of WebAssembly, at most one table is allowed in a module.
Consequently, the only valid \(\hyperref[syntax/modules:syntax-tableidx]{\mathit{tableidx}}\) is \(0\).
\end{sphinxadmonition}

\index{data|textbf}\index{memory}\index{memory index}\index{expression}\index{constant}\index{byte}\index{vector}\index{abstract syntax!data}\index{data!abstract syntax}\index{memory!data}\index{data!segment}\ignorespaces 

\subsection{Data Segments}
\label{\detokenize{syntax/modules:index-8}}\label{\detokenize{syntax/modules:syntax-data}}\label{\detokenize{syntax/modules:data-segments}}
The initial contents of a {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memory}}}} are zero-valued bytes.
The \(\hyperref[syntax/modules:syntax-module]{\mathsf{data}}\) component of a module defines a vector of \sphinxstyleemphasis{data segments} that initialize a range of memory, at a given offset, with a static {\hyperref[\detokenize{syntax/conventions:syntax-vec}]{\sphinxcrossref{\DUrole{std,std-ref}{vector}}}} of {\hyperref[\detokenize{syntax/values:syntax-byte}]{\sphinxcrossref{\DUrole{std,std-ref}{bytes}}}}.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2132#1{{}}\mathdef2132{data segment} & \hyperref[syntax/modules:syntax-data]{\mathit{data}} &::=&
  \{ \hyperref[syntax/modules:syntax-data]{\mathsf{data}}~\hyperref[syntax/modules:syntax-memidx]{\mathit{memidx}}, \hyperref[syntax/modules:syntax-data]{\mathsf{offset}}~\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}}, \hyperref[syntax/modules:syntax-data]{\mathsf{init}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/values:syntax-byte]{\mathit{byte}}) \} \\
\end{array}\end{split}
\end{equation*}
The \(\hyperref[syntax/modules:syntax-data]{\mathsf{offset}}\) is given by a {\hyperref[\detokenize{valid/instructions:valid-constant}]{\sphinxcrossref{\DUrole{std,std-ref}{constant}}}} {\hyperref[\detokenize{syntax/instructions:syntax-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{expression}}}}.

\begin{sphinxadmonition}{note}{Note:}
In the current version of WebAssembly, at most one memory is allowed in a module.
Consequently, the only valid \(\hyperref[syntax/modules:syntax-memidx]{\mathit{memidx}}\) is \(0\).
\end{sphinxadmonition}

\index{start function|textbf}\index{function}\index{function index}\index{table}\index{memory}\index{instantiation}\index{abstract syntax!start function}\index{start function!abstract syntax}\ignorespaces 

\subsection{Start Function}
\label{\detokenize{syntax/modules:start-function}}\label{\detokenize{syntax/modules:syntax-start}}\label{\detokenize{syntax/modules:index-9}}
The \(\hyperref[syntax/modules:syntax-module]{\mathsf{start}}\) component of a module declares the {\hyperref[\detokenize{syntax/modules:syntax-funcidx}]{\sphinxcrossref{\DUrole{std,std-ref}{function index}}}} of a \sphinxstyleemphasis{start function} that is automatically invoked when the module is {\hyperref[\detokenize{exec/modules:exec-instantiation}]{\sphinxcrossref{\DUrole{std,std-ref}{instantiated}}}}, after {\hyperref[\detokenize{syntax/modules:syntax-table}]{\sphinxcrossref{\DUrole{std,std-ref}{tables}}}} and {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memories}}}} have been initialized.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2132#1{{}}\mathdef2132{start function} & \hyperref[syntax/modules:syntax-start]{\mathit{start}} &::=&
  \{ \hyperref[syntax/modules:syntax-start]{\mathsf{func}}~\hyperref[syntax/modules:syntax-funcidx]{\mathit{funcidx}} \} \\
\end{array}\end{split}
\end{equation*}
\index{export|textbf}\index{name}\index{index}\index{function index}\index{table index}\index{memory index}\index{global index}\index{function}\index{table}\index{memory}\index{global}\index{instantiation}\index{abstract syntax!export}\index{export!abstract syntax}\index{function!export}\index{table!export}\index{memory!export}\index{global!export}\ignorespaces \phantomsection\label{\detokenize{syntax/modules:syntax-exportdesc}}

\subsection{Exports}
\label{\detokenize{syntax/modules:index-10}}\label{\detokenize{syntax/modules:exports}}\label{\detokenize{syntax/modules:syntax-exportdesc}}\label{\detokenize{syntax/modules:syntax-export}}
The \(\hyperref[syntax/modules:syntax-module]{\mathsf{exports}}\) component of a module defines a set of \sphinxstyleemphasis{exports} that become accessible to the host environment once the module has been {\hyperref[\detokenize{exec/modules:exec-instantiation}]{\sphinxcrossref{\DUrole{std,std-ref}{instantiated}}}}.
\begin{equation*}
\begin{split}\begin{array}{llcl}
\def\mathdef2132#1{{}}\mathdef2132{export} & \hyperref[syntax/modules:syntax-export]{\mathit{export}} &::=&
  \{ \hyperref[syntax/modules:syntax-export]{\mathsf{name}}~\hyperref[syntax/values:syntax-name]{\mathit{name}}, \hyperref[syntax/modules:syntax-export]{\mathsf{desc}}~\hyperref[syntax/modules:syntax-exportdesc]{\mathit{exportdesc}} \} \\
\def\mathdef2132#1{{}}\mathdef2132{export description} & \hyperref[syntax/modules:syntax-exportdesc]{\mathit{exportdesc}} &::=&
  \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{func}}~\hyperref[syntax/modules:syntax-funcidx]{\mathit{funcidx}} \\&&|&
  \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{table}}~\hyperref[syntax/modules:syntax-tableidx]{\mathit{tableidx}} \\&&|&
  \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{mem}}~\hyperref[syntax/modules:syntax-memidx]{\mathit{memidx}} \\&&|&
  \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{global}}~\hyperref[syntax/modules:syntax-globalidx]{\mathit{globalidx}} \\
\end{array}\end{split}
\end{equation*}
Each export is labeled by a unique {\hyperref[\detokenize{syntax/values:syntax-name}]{\sphinxcrossref{\DUrole{std,std-ref}{name}}}}.
Exportable definitions are {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{functions}}}}, {\hyperref[\detokenize{syntax/modules:syntax-table}]{\sphinxcrossref{\DUrole{std,std-ref}{tables}}}}, {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memories}}}}, and {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{globals}}}},
which are referenced through a respective descriptor.


\subsubsection{Conventions}
\label{\detokenize{syntax/modules:id1}}
The following auxiliary notation is defined for sequences of exports, filtering out indices of a specific kind in an order-preserving fashion:
\begin{itemize}
\item {} 
\(\hyperref[syntax/modules:syntax-exportdesc]{\mathrm{funcs}}(\hyperref[syntax/modules:syntax-export]{\mathit{export}}^\ast) = [\hyperref[syntax/modules:syntax-funcidx]{\mathit{funcidx}} ~|~ \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{func}}~\hyperref[syntax/modules:syntax-funcidx]{\mathit{funcidx}} \in (\hyperref[syntax/modules:syntax-export]{\mathit{export}}.\hyperref[syntax/modules:syntax-export]{\mathsf{desc}})^\ast]\)

\item {} 
\(\hyperref[syntax/modules:syntax-exportdesc]{\mathrm{tables}}(\hyperref[syntax/modules:syntax-export]{\mathit{export}}^\ast) = [\hyperref[syntax/modules:syntax-tableidx]{\mathit{tableidx}} ~|~ \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{table}}~\hyperref[syntax/modules:syntax-tableidx]{\mathit{tableidx}} \in (\hyperref[syntax/modules:syntax-export]{\mathit{export}}.\hyperref[syntax/modules:syntax-export]{\mathsf{desc}})^\ast]\)

\item {} 
\(\hyperref[syntax/modules:syntax-exportdesc]{\mathrm{mems}}(\hyperref[syntax/modules:syntax-export]{\mathit{export}}^\ast) = [\hyperref[syntax/modules:syntax-memidx]{\mathit{memidx}} ~|~ \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{mem}}~\hyperref[syntax/modules:syntax-memidx]{\mathit{memidx}} \in (\hyperref[syntax/modules:syntax-export]{\mathit{export}}.\hyperref[syntax/modules:syntax-export]{\mathsf{desc}})^\ast]\)

\item {} 
\(\hyperref[syntax/modules:syntax-exportdesc]{\mathrm{globals}}(\hyperref[syntax/modules:syntax-export]{\mathit{export}}^\ast) = [\hyperref[syntax/modules:syntax-globalidx]{\mathit{globalidx}} ~|~ \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{global}}~\hyperref[syntax/modules:syntax-globalidx]{\mathit{globalidx}} \in (\hyperref[syntax/modules:syntax-export]{\mathit{export}}.\hyperref[syntax/modules:syntax-export]{\mathsf{desc}})^\ast]\)

\end{itemize}

\index{import|textbf}\index{name}\index{function type}\index{table type}\index{memory type}\index{global type}\index{index}\index{index space}\index{type index}\index{function index}\index{table index}\index{memory index}\index{global index}\index{function}\index{table}\index{memory}\index{global}\index{instantiation}\index{abstract syntax!import}\index{import!abstract syntax}\index{function!import}\index{table!import}\index{memory!import}\index{global!import}\ignorespaces \phantomsection\label{\detokenize{syntax/modules:syntax-importdesc}}

\subsection{Imports}
\label{\detokenize{syntax/modules:syntax-import}}\label{\detokenize{syntax/modules:syntax-importdesc}}\label{\detokenize{syntax/modules:index-11}}\label{\detokenize{syntax/modules:imports}}
The \(\hyperref[syntax/modules:syntax-module]{\mathsf{imports}}\) component of a module defines a set of \sphinxstyleemphasis{imports} that are required for {\hyperref[\detokenize{exec/modules:exec-instantiation}]{\sphinxcrossref{\DUrole{std,std-ref}{instantiation}}}}.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2132#1{{}}\mathdef2132{import} & \hyperref[syntax/modules:syntax-import]{\mathit{import}} &::=&
  \{ \hyperref[syntax/modules:syntax-import]{\mathsf{module}}~\hyperref[syntax/values:syntax-name]{\mathit{name}}, \hyperref[syntax/modules:syntax-import]{\mathsf{name}}~\hyperref[syntax/values:syntax-name]{\mathit{name}}, \hyperref[syntax/modules:syntax-import]{\mathsf{desc}}~\hyperref[syntax/modules:syntax-importdesc]{\mathit{importdesc}} \} \\
\def\mathdef2132#1{{}}\mathdef2132{import description} & \hyperref[syntax/modules:syntax-importdesc]{\mathit{importdesc}} &::=&
  \hyperref[syntax/modules:syntax-importdesc]{\mathsf{func}}~\hyperref[syntax/modules:syntax-typeidx]{\mathit{typeidx}} \\&&|&
  \hyperref[syntax/modules:syntax-importdesc]{\mathsf{table}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}} \\&&|&
  \hyperref[syntax/modules:syntax-importdesc]{\mathsf{mem}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}} \\&&|&
  \hyperref[syntax/modules:syntax-importdesc]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}} \\
\end{array}\end{split}
\end{equation*}
Each import is labeled by a two-level {\hyperref[\detokenize{syntax/values:syntax-name}]{\sphinxcrossref{\DUrole{std,std-ref}{name}}}} space, consisting of a \(\hyperref[syntax/modules:syntax-import]{\mathsf{module}}\) name and a \(\hyperref[syntax/modules:syntax-import]{\mathsf{name}}\) for an entity within that module.
Importable definitions are {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{functions}}}}, {\hyperref[\detokenize{syntax/modules:syntax-table}]{\sphinxcrossref{\DUrole{std,std-ref}{tables}}}}, {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memories}}}}, and {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{globals}}}}.
Each import is specified by a descriptor with a respective type that a definition provided during instantiation is required to match.

Every import defines an index in the respective {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{index space}}}}.
In each index space, the indices of imports go before the first index of any definition contained in the module itself.

\begin{sphinxadmonition}{note}{Note:}
Unlike export names, import names are not necessarily unique.
It is possible to import the same \(\hyperref[syntax/modules:syntax-import]{\mathsf{module}}\)/\(\hyperref[syntax/modules:syntax-import]{\mathsf{name}}\) pair multiple times;
such imports may even have different type descriptions, including different kinds of entities.
A module with such imports can still be instantiated depending on the specifics of how an {\hyperref[\detokenize{intro/overview:embedder}]{\sphinxcrossref{\DUrole{std,std-ref}{embedder}}}} allows resolving and supplying imports.
However, embedders are not required to support such overloading,
and a WebAssembly module itself cannot implement an overloaded name.
\end{sphinxadmonition}


\chapter{Validation}
\label{\detokenize{valid/index:validation}}\label{\detokenize{valid/index::doc}}\label{\detokenize{valid/index:valid}}
\index{validation|textbf}\index{type system|textbf}\index{function type}\index{table type}\index{memory type}\index{globaltype}\index{valtype}\index{resulttype}\index{index space}\index{instantiation. module}\ignorespaces 

\section{Conventions}
\label{\detokenize{valid/conventions:conventions}}\label{\detokenize{valid/conventions::doc}}\label{\detokenize{valid/conventions:index-0}}\label{\detokenize{valid/conventions:type-system}}
Validation checks that a WebAssembly module is well-formed.
Only valid modules can be {\hyperref[\detokenize{exec/modules:exec-instantiation}]{\sphinxcrossref{\DUrole{std,std-ref}{instantiated}}}}.

Validity is defined by a \sphinxstyleemphasis{type system} over the {\hyperref[\detokenize{syntax/index:syntax}]{\sphinxcrossref{\DUrole{std,std-ref}{abstract syntax}}}} of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}} and its contents.
For each piece of abstract syntax, there is a typing rule that specifies the constraints that apply to it.
All rules are given in two \sphinxstyleemphasis{equivalent} forms:
\begin{enumerate}
\item {} 
In \sphinxstyleemphasis{prose}, describing the meaning in intuitive form.

\item {} 
In \sphinxstyleemphasis{formal notation}, describing the rule in mathematical form. %
\begin{footnote}[13]\sphinxAtStartFootnote
The semantics is derived from the following article:
Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke Wagner, Alon Zakai, JF Bastien, Michael Holman. \sphinxhref{https://dl.acm.org/citation.cfm?doid=3062341.3062363}{Bringing the Web up to Speed with WebAssembly}. Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.
%
\end{footnote}

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
The prose and formal rules are equivalent,
so that understanding of the formal notation is \sphinxstyleemphasis{not} required to read this specification.
The formalism offers a more concise description in notation that is used widely in programming languages semantics and is readily amenable to mathematical proof.
\end{sphinxadmonition}

In both cases, the rules are formulated in a \sphinxstyleemphasis{declarative} manner.
That is, they only formulate the constraints, they do not define an algorithm.
The skeleton of a sound and complete algorithm for type-checking instruction sequences according to this specification is provided in the {\hyperref[\detokenize{appendix/algorithm:algo-valid}]{\sphinxcrossref{\DUrole{std,std-ref}{appendix}}}}.

\index{context|textbf}\index{function type}\index{table type}\index{memory type}\index{global type}\index{value type}\index{result type}\index{index space}\index{module}\index{function}\ignorespaces 

\subsection{Contexts}
\label{\detokenize{valid/conventions:context}}\label{\detokenize{valid/conventions:contexts}}\label{\detokenize{valid/conventions:index-1}}
Validity of an individual definition is specified relative to a \sphinxstyleemphasis{context},
which collects relevant information about the surrounding {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}} and the definitions in scope:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Types}: the list of types defined in the current module.

\item {} 
\sphinxstyleemphasis{Functions}: the list of functions declared in the current module, represented by their function type.

\item {} 
\sphinxstyleemphasis{Tables}: the list of tables declared in the current module, represented by their table type.

\item {} 
\sphinxstyleemphasis{Memories}: the list of memories declared in the current module, represented by their memory type.

\item {} 
\sphinxstyleemphasis{Globals}: the list of globals declared in the current module, represented by their global type.

\item {} 
\sphinxstyleemphasis{Locals}: the list of locals declared in the current function (including parameters), represented by their value type.

\item {} 
\sphinxstyleemphasis{Labels}: the stack of labels accessible from the current position, represented by their result type.

\item {} 
\sphinxstyleemphasis{Return}: the return type of the current function, represented as an optional result type that is absent when no return is allowed, as in free-standing expressions.

\end{itemize}

In other words, a context contains a sequence of suitable {\hyperref[\detokenize{syntax/types:syntax-type}]{\sphinxcrossref{\DUrole{std,std-ref}{types}}}} for each {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{index space}}}},
describing each defined entry in that space.
Locals, labels and return type are only used for validating {\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instructions}}}} in {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function bodies}}}}, and are left empty elsewhere.
The label stack is the only part of the context that changes as validation of an instruction sequence proceeds.

More concretely, contexts are defined as {\hyperref[\detokenize{syntax/conventions:notation-record}]{\sphinxcrossref{\DUrole{std,std-ref}{records}}}} \(C\) with abstract syntax:
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef3399#1{{}}\mathdef3399{(context)} & C &::=&
  \begin{array}[t]{l@{~}ll}
  \{ & \hyperref[valid/conventions:context]{\mathsf{types}} & \hyperref[syntax/types:syntax-functype]{\mathit{functype}}^\ast, \\
     & \hyperref[valid/conventions:context]{\mathsf{funcs}} & \hyperref[syntax/types:syntax-functype]{\mathit{functype}}^\ast, \\
     & \hyperref[valid/conventions:context]{\mathsf{tables}} & \hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}^\ast, \\
     & \hyperref[valid/conventions:context]{\mathsf{mems}} & \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}^\ast, \\
     & \hyperref[valid/conventions:context]{\mathsf{globals}} & \hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}^\ast, \\
     & \hyperref[valid/conventions:context]{\mathsf{locals}} & \hyperref[syntax/types:syntax-valtype]{\mathit{valtype}}^\ast, \\
     & \hyperref[valid/conventions:context]{\mathsf{labels}} & \hyperref[syntax/types:syntax-resulttype]{\mathit{resulttype}}^\ast, \\
     & \hyperref[valid/conventions:context]{\mathsf{return}} & \hyperref[syntax/types:syntax-resulttype]{\mathit{resulttype}}^? ~\} \\
  \end{array}
\end{array}\end{split}
\end{equation*}\phantomsection\label{\detokenize{valid/conventions:notation-extend}}
In addition to field access written \(C.\mathsf{field}\) the following notation is adopted for manipulating contexts:
\begin{itemize}
\item {} 
When spelling out a context, empty fields are omitted.

\item {} 
\(C,\mathsf{field}\,A^\ast\) denotes the same context as \(C\) but with the elements \(A^\ast\) prepended to its \(\mathsf{field}\) component sequence.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
We use {\hyperref[\detokenize{syntax/conventions:notation-index}]{\sphinxcrossref{\DUrole{std,std-ref}{indexing notation}}}} like \(C.\hyperref[valid/conventions:context]{\mathsf{labels}}[i]\) to look up indices in their respective {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{index space}}}} in the context.
Context extension notation \(C,\mathsf{field}\,A\) is primarily used to locally extend \sphinxstyleemphasis{relative} index spaces, such as {\hyperref[\detokenize{syntax/modules:syntax-labelidx}]{\sphinxcrossref{\DUrole{std,std-ref}{label indices}}}}.
Accordingly, the notation is defined to append at the \sphinxstyleemphasis{front} of the respective sequence, introducing a new relative index \(0\) and shifting the existing ones.
\end{sphinxadmonition}


\subsection{Prose Notation}
\label{\detokenize{valid/conventions:valid-notation-textual}}\label{\detokenize{valid/conventions:prose-notation}}
Validation is specified by stylised rules for each relevant part of the {\hyperref[\detokenize{syntax/index:syntax}]{\sphinxcrossref{\DUrole{std,std-ref}{abstract syntax}}}}.
The rules not only state constraints defining when a phrase is valid,
they also classify it with a type.
The following conventions are adopted in stating these rules.
\begin{itemize}
\item {} 
A phrase \(A\) is said to be “valid with type \(T\)”
if and only if all constraints expressed by the respective rules are met.
The form of \(T\) depends on what \(A\) is.

\begin{sphinxadmonition}{note}{Note:}
For example, if \(A\) is a {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}},
then  \(T\) is a {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}};
for an \(A\) that is a {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}},
\(T\) is a {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global type}}}};
and so on.
\end{sphinxadmonition}

\item {} 
The rules implicitly assume a given {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} \(C\).

\item {} 
In some places, this context is locally extended to a context \(C'\) with additional entries.
The formulation “Under context \(C'\), … \sphinxstyleemphasis{statement} …” is adopted to express that the following statement must apply under the assumptions embodied in the extended context.

\end{itemize}

\index{typing rules|textbf}\ignorespaces 

\subsection{Formal Notation}
\label{\detokenize{valid/conventions:formal-notation}}\label{\detokenize{valid/conventions:valid-notation}}\label{\detokenize{valid/conventions:index-2}}
\begin{sphinxadmonition}{note}{Note:}
This section gives a brief explanation of the notation for specifying typing rules formally.
For the interested reader, a more thorough introduction can be found in respective text books. %
\begin{footnote}[15]\sphinxAtStartFootnote
For example: Benjamin Pierce. \sphinxhref{https://www.cis.upenn.edu/~bcpierce/tapl/}{Types and Programming Languages}. The MIT Press 2002
%
\end{footnote}
\end{sphinxadmonition}

The proposition that a phrase \(A\) has a respective type \(T\) is written \(A : T\).
In general, however, typing is dependent on a context \(C\).
To express this explicitly, the complete form is a \sphinxstyleemphasis{judgement} \(C \vdash A : T\),
which says that \(A : T\) holds under the assumptions encoded in \(C\).

The formal typing rules use a standard approach for specifying type systems, rendering them into \sphinxstyleemphasis{deduction rules}.
Every rule has the following general form:
\begin{equation*}
\begin{split}\frac{
  \mathit{premise}_1 \qquad \mathit{premise}_2 \qquad \dots \qquad \mathit{premise}_n
}{
  \mathit{conclusion}
}\end{split}
\end{equation*}
Such a rule is read as a big implication: if all premises hold, then the conclusion holds.
Some rules have no premises; they are \sphinxstyleemphasis{axioms} whose conclusion holds unconditionally.
The conclusion always is a judgment \(C \vdash A : T\),
and there is one respective rule for each relevant construct \(A\) of the abstract syntax.

\begin{sphinxadmonition}{note}{Note:}
For example, the typing rule for the \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}}\) instruction can be given as an axiom:
\begin{equation*}
\begin{split}\frac{
}{
  C \vdash \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}} : [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]
}\end{split}
\end{equation*}
The instruction is always valid with type \([\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\){]}
(saying that it consumes two \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\) values and produces one),
independent of any side conditions.

An instruction like \(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.get}}\) can be typed as follows:
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{locals}}[x] = t
}{
  C \vdash \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.get}}~x : [] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]
}\end{split}
\end{equation*}
Here, the premise enforces that the immediate {\hyperref[\detokenize{syntax/modules:syntax-localidx}]{\sphinxcrossref{\DUrole{std,std-ref}{local index}}}} \(x\) exists in the context.
The instruction produces a value of its respective type \(t\)
(and does not consume any values).
If \(C.\hyperref[valid/conventions:context]{\mathsf{locals}}[x]\) does not exist then the premise does not hold,
and the instruction is ill-typed.

Finally, a {\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{structured}}}} instruction requires
a recursive rule, where the premise is itself a typing judgement:
\begin{equation*}
\begin{split}\frac{
  C \vdash \hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}} : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
  \qquad
  C,\hyperref[exec/runtime:syntax-label]{\mathsf{label}}\,[t_2^\ast] \vdash \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}{
  C \vdash \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}~\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}
A \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}\) instruction is only valid when the instruction sequence in its body is.
Moreover, the result type must match the block’s annotation \(\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}}\).
If so, then the \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}\) instruction has the same type as the body.
Inside the body an additional label of the corresponding result type is available,
which is expressed by extending the context \(C\) with the additional label information for the premise.
\end{sphinxadmonition}


\section{Types}
\label{\detokenize{valid/types:types}}\label{\detokenize{valid/types::doc}}
Most {\hyperref[\detokenize{syntax/types:syntax-type}]{\sphinxcrossref{\DUrole{std,std-ref}{types}}}} are universally valid.
However, restrictions apply to {\hyperref[\detokenize{syntax/types:syntax-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{limits}}}}, which must be checked during validation.
Moreover, {\hyperref[\detokenize{syntax/instructions:syntax-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{block types}}}} are converted to plain {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function types}}}} for ease of processing.

\index{limits}\index{validation!limits}\index{limits!validation}\index{abstract syntax!limits}\ignorespaces 

\subsection{Limits}
\label{\detokenize{valid/types:valid-limits}}\label{\detokenize{valid/types:index-0}}\label{\detokenize{valid/types:limits}}
{\hyperref[\detokenize{syntax/types:syntax-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{Limits}}}} must have meaningful bounds that are within a given range.


\subsubsection{\protect\(\{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^? \}\protect\)}
\label{\detokenize{valid/types:id1}}\begin{itemize}
\item {} 
The value of \(n\) must not be larger than \(k\).

\item {} 
If the maximum \(m^?\) is not empty, then:
\begin{itemize}
\item {} 
Its value must not be larger than \(k\).

\item {} 
Its value must not be smaller than \(n\).

\end{itemize}

\item {} 
Then the limit is valid within range \(k\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  n \leq k
  \qquad
  (m \leq k)^?
  \qquad
  (n \leq m)^?
}{
  \hyperref[valid/types:valid-limits]{\vdash} \{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^? \} : k
}\end{split}
\end{equation*}
\index{block type}\index{validation!block type}\index{block type!validation}\index{abstract syntax!block type}\ignorespaces 

\subsection{Block Types}
\label{\detokenize{valid/types:index-1}}\label{\detokenize{valid/types:valid-blocktype}}\label{\detokenize{valid/types:block-types}}
{\hyperref[\detokenize{syntax/instructions:syntax-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{Block types}}}} may be expressed in one of two forms, both of which are converted to plain {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function types}}}} by the following rules.


\subsubsection{\protect\(\hyperref[syntax/modules:syntax-typeidx]{\mathit{typeidx}}\protect\)}
\label{\detokenize{valid/types:id2}}\begin{itemize}
\item {} 
The type \(C.\hyperref[valid/conventions:context]{\mathsf{types}}[\hyperref[syntax/modules:syntax-typeidx]{\mathit{typeidx}}]\) must be defined in the context.

\item {} 
Then the block type is valid as {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(C.\hyperref[valid/conventions:context]{\mathsf{types}}[\hyperref[syntax/modules:syntax-typeidx]{\mathit{typeidx}}]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{types}}[\hyperref[syntax/modules:syntax-typeidx]{\mathit{typeidx}}] = \hyperref[syntax/types:syntax-functype]{\mathit{functype}}
}{
  C \hyperref[valid/types:valid-blocktype]{\vdash} \hyperref[syntax/modules:syntax-typeidx]{\mathit{typeidx}} : \hyperref[syntax/types:syntax-functype]{\mathit{functype}}
}\end{split}
\end{equation*}

\subsubsection{\protect\([\hyperref[syntax/types:syntax-valtype]{\mathit{valtype}}^?]\protect\)}
\label{\detokenize{valid/types:id3}}\begin{itemize}
\item {} 
The block type is valid as {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathit{valtype}}^?]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  C \hyperref[valid/types:valid-blocktype]{\vdash} [\hyperref[syntax/types:syntax-valtype]{\mathit{valtype}}^?] : [] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathit{valtype}}^?]
}\end{split}
\end{equation*}
\index{table type}\index{element type}\index{limits}\index{validation!table type}\index{table type!validation}\index{abstract syntax!table type}\ignorespaces 

\subsection{Table Types}
\label{\detokenize{valid/types:index-2}}\label{\detokenize{valid/types:table-types}}\label{\detokenize{valid/types:valid-tabletype}}

\subsubsection{\protect\(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}~\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}}\protect\)}
\label{\detokenize{valid/types:id4}}\begin{itemize}
\item {} 
The limits \(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}\) must be {\hyperref[\detokenize{valid/types:valid-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} within range \(2^{32}\).

\item {} 
Then the table type is valid.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \hyperref[valid/types:valid-limits]{\vdash} \hyperref[syntax/types:syntax-limits]{\mathit{limits}} : 2^{32}
}{
  \hyperref[valid/types:valid-tabletype]{\vdash} \hyperref[syntax/types:syntax-limits]{\mathit{limits}}~\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}} \mathrel{\mbox{ok}}
}\end{split}
\end{equation*}
\index{memory type}\index{limits}\index{validation!memory type}\index{memory type!validation}\index{abstract syntax!memory type}\ignorespaces 

\subsection{Memory Types}
\label{\detokenize{valid/types:memory-types}}\label{\detokenize{valid/types:valid-memtype}}\label{\detokenize{valid/types:index-3}}

\subsubsection{\protect\(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}\protect\)}
\label{\detokenize{valid/types:id5}}\begin{itemize}
\item {} 
The limits \(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}\) must be {\hyperref[\detokenize{valid/types:valid-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} within range \(2^{16}\).

\item {} 
Then the memory type is valid.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \hyperref[valid/types:valid-limits]{\vdash} \hyperref[syntax/types:syntax-limits]{\mathit{limits}} : 2^{16}
}{
  \hyperref[valid/types:valid-memtype]{\vdash} \hyperref[syntax/types:syntax-limits]{\mathit{limits}} \mathrel{\mbox{ok}}
}\end{split}
\end{equation*}
\index{global type}\index{value type}\index{mutability}\index{validation!global type}\index{global type!validation}\index{abstract syntax!global type}\ignorespaces 

\subsection{Global Types}
\label{\detokenize{valid/types:valid-globaltype}}\label{\detokenize{valid/types:global-types}}\label{\detokenize{valid/types:index-4}}

\subsubsection{\protect\(\hyperref[syntax/types:syntax-mut]{\mathit{mut}}~\hyperref[syntax/types:syntax-valtype]{\mathit{valtype}}\protect\)}
\label{\detokenize{valid/types:id6}}\begin{itemize}
\item {} 
The global type is valid.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  \hyperref[valid/types:valid-globaltype]{\vdash} \hyperref[syntax/types:syntax-mut]{\mathit{mut}}~\hyperref[syntax/types:syntax-valtype]{\mathit{valtype}} \mathrel{\mbox{ok}}
}\end{split}
\end{equation*}
\index{instruction}\index{function type}\index{context}\index{value}\index{operand stack}\index{polymorphism|textbf}\ignorespaces 

\section{Instructions}
\label{\detokenize{valid/instructions:valid-instr}}\label{\detokenize{valid/instructions::doc}}\label{\detokenize{valid/instructions:index-0}}\label{\detokenize{valid/instructions:instructions}}
{\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{Instructions}}}} are classified by {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function types}}}} \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\)
that describe how they manipulate the {\hyperref[\detokenize{exec/runtime:stack}]{\sphinxcrossref{\DUrole{std,std-ref}{operand stack}}}}.
The types describe the required input stack with argument values of types \(t_1^\ast\) that an instruction pops off
and the provided output stack with result values of types \(t_2^\ast\) that it pushes back.

\begin{sphinxadmonition}{note}{Note:}
For example, the instruction \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}}\) has type \([\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]\),
consuming two \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\) values and producing one.
\end{sphinxadmonition}

Typing extends to {\hyperref[\detokenize{valid/instructions:valid-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{instruction sequences}}}} \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\).
Such a sequence has a {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\) if the accumulative effect of executing the instructions is consuming values of types \(t_1^\ast\) off the operand stack and pushing new values of types \(t_2^\ast\).

\phantomsection\label{\detokenize{valid/instructions:polymorphism}}
For some instructions, the typing rules do not fully constrain the type,
and therefore allow for multiple types.
Such instructions are called \sphinxstyleemphasis{polymorphic}.
Two degrees of polymorphism can be distinguished:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{value-polymorphic}:
the {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t\) of one or several individual operands is unconstrained.
That is the case for all {\hyperref[\detokenize{valid/instructions:valid-instr-parametric}]{\sphinxcrossref{\DUrole{std,std-ref}{parametric instructions}}}} like \(\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{drop}}\) and \(\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}}\).

\item {} 
\sphinxstyleemphasis{stack-polymorphic}:
the entire (or most of the) {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\) of the instruction is unconstrained.
That is the case for all {\hyperref[\detokenize{valid/instructions:valid-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{control instructions}}}} that perform an \sphinxstyleemphasis{unconditional control transfer}, such as \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}}\), \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}\), \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_table}}\), and \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{return}}\).

\end{itemize}

In both cases, the unconstrained types or type sequences can be chosen arbitrarily, as long as they meet the constraints imposed for the surrounding parts of the program.

\begin{sphinxadmonition}{note}{Note:}
For example, the \(\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}}\) instruction is valid with type \([t~t~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]\), for any possible {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t\).   Consequently, both instruction sequences
\begin{equation*}
\begin{split}(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~1)~~(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~2)~~(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~3)~~\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}}{}\end{split}
\end{equation*}
and
\begin{equation*}
\begin{split}(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~1.0)~~(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~2.0)~~(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~3)~~\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}}{}\end{split}
\end{equation*}
are valid, with \(t\) in the typing of \(\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}}\) being instantiated to \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\) or \(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}\), respectively.

The \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}}\) instruction is valid with type \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\) for any possible sequences of value types \(t_1^\ast\) and \(t_2^\ast\).
Consequently,
\begin{equation*}
\begin{split}\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}}~~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}}\end{split}
\end{equation*}
is valid by assuming type \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]\) for the \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}}\) instruction.
In contrast,
\begin{equation*}
\begin{split}\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}}~~(\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~0)~~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}}\end{split}
\end{equation*}
is invalid, because there is no possible type to pick for the \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}}\) instruction that would make the sequence well-typed.
\end{sphinxadmonition}

\index{numeric instruction}\index{validation!instruction}\index{instruction!validation}\index{abstract syntax!instruction}\ignorespaces 

\subsection{Numeric Instructions}
\label{\detokenize{valid/instructions:valid-instr-numeric}}\label{\detokenize{valid/instructions:numeric-instructions}}\label{\detokenize{valid/instructions:index-1}}

\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c\protect\)}
\label{\detokenize{valid/instructions:valid-const}}\label{\detokenize{valid/instructions:id1}}\begin{itemize}
\item {} 
The instruction is valid with type \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c : [] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]
}\end{split}
\end{equation*}

\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-unop]{\mathit{unop}}\protect\)}
\label{\detokenize{valid/instructions:id2}}\label{\detokenize{valid/instructions:valid-unop}}\begin{itemize}
\item {} 
The instruction is valid with type \([t] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} t\mathsf{.}\hyperref[syntax/instructions:syntax-unop]{\mathit{unop}} : [t] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]
}\end{split}
\end{equation*}

\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-binop]{\mathit{binop}}\protect\)}
\label{\detokenize{valid/instructions:id3}}\label{\detokenize{valid/instructions:valid-binop}}\begin{itemize}
\item {} 
The instruction is valid with type \([t~t] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} t\mathsf{.}\hyperref[syntax/instructions:syntax-binop]{\mathit{binop}} : [t~t] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]
}\end{split}
\end{equation*}

\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-testop]{\mathit{testop}}\protect\)}
\label{\detokenize{valid/instructions:id4}}\label{\detokenize{valid/instructions:valid-testop}}\begin{itemize}
\item {} 
The instruction is valid with type \([t] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} t\mathsf{.}\hyperref[syntax/instructions:syntax-testop]{\mathit{testop}} : [t] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]
}\end{split}
\end{equation*}

\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-relop]{\mathit{relop}}\protect\)}
\label{\detokenize{valid/instructions:valid-relop}}\label{\detokenize{valid/instructions:id5}}\begin{itemize}
\item {} 
The instruction is valid with type \([t~t] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} t\mathsf{.}\hyperref[syntax/instructions:syntax-relop]{\mathit{relop}} : [t~t] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]
}\end{split}
\end{equation*}

\subsubsection{\protect\(t_2\mathsf{.}\hyperref[syntax/instructions:syntax-cvtop]{\mathit{cvtop}}\mathsf{\_}t_1\mathsf{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}^?\protect\)}
\label{\detokenize{valid/instructions:valid-cvtop}}\label{\detokenize{valid/instructions:id6}}\begin{itemize}
\item {} 
The instruction is valid with type \([t_1] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} t_2\mathsf{.}\hyperref[syntax/instructions:syntax-cvtop]{\mathit{cvtop}}\mathsf{\_}t_1\mathsf{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}^? : [t_1] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2]
}\end{split}
\end{equation*}
\index{parametric instructions}\index{value type}\index{polymorphism}\index{validation!instruction}\index{instruction!validation}\index{abstract syntax!instruction}\ignorespaces 

\subsection{Parametric Instructions}
\label{\detokenize{valid/instructions:parametric-instructions}}\label{\detokenize{valid/instructions:index-2}}\label{\detokenize{valid/instructions:valid-instr-parametric}}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{drop}}\protect\)}
\label{\detokenize{valid/instructions:valid-drop}}\label{\detokenize{valid/instructions:id7}}\begin{itemize}
\item {} 
The instruction is valid with type \([t] \hyperref[syntax/types:syntax-functype]{\rightarrow} []\), for any {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{drop}} : [t] \hyperref[syntax/types:syntax-functype]{\rightarrow} []
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}}\protect\)}
\label{\detokenize{valid/instructions:valid-select}}\label{\detokenize{valid/instructions:id8}}\begin{itemize}
\item {} 
The instruction is valid with type \([t~t~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]\), for any {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}} : [t~t~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]
}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
Both \(\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{drop}}\) and \(\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}}\) are {\hyperref[\detokenize{valid/instructions:polymorphism}]{\sphinxcrossref{\DUrole{std,std-ref}{value-polymorphic}}}} instructions.
\end{sphinxadmonition}

\index{variable instructions}\index{local index}\index{global index}\index{context}\index{validation!instruction}\index{instruction!validation}\index{abstract syntax!instruction}\ignorespaces 

\subsection{Variable Instructions}
\label{\detokenize{valid/instructions:valid-instr-variable}}\label{\detokenize{valid/instructions:index-3}}\label{\detokenize{valid/instructions:variable-instructions}}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.get}}~x\protect\)}
\label{\detokenize{valid/instructions:id9}}\label{\detokenize{valid/instructions:valid-local-get}}\begin{itemize}
\item {} 
The local \(C.\hyperref[valid/conventions:context]{\mathsf{locals}}[x]\) must be defined in the context.

\item {} 
Let \(t\) be the {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(C.\hyperref[valid/conventions:context]{\mathsf{locals}}[x]\).

\item {} 
Then the instruction is valid with type \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{locals}}[x] = t
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.get}}~x : [] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.set}}~x\protect\)}
\label{\detokenize{valid/instructions:id10}}\label{\detokenize{valid/instructions:valid-local-set}}\begin{itemize}
\item {} 
The local \(C.\hyperref[valid/conventions:context]{\mathsf{locals}}[x]\) must be defined in the context.

\item {} 
Let \(t\) be the {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(C.\hyperref[valid/conventions:context]{\mathsf{locals}}[x]\).

\item {} 
Then the instruction is valid with type \([t] \hyperref[syntax/types:syntax-functype]{\rightarrow} []\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{locals}}[x] = t
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.set}}~x : [t] \hyperref[syntax/types:syntax-functype]{\rightarrow} []
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.tee}}~x\protect\)}
\label{\detokenize{valid/instructions:valid-local-tee}}\label{\detokenize{valid/instructions:id11}}\begin{itemize}
\item {} 
The local \(C.\hyperref[valid/conventions:context]{\mathsf{locals}}[x]\) must be defined in the context.

\item {} 
Let \(t\) be the {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(C.\hyperref[valid/conventions:context]{\mathsf{locals}}[x]\).

\item {} 
Then the instruction is valid with type \([t] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{locals}}[x] = t
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.tee}}~x : [t] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.get}}~x\protect\)}
\label{\detokenize{valid/instructions:id12}}\label{\detokenize{valid/instructions:valid-global-get}}\begin{itemize}
\item {} 
The global \(C.\hyperref[valid/conventions:context]{\mathsf{globals}}[x]\) must be defined in the context.

\item {} 
Let \(\hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t\) be the {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global type}}}} \(C.\hyperref[valid/conventions:context]{\mathsf{globals}}[x]\).

\item {} 
Then the instruction is valid with type \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{globals}}[x] = \hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.get}}~x : [] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.set}}~x\protect\)}
\label{\detokenize{valid/instructions:valid-global-set}}\label{\detokenize{valid/instructions:id13}}\begin{itemize}
\item {} 
The global \(C.\hyperref[valid/conventions:context]{\mathsf{globals}}[x]\) must be defined in the context.

\item {} 
Let \(\hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t\) be the {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global type}}}} \(C.\hyperref[valid/conventions:context]{\mathsf{globals}}[x]\).

\item {} 
The mutability \(\hyperref[syntax/types:syntax-mut]{\mathit{mut}}\) must be \(\hyperref[syntax/types:syntax-mut]{\mathsf{var}}\).

\item {} 
Then the instruction is valid with type \([t] \hyperref[syntax/types:syntax-functype]{\rightarrow} []\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{globals}}[x] = \hyperref[syntax/types:syntax-mut]{\mathsf{var}}~t
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.set}}~x : [t] \hyperref[syntax/types:syntax-functype]{\rightarrow} []
}\end{split}
\end{equation*}
\index{memory instruction}\index{memory index}\index{context}\index{validation!instruction}\index{instruction!validation}\index{abstract syntax!instruction}\ignorespaces \phantomsection\label{\detokenize{valid/instructions:valid-memarg}}

\subsection{Memory Instructions}
\label{\detokenize{valid/instructions:valid-memarg}}\label{\detokenize{valid/instructions:memory-instructions}}\label{\detokenize{valid/instructions:valid-instr-memory}}\label{\detokenize{valid/instructions:index-4}}

\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}\protect\)}
\label{\detokenize{valid/instructions:valid-load}}\label{\detokenize{valid/instructions:id14}}\begin{itemize}
\item {} 
The memory \(C.\hyperref[valid/conventions:context]{\mathsf{mems}}[0]\) must be defined in the context.

\item {} 
The alignment \(2^{\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{align}}}\) must not be larger than the {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{bit width}}}} of \(t\) divided by \(8\).

\item {} 
Then the instruction is valid with type \([\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{mems}}[0] = \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}
  \qquad
  2^{\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{align}}} \leq |t|/8
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} t\mathsf{.load}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} : [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]
}\end{split}
\end{equation*}

\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}{N}\mathsf{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}\protect\)}
\label{\detokenize{valid/instructions:valid-loadn}}\label{\detokenize{valid/instructions:id15}}\begin{itemize}
\item {} 
The memory \(C.\hyperref[valid/conventions:context]{\mathsf{mems}}[0]\) must be defined in the context.

\item {} 
The alignment \(2^{\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{align}}}\) must not be larger than \(N/8\).

\item {} 
Then the instruction is valid with type \([\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{mems}}[0] = \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}
  \qquad
  2^{\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{align}}} \leq N/8
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} t\mathsf{.load}N\mathsf{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} : [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t]
}\end{split}
\end{equation*}

\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}\protect\)}
\label{\detokenize{valid/instructions:id16}}\begin{itemize}
\item {} 
The memory \(C.\hyperref[valid/conventions:context]{\mathsf{mems}}[0]\) must be defined in the context.

\item {} 
The alignment \(2^{\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{align}}}\) must not be larger than the {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{bit width}}}} of \(t\) divided by \(8\).

\item {} 
Then the instruction is valid with type \([\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}~t] \hyperref[syntax/types:syntax-functype]{\rightarrow} []\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{mems}}[0] = \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}
  \qquad
  2^{\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{align}}} \leq |t|/8
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} t\mathsf{.store}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} : [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}~t] \hyperref[syntax/types:syntax-functype]{\rightarrow} []
}\end{split}
\end{equation*}

\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}{N}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}\protect\)}
\label{\detokenize{valid/instructions:id17}}\label{\detokenize{valid/instructions:valid-storen}}\begin{itemize}
\item {} 
The memory \(C.\hyperref[valid/conventions:context]{\mathsf{mems}}[0]\) must be defined in the context.

\item {} 
The alignment \(2^{\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{align}}}\) must not be larger than \(N/8\).

\item {} 
Then the instruction is valid with type \([\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}~t] \hyperref[syntax/types:syntax-functype]{\rightarrow} []\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{mems}}[0] = \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}
  \qquad
  2^{\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{align}}} \leq N/8
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} t\mathsf{.store}N~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}} : [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}~t] \hyperref[syntax/types:syntax-functype]{\rightarrow} []
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.size}}\protect\)}
\label{\detokenize{valid/instructions:id18}}\label{\detokenize{valid/instructions:valid-memory-size}}\begin{itemize}
\item {} 
The memory \(C.\hyperref[valid/conventions:context]{\mathsf{mems}}[0]\) must be defined in the context.

\item {} 
Then the instruction is valid with type \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{mems}}[0] = \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.size}} : [] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.grow}}\protect\)}
\label{\detokenize{valid/instructions:id19}}\label{\detokenize{valid/instructions:valid-memory-grow}}\begin{itemize}
\item {} 
The memory \(C.\hyperref[valid/conventions:context]{\mathsf{mems}}[0]\) must be defined in the context.

\item {} 
Then the instruction is valid with type \([\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{mems}}[0] = \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.grow}} : [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]
}\end{split}
\end{equation*}
\index{control instructions}\index{structured control}\index{label}\index{block}\index{branch}\index{block type}\index{result type}\index{label index}\index{function index}\index{type index}\index{vector}\index{polymorphism}\index{context}\index{validation!instruction}\index{instruction!validation}\index{abstract syntax!instruction}\ignorespaces \phantomsection\label{\detokenize{valid/instructions:valid-label}}

\subsection{Control Instructions}
\label{\detokenize{valid/instructions:valid-instr-control}}\label{\detokenize{valid/instructions:valid-label}}\label{\detokenize{valid/instructions:control-instructions}}\label{\detokenize{valid/instructions:index-5}}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{nop}}\protect\)}
\label{\detokenize{valid/instructions:id20}}\label{\detokenize{valid/instructions:valid-nop}}\begin{itemize}
\item {} 
The instruction is valid with type \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} []\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{nop}} : [] \hyperref[syntax/types:syntax-functype]{\rightarrow} []
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}}\protect\)}
\label{\detokenize{valid/instructions:valid-unreachable}}\label{\detokenize{valid/instructions:id21}}\begin{itemize}
\item {} 
The instruction is valid with type \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\), for any sequences of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} \(t_1^\ast\) and \(t_2^\ast\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}} : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}}\) instruction is {\hyperref[\detokenize{valid/instructions:polymorphism}]{\sphinxcrossref{\DUrole{std,std-ref}{stack-polymorphic}}}}.
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}~\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\protect\)}
\label{\detokenize{valid/instructions:id22}}\label{\detokenize{valid/instructions:valid-block}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{syntax/instructions:syntax-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{block type}}}} must be {\hyperref[\detokenize{valid/types:valid-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} as some {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).

\item {} 
Let \(C'\) be the same {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} as \(C\), but with the {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t_2^\ast]\) prepended to the \(\hyperref[valid/conventions:context]{\mathsf{labels}}\) vector.

\item {} 
Under context \(C'\),
the instruction sequence \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\) must be {\hyperref[\detokenize{valid/instructions:valid-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with type \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).

\item {} 
Then the compound instruction is valid with type \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C \hyperref[valid/types:valid-blocktype]{\vdash} \hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}} : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
  \qquad
  C,\hyperref[valid/conventions:context]{\mathsf{labels}}\,[t_2^\ast] \hyperref[valid/instructions:valid-instr-seq]{\vdash} \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}~\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The {\hyperref[\detokenize{valid/conventions:notation-extend}]{\sphinxcrossref{\DUrole{std,std-ref}{notation}}}} \(C,\hyperref[valid/conventions:context]{\mathsf{labels}}\,[t^\ast]\) inserts the new label type at index \(0\), shifting all others.
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{loop}}~\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\protect\)}
\label{\detokenize{valid/instructions:valid-loop}}\label{\detokenize{valid/instructions:id23}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{syntax/instructions:syntax-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{block type}}}} must be {\hyperref[\detokenize{valid/types:valid-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} as some {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).

\item {} 
Let \(C'\) be the same {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} as \(C\), but with the {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t_1^\ast]\) prepended to the \(\hyperref[valid/conventions:context]{\mathsf{labels}}\) vector.

\item {} 
Under context \(C'\),
the instruction sequence \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\) must be {\hyperref[\detokenize{valid/instructions:valid-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with type \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).

\item {} 
Then the compound instruction is valid with type \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C \hyperref[valid/types:valid-blocktype]{\vdash} \hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}} : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
  \qquad
  C,\hyperref[valid/conventions:context]{\mathsf{labels}}\,[t_1^\ast] \hyperref[valid/instructions:valid-instr-seq]{\vdash} \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{loop}}~\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The {\hyperref[\detokenize{valid/conventions:notation-extend}]{\sphinxcrossref{\DUrole{std,std-ref}{notation}}}} \(C,\hyperref[valid/conventions:context]{\mathsf{labels}}\,[t^\ast]\) inserts the new label type at index \(0\), shifting all others.
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}~\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_1^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{else}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_2^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\protect\)}
\label{\detokenize{valid/instructions:id24}}\label{\detokenize{valid/instructions:valid-if}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{syntax/instructions:syntax-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{block type}}}} must be {\hyperref[\detokenize{valid/types:valid-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} as some {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).

\item {} 
Let \(C'\) be the same {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} as \(C\), but with the {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t_2^\ast]\) prepended to the \(\hyperref[valid/conventions:context]{\mathsf{labels}}\) vector.

\item {} 
Under context \(C'\),
the instruction sequence \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_1^\ast\) must be {\hyperref[\detokenize{valid/instructions:valid-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with type \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).

\item {} 
Under context \(C'\),
the instruction sequence \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_2^\ast\) must be {\hyperref[\detokenize{valid/instructions:valid-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with type \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).

\item {} 
Then the compound instruction is valid with type \([t_1^\ast~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C \hyperref[valid/types:valid-blocktype]{\vdash} \hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}} : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
  \qquad
  C,\hyperref[valid/conventions:context]{\mathsf{labels}}\,[t_2^\ast] \hyperref[valid/instructions:valid-instr-seq]{\vdash} \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_1^\ast : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
  \qquad
  C,\hyperref[valid/conventions:context]{\mathsf{labels}}\,[t_2^\ast] \hyperref[valid/instructions:valid-instr-seq]{\vdash} \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_2^\ast : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}~\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_1^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{else}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_2^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} : [t_1^\ast~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The {\hyperref[\detokenize{valid/conventions:notation-extend}]{\sphinxcrossref{\DUrole{std,std-ref}{notation}}}} \(C,\hyperref[valid/conventions:context]{\mathsf{labels}}\,[t^\ast]\) inserts the new label type at index \(0\), shifting all others.
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}~l\protect\)}
\label{\detokenize{valid/instructions:valid-br}}\label{\detokenize{valid/instructions:id25}}\begin{itemize}
\item {} 
The label \(C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l]\) must be defined in the context.

\item {} 
Let \([t^\ast]\) be the {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \(C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l]\).

\item {} 
Then the instruction is valid with type \([t_1^\ast~t^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\), for any sequences of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} \(t_1^\ast\) and \(t_2^\ast\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l] = [t^\ast]
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}~l : [t_1^\ast~t^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The {\hyperref[\detokenize{syntax/modules:syntax-labelidx}]{\sphinxcrossref{\DUrole{std,std-ref}{label index}}}} space in the {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} \(C\) contains the most recent label first, so that \(C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l]\) performs a relative lookup as expected.

The \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}\) instruction is {\hyperref[\detokenize{valid/instructions:polymorphism}]{\sphinxcrossref{\DUrole{std,std-ref}{stack-polymorphic}}}}.
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_if}}~l\protect\)}
\label{\detokenize{valid/instructions:valid-br-if}}\label{\detokenize{valid/instructions:id26}}\begin{itemize}
\item {} 
The label \(C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l]\) must be defined in the context.

\item {} 
Let \([t^\ast]\) be the {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \(C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l]\).

\item {} 
Then the instruction is valid with type \([t^\ast~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t^\ast]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l] = [t^\ast]
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_if}}~l : [t^\ast~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t^\ast]
}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The {\hyperref[\detokenize{syntax/modules:syntax-labelidx}]{\sphinxcrossref{\DUrole{std,std-ref}{label index}}}} space in the {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} \(C\) contains the most recent label first, so that \(C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l]\) performs a relative lookup as expected.
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_table}}~l^\ast~l_N\protect\)}
\label{\detokenize{valid/instructions:id27}}\label{\detokenize{valid/instructions:valid-br-table}}\begin{itemize}
\item {} 
The label \(C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l_N]\) must be defined in the context.

\item {} 
Let \([t^\ast]\) be the {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \(C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l_N]\).

\item {} 
For all \(l_i\) in \(l^\ast\),
the label \(C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l_i]\) must be defined in the context.

\item {} 
For all \(l_i\) in \(l^\ast\),
\(C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l_i]\) must be \([t^\ast]\).

\item {} 
Then the instruction is valid with type \([t_1^\ast~t^\ast~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\), for any sequences of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} \(t_1^\ast\) and \(t_2^\ast\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  (C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l] = [t^\ast])^\ast
  \qquad
  C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l_N] = [t^\ast]
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_table}}~l^\ast~l_N : [t_1^\ast~t^\ast~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The {\hyperref[\detokenize{syntax/modules:syntax-labelidx}]{\sphinxcrossref{\DUrole{std,std-ref}{label index}}}} space in the {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} \(C\) contains the most recent label first, so that \(C.\hyperref[valid/conventions:context]{\mathsf{labels}}[l_i]\) performs a relative lookup as expected.

The \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_table}}\) instruction is {\hyperref[\detokenize{valid/instructions:polymorphism}]{\sphinxcrossref{\DUrole{std,std-ref}{stack-polymorphic}}}}.
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{return}}\protect\)}
\label{\detokenize{valid/instructions:id28}}\label{\detokenize{valid/instructions:valid-return}}\begin{itemize}
\item {} 
The return type \(C.\hyperref[valid/conventions:context]{\mathsf{return}}\) must not be absent in the context.

\item {} 
Let \([t^\ast]\) be the {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} of \(C.\hyperref[valid/conventions:context]{\mathsf{return}}\).

\item {} 
Then the instruction is valid with type \([t_1^\ast~t^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\), for any sequences of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} \(t_1^\ast\) and \(t_2^\ast\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{return}} = [t^\ast]
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{return}} : [t_1^\ast~t^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{return}}\) instruction is {\hyperref[\detokenize{valid/instructions:polymorphism}]{\sphinxcrossref{\DUrole{std,std-ref}{stack-polymorphic}}}}.

\(C.\hyperref[valid/conventions:context]{\mathsf{return}}\) is absent (set to \(\epsilon\)) when validating an {\hyperref[\detokenize{valid/instructions:valid-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{expression}}}} that is not a function body.
This differs from it being set to the empty result type (\([\epsilon]\)),
which is the case for functions not returning anything.
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call}}~x\protect\)}
\label{\detokenize{valid/instructions:valid-call}}\label{\detokenize{valid/instructions:id29}}\begin{itemize}
\item {} 
The function \(C.\hyperref[valid/conventions:context]{\mathsf{funcs}}[x]\) must be defined in the context.

\item {} 
Then the instruction is valid with type \(C.\hyperref[valid/conventions:context]{\mathsf{funcs}}[x]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{funcs}}[x] = [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call}}~x : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call\_indirect}}~x\protect\)}
\label{\detokenize{valid/instructions:id30}}\label{\detokenize{valid/instructions:valid-call-indirect}}\begin{itemize}
\item {} 
The table \(C.\hyperref[valid/conventions:context]{\mathsf{tables}}[0]\) must be defined in the context.

\item {} 
Let \(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}~\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}}\) be the {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table type}}}} \(C.\hyperref[valid/conventions:context]{\mathsf{tables}}[0]\).

\item {} 
The {\hyperref[\detokenize{syntax/types:syntax-elemtype}]{\sphinxcrossref{\DUrole{std,std-ref}{element type}}}} \(\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}}\) must be \(\hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}}\).

\item {} 
The type \(C.\hyperref[valid/conventions:context]{\mathsf{types}}[x]\) must be defined in the context.

\item {} 
Let \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\) be the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(C.\hyperref[valid/conventions:context]{\mathsf{types}}[x]\).

\item {} 
Then the instruction is valid with type \([t_1^\ast~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{tables}}[0] = \hyperref[syntax/types:syntax-limits]{\mathit{limits}}~\hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}}
  \qquad
  C.\hyperref[valid/conventions:context]{\mathsf{types}}[x] = [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}{
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call\_indirect}}~x : [t_1^\ast~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}
\index{instruction}\index{instruction sequence}\ignorespaces 

\subsection{Instruction Sequences}
\label{\detokenize{valid/instructions:index-6}}\label{\detokenize{valid/instructions:valid-instr-seq}}\label{\detokenize{valid/instructions:instruction-sequences}}
Typing of instruction sequences is defined recursively.


\subsubsection{Empty Instruction Sequence: \protect\(\epsilon\protect\)}
\label{\detokenize{valid/instructions:empty-instruction-sequence}}\begin{itemize}
\item {} 
The empty instruction sequence is valid with type \([t^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t^\ast]\),
for any sequence of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} \(t^\ast\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  C \hyperref[valid/instructions:valid-instr-seq]{\vdash} \epsilon : [t^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t^\ast]
}\end{split}
\end{equation*}

\subsubsection{Non-empty Instruction Sequence: \protect\(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_N\protect\)}
\label{\detokenize{valid/instructions:non-empty-instruction-sequence}}\begin{itemize}
\item {} 
The instruction sequence \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\) must be valid with type \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\),
for some sequences of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} \(t_1^\ast\) and \(t_2^\ast\).

\item {} 
The instruction \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_N\) must be valid with type \([t^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_3^\ast]\),
for some sequences of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} \(t^\ast\) and \(t_3^\ast\).

\item {} 
There must be a sequence of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} \(t_0^\ast\),
such that \(t_2^\ast = t_0^\ast~t^\ast\).

\item {} 
Then the combined instruction sequence is valid with type \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_0^\ast~t_3^\ast]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C \hyperref[valid/instructions:valid-instr-seq]{\vdash} \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_0^\ast~t^\ast]
  \qquad
  C \hyperref[valid/instructions:valid-instr]{\vdash} \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_N : [t^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_3^\ast]
}{
  C \hyperref[valid/instructions:valid-instr-seq]{\vdash} \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_N : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_0^\ast~t_3^\ast]
}\end{split}
\end{equation*}
\index{expression}\index{result type}\index{validation!expression}\index{expression!validation}\index{abstract syntax!expression}\index{expression!constant}\ignorespaces 

\subsection{Expressions}
\label{\detokenize{valid/instructions:expressions}}\label{\detokenize{valid/instructions:valid-expr}}\label{\detokenize{valid/instructions:index-7}}
Expressions \(\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}}\) are classified by {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result types}}}} of the form \([t^\ast]\).


\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\protect\)}
\label{\detokenize{valid/instructions:id31}}\begin{itemize}
\item {} 
The instruction sequence \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\) must be {\hyperref[\detokenize{valid/instructions:valid-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with type \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t^\ast]\),
for some {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t^\ast]\).

\item {} 
Then the expression is valid with {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t^\ast]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C \hyperref[valid/instructions:valid-instr-seq]{\vdash} \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast : [] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t^\ast]
}{
  C \hyperref[valid/instructions:valid-expr]{\vdash} \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} : [t^\ast]
}\end{split}
\end{equation*}
\index{constant|textbf}\ignorespaces 

\subsubsection{Constant Expressions}
\label{\detokenize{valid/instructions:valid-constant}}\label{\detokenize{valid/instructions:constant-expressions}}\label{\detokenize{valid/instructions:index-8}}\begin{itemize}
\item {} 
In a \sphinxstyleemphasis{constant} expression \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\) all instructions in \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\) must be constant.

\item {} 
A constant instruction \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}\) must be:
\begin{itemize}
\item {} 
either of the form \(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c\),

\item {} 
or of the form \(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.get}}~x\), in which case \(C.\hyperref[valid/conventions:context]{\mathsf{globals}}[x]\) must be a {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global type}}}} of the form \(\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~t\).

\end{itemize}

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  (C \hyperref[valid/instructions:valid-constant]{\vdash} \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}} \hyperref[valid/instructions:valid-constant]{\mathrel{\mbox{const}}})^\ast
}{
  C \hyperref[valid/instructions:valid-constant]{\vdash} \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \hyperref[valid/instructions:valid-constant]{\mathrel{\mbox{const}}}
}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\frac{
}{
  C \hyperref[valid/instructions:valid-constant]{\vdash} t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c \hyperref[valid/instructions:valid-constant]{\mathrel{\mbox{const}}}
}
\qquad
\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{globals}}[x] = \hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~t
}{
  C \hyperref[valid/instructions:valid-constant]{\vdash} \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.get}}~x \hyperref[valid/instructions:valid-constant]{\mathrel{\mbox{const}}}
}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
Currently, constant expressions occurring as initializers of {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{globals}}}} are further constrained in that contained \(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.get}}\) instructions are only allowed to refer to \sphinxstyleemphasis{imported} globals.
This is enforced in the {\hyperref[\detokenize{valid/modules:valid-module}]{\sphinxcrossref{\DUrole{std,std-ref}{validation rule for modules}}}} by constraining the context \(C\) accordingly.

The definition of constant expression may be extended in future versions of WebAssembly.
\end{sphinxadmonition}


\section{Modules}
\label{\detokenize{valid/modules::doc}}\label{\detokenize{valid/modules:modules}}
{\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{Modules}}}} are valid when all the components they contain are valid.
Furthermore, most definitions are themselves classified with a suitable type.

\index{function}\index{local}\index{function index}\index{local index}\index{type index}\index{function type}\index{value type}\index{expression}\index{import}\index{abstract syntax!function}\index{function!abstract syntax}\index{abstract syntax!function}\ignorespaces \phantomsection\label{\detokenize{valid/modules:valid-local}}

\subsection{Functions}
\label{\detokenize{valid/modules:valid-func}}\label{\detokenize{valid/modules:functions}}\label{\detokenize{valid/modules:index-0}}\label{\detokenize{valid/modules:valid-local}}
Functions \(\hyperref[syntax/modules:syntax-func]{\mathit{func}}\) are classified by {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function types}}}} of the form \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).


\subsubsection{\protect\(\{ \hyperref[syntax/modules:syntax-func]{\mathsf{type}}~x, \hyperref[syntax/modules:syntax-func]{\mathsf{locals}}~t^\ast, \hyperref[syntax/modules:syntax-func]{\mathsf{body}}~\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}} \}\protect\)}
\label{\detokenize{valid/modules:id1}}\begin{itemize}
\item {} 
The type \(C.\hyperref[valid/conventions:context]{\mathsf{types}}[x]\) must be defined in the context.

\item {} 
Let \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\) be the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(C.\hyperref[valid/conventions:context]{\mathsf{types}}[x]\).

\item {} 
Let \(C'\) be the same {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} as \(C\),
but with:
\begin{itemize}
\item {} 
\(\hyperref[valid/conventions:context]{\mathsf{locals}}\) set to the sequence of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} \(t_1^\ast~t^\ast\), concatenating parameters and locals,

\item {} 
\(\hyperref[valid/conventions:context]{\mathsf{labels}}\) set to the singular sequence containing only {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t_2^\ast]\).

\item {} 
\(\hyperref[valid/conventions:context]{\mathsf{return}}\) set to the {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t_2^\ast]\).

\end{itemize}

\item {} 
Under the context \(C'\),
the expression \(\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}}\) must be valid with type \([t_2^\ast]\).

\item {} 
Then the function definition is valid with type \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{types}}[x] = [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
  \qquad
  C,\hyperref[valid/conventions:context]{\mathsf{locals}}\,t_1^\ast~t^\ast,\hyperref[valid/conventions:context]{\mathsf{labels}}~[t_2^\ast],\hyperref[valid/conventions:context]{\mathsf{return}}~[t_2^\ast] \hyperref[valid/instructions:valid-expr]{\vdash} \hyperref[syntax/instructions:syntax-expr]{\mathit{expr}} : [t_2^\ast]
}{
  C \hyperref[valid/modules:valid-func]{\vdash} \{ \hyperref[syntax/modules:syntax-func]{\mathsf{type}}~x, \hyperref[syntax/modules:syntax-func]{\mathsf{locals}}~t^\ast, \hyperref[syntax/modules:syntax-func]{\mathsf{body}}~\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}} \} : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}
\index{table}\index{table type}\index{validation!table}\index{table!validation}\index{abstract syntax!table}\ignorespaces 

\subsection{Tables}
\label{\detokenize{valid/modules:index-1}}\label{\detokenize{valid/modules:tables}}\label{\detokenize{valid/modules:valid-table}}
Tables \(\hyperref[syntax/modules:syntax-table]{\mathit{table}}\) are classified by {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table types}}}}.


\subsubsection{\protect\(\{ \hyperref[syntax/modules:syntax-table]{\mathsf{type}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}} \}\protect\)}
\label{\detokenize{valid/modules:id2}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table type}}}} \(\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}\) must be {\hyperref[\detokenize{valid/types:valid-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}.

\item {} 
Then the table definition is valid with type \(\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \hyperref[valid/types:valid-tabletype]{\vdash} \hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}} \mathrel{\mbox{ok}}
}{
  C \hyperref[valid/modules:valid-table]{\vdash} \{ \hyperref[syntax/modules:syntax-table]{\mathsf{type}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}} \} : \hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}
}\end{split}
\end{equation*}
\index{memory}\index{memory type}\index{validation!memory}\index{memory!validation}\index{abstract syntax!memory}\ignorespaces 

\subsection{Memories}
\label{\detokenize{valid/modules:valid-mem}}\label{\detokenize{valid/modules:index-2}}\label{\detokenize{valid/modules:memories}}
Memories \(\hyperref[syntax/modules:syntax-mem]{\mathit{mem}}\) are classified by {\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory types}}}}.


\subsubsection{\protect\(\{ \hyperref[syntax/modules:syntax-mem]{\mathsf{type}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}} \}\protect\)}
\label{\detokenize{valid/modules:id3}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory type}}}} \(\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}\) must be {\hyperref[\detokenize{valid/types:valid-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}.

\item {} 
Then the memory definition is valid with type \(\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \hyperref[valid/types:valid-memtype]{\vdash} \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}} \mathrel{\mbox{ok}}
}{
  C \hyperref[valid/modules:valid-mem]{\vdash} \{ \hyperref[syntax/modules:syntax-mem]{\mathsf{type}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}} \} : \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}
}\end{split}
\end{equation*}
\index{global}\index{global type}\index{expression}\index{validation!global}\index{global!validation}\index{abstract syntax!global}\ignorespaces 

\subsection{Globals}
\label{\detokenize{valid/modules:globals}}\label{\detokenize{valid/modules:valid-global}}\label{\detokenize{valid/modules:index-3}}
Globals \(\hyperref[syntax/modules:syntax-global]{\mathit{global}}\) are classified by {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global types}}}} of the form \(\hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t\).


\subsubsection{\protect\(\{ \hyperref[syntax/modules:syntax-global]{\mathsf{type}}~\hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t, \hyperref[syntax/modules:syntax-global]{\mathsf{init}}~\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}} \}\protect\)}
\label{\detokenize{valid/modules:id4}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global type}}}} \(\hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t\) must be {\hyperref[\detokenize{valid/types:valid-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}.

\item {} 
The expression \(\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}}\) must be {\hyperref[\detokenize{valid/instructions:valid-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t]\).

\item {} 
The expression \(\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}}\) must be {\hyperref[\detokenize{valid/instructions:valid-constant}]{\sphinxcrossref{\DUrole{std,std-ref}{constant}}}}.

\item {} 
Then the global definition is valid with type \(\hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \hyperref[valid/types:valid-globaltype]{\vdash} \hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t \mathrel{\mbox{ok}}
  \qquad
  C \hyperref[valid/instructions:valid-expr]{\vdash} \hyperref[syntax/instructions:syntax-expr]{\mathit{expr}} : [t]
  \qquad
  C \hyperref[valid/instructions:valid-constant]{\vdash} \hyperref[syntax/instructions:syntax-expr]{\mathit{expr}} \hyperref[valid/instructions:valid-constant]{\mathrel{\mbox{const}}}
}{
  C \hyperref[valid/modules:valid-global]{\vdash} \{ \hyperref[syntax/modules:syntax-global]{\mathsf{type}}~\hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t, \hyperref[syntax/modules:syntax-global]{\mathsf{init}}~\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}} \} : \hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t
}\end{split}
\end{equation*}
\index{element}\index{table}\index{table index}\index{expression}\index{function index}\index{validation!element}\index{element!validation}\index{abstract syntax!element}\index{table!element}\index{element!segment}\ignorespaces 

\subsection{Element Segments}
\label{\detokenize{valid/modules:element-segments}}\label{\detokenize{valid/modules:index-4}}\label{\detokenize{valid/modules:valid-elem}}
Element segments \(\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}\) are not classified by a type.


\subsubsection{\protect\(\{ \hyperref[syntax/modules:syntax-elem]{\mathsf{table}}~x, \hyperref[syntax/modules:syntax-elem]{\mathsf{offset}}~\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}}, \hyperref[syntax/modules:syntax-elem]{\mathsf{init}}~y^\ast \}\protect\)}
\label{\detokenize{valid/modules:id5}}\begin{itemize}
\item {} 
The table \(C.\hyperref[valid/conventions:context]{\mathsf{tables}}[x]\) must be defined in the context.

\item {} 
Let \(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}~\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}}\) be the {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table type}}}} \(C.\hyperref[valid/conventions:context]{\mathsf{tables}}[x]\).

\item {} 
The {\hyperref[\detokenize{syntax/types:syntax-elemtype}]{\sphinxcrossref{\DUrole{std,std-ref}{element type}}}} \(\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}}\) must be \(\hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}}\).

\item {} 
The expression \(\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}}\) must be {\hyperref[\detokenize{valid/instructions:valid-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]\).

\item {} 
The expression \(\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}}\) must be {\hyperref[\detokenize{valid/instructions:valid-constant}]{\sphinxcrossref{\DUrole{std,std-ref}{constant}}}}.

\item {} 
For each \(y_i\) in \(y^\ast\),
the function \(C.\hyperref[valid/conventions:context]{\mathsf{funcs}}[y]\) must be defined in the context.

\item {} 
Then the element segment is valid.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{tables}}[x] = \hyperref[syntax/types:syntax-limits]{\mathit{limits}}~\hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}}
  \qquad
  C \hyperref[valid/instructions:valid-expr]{\vdash} \hyperref[syntax/instructions:syntax-expr]{\mathit{expr}} : [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]
  \qquad
  C \hyperref[valid/instructions:valid-constant]{\vdash} \hyperref[syntax/instructions:syntax-expr]{\mathit{expr}} \hyperref[valid/instructions:valid-constant]{\mathrel{\mbox{const}}}
  \qquad
  (C.\hyperref[valid/conventions:context]{\mathsf{funcs}}[y] = \hyperref[syntax/types:syntax-functype]{\mathit{functype}})^\ast
}{
  C \hyperref[valid/modules:valid-elem]{\vdash} \{ \hyperref[syntax/modules:syntax-elem]{\mathsf{table}}~x, \hyperref[syntax/modules:syntax-elem]{\mathsf{offset}}~\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}}, \hyperref[syntax/modules:syntax-elem]{\mathsf{init}}~y^\ast \} \mathrel{\mbox{ok}}
}\end{split}
\end{equation*}
\index{data}\index{memory}\index{memory index}\index{expression}\index{byte}\index{validation!data}\index{data!validation}\index{abstract syntax!data}\index{memory!data}\index{data!segment}\ignorespaces 

\subsection{Data Segments}
\label{\detokenize{valid/modules:valid-data}}\label{\detokenize{valid/modules:index-5}}\label{\detokenize{valid/modules:data-segments}}
Data segments \(\hyperref[syntax/modules:syntax-data]{\mathit{data}}\) are not classified by any type.


\subsubsection{\protect\(\{ \hyperref[syntax/modules:syntax-data]{\mathsf{data}}~x, \hyperref[syntax/modules:syntax-data]{\mathsf{offset}}~\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}}, \hyperref[syntax/modules:syntax-data]{\mathsf{init}}~b^\ast \}\protect\)}
\label{\detokenize{valid/modules:id6}}\begin{itemize}
\item {} 
The memory \(C.\hyperref[valid/conventions:context]{\mathsf{mems}}[x]\) must be defined in the context.

\item {} 
The expression \(\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}}\) must be {\hyperref[\detokenize{valid/instructions:valid-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]\).

\item {} 
The expression \(\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}}\) must be {\hyperref[\detokenize{valid/instructions:valid-constant}]{\sphinxcrossref{\DUrole{std,std-ref}{constant}}}}.

\item {} 
Then the data segment is valid.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{mems}}[x] = \hyperref[syntax/types:syntax-limits]{\mathit{limits}}
  \qquad
  C \hyperref[valid/instructions:valid-expr]{\vdash} \hyperref[syntax/instructions:syntax-expr]{\mathit{expr}} : [\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}]
  \qquad
  C \hyperref[valid/instructions:valid-constant]{\vdash} \hyperref[syntax/instructions:syntax-expr]{\mathit{expr}} \hyperref[valid/instructions:valid-constant]{\mathrel{\mbox{const}}}
}{
  C \hyperref[valid/modules:valid-data]{\vdash} \{ \hyperref[syntax/modules:syntax-data]{\mathsf{data}}~x, \hyperref[syntax/modules:syntax-data]{\mathsf{offset}}~\hyperref[syntax/instructions:syntax-expr]{\mathit{expr}}, \hyperref[syntax/modules:syntax-data]{\mathsf{init}}~b^\ast \} \mathrel{\mbox{ok}}
}\end{split}
\end{equation*}
\index{start function}\index{function index}\index{validation!start function}\index{start function!validation}\index{abstract syntax!start function}\ignorespaces 

\subsection{Start Function}
\label{\detokenize{valid/modules:valid-start}}\label{\detokenize{valid/modules:start-function}}\label{\detokenize{valid/modules:index-6}}
Start function declarations \(\hyperref[syntax/modules:syntax-start]{\mathit{start}}\) are not classified by any type.


\subsubsection{\protect\(\{ \hyperref[syntax/modules:syntax-start]{\mathsf{func}}~x \}\protect\)}
\label{\detokenize{valid/modules:id7}}\begin{itemize}
\item {} 
The function \(C.\hyperref[valid/conventions:context]{\mathsf{funcs}}[x]\) must be defined in the context.

\item {} 
The type of \(C.\hyperref[valid/conventions:context]{\mathsf{funcs}}[x]\) must be \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} []\).

\item {} 
Then the start function is valid.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{funcs}}[x] = [] \hyperref[syntax/types:syntax-functype]{\rightarrow} []
}{
  C \hyperref[valid/modules:valid-start]{\vdash} \{ \hyperref[syntax/modules:syntax-start]{\mathsf{func}}~x \} \mathrel{\mbox{ok}}
}\end{split}
\end{equation*}
\index{export}\index{name}\index{index}\index{function index}\index{table index}\index{memory index}\index{global index}\index{validation!export}\index{export!validation}\index{abstract syntax!export}\ignorespaces \phantomsection\label{\detokenize{valid/modules:valid-exportdesc}}

\subsection{Exports}
\label{\detokenize{valid/modules:exports}}\label{\detokenize{valid/modules:index-7}}\label{\detokenize{valid/modules:valid-export}}\label{\detokenize{valid/modules:valid-exportdesc}}
Exports \(\hyperref[syntax/modules:syntax-export]{\mathit{export}}\) and export descriptions \(\hyperref[syntax/modules:syntax-exportdesc]{\mathit{exportdesc}}\) are classified by their {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}}.


\subsubsection{\protect\(\{ \hyperref[syntax/modules:syntax-export]{\mathsf{name}}~\hyperref[syntax/values:syntax-name]{\mathit{name}}, \hyperref[syntax/modules:syntax-export]{\mathsf{desc}}~\hyperref[syntax/modules:syntax-exportdesc]{\mathit{exportdesc}} \}\protect\)}
\label{\detokenize{valid/modules:id8}}\begin{itemize}
\item {} 
The export description \(\hyperref[syntax/modules:syntax-exportdesc]{\mathit{exportdesc}}\) must be valid with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}\).

\item {} 
Then the export is valid with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C \hyperref[valid/modules:valid-exportdesc]{\vdash} \hyperref[syntax/modules:syntax-exportdesc]{\mathit{exportdesc}} : \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}
}{
  C \hyperref[valid/modules:valid-export]{\vdash} \{ \hyperref[syntax/modules:syntax-export]{\mathsf{name}}~\hyperref[syntax/values:syntax-name]{\mathit{name}}, \hyperref[syntax/modules:syntax-export]{\mathsf{desc}}~\hyperref[syntax/modules:syntax-exportdesc]{\mathit{exportdesc}} \} : \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/modules:syntax-exportdesc]{\mathsf{func}}~x\protect\)}
\label{\detokenize{valid/modules:id9}}\begin{itemize}
\item {} 
The function \(C.\hyperref[valid/conventions:context]{\mathsf{funcs}}[x]\) must be defined in the context.

\item {} 
Then the export description is valid with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~C.\hyperref[valid/conventions:context]{\mathsf{funcs}}[x]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{funcs}}[x] = \hyperref[syntax/types:syntax-functype]{\mathit{functype}}
}{
  C \hyperref[valid/modules:valid-exportdesc]{\vdash} \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{func}}~x : \hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/modules:syntax-exportdesc]{\mathsf{table}}~x\protect\)}
\label{\detokenize{valid/modules:id10}}\begin{itemize}
\item {} 
The table \(C.\hyperref[valid/conventions:context]{\mathsf{tables}}[x]\) must be defined in the context.

\item {} 
Then the export description is valid with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~C.\hyperref[valid/conventions:context]{\mathsf{tables}}[x]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{tables}}[x] = \hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}
}{
  C \hyperref[valid/modules:valid-exportdesc]{\vdash} \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{table}}~x : \hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/modules:syntax-exportdesc]{\mathsf{mem}}~x\protect\)}
\label{\detokenize{valid/modules:id11}}\begin{itemize}
\item {} 
The memory \(C.\hyperref[valid/conventions:context]{\mathsf{mems}}[x]\) must be defined in the context.

\item {} 
Then the export description is valid with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~C.\hyperref[valid/conventions:context]{\mathsf{mems}}[x]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{mems}}[x] = \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}
}{
  C \hyperref[valid/modules:valid-exportdesc]{\vdash} \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{mem}}~x : \hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/modules:syntax-exportdesc]{\mathsf{global}}~x\protect\)}
\label{\detokenize{valid/modules:id12}}\begin{itemize}
\item {} 
The global \(C.\hyperref[valid/conventions:context]{\mathsf{globals}}[x]\) must be defined in the context.

\item {} 
Then the export description is valid with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~C.\hyperref[valid/conventions:context]{\mathsf{globals}}[x]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{globals}}[x] = \hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}
}{
  C \hyperref[valid/modules:valid-exportdesc]{\vdash} \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{global}}~x : \hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}
}\end{split}
\end{equation*}
\index{import}\index{name}\index{function type}\index{table type}\index{memory type}\index{global type}\index{validation!import}\index{import!validation}\index{abstract syntax!import}\ignorespaces \phantomsection\label{\detokenize{valid/modules:valid-importdesc}}

\subsection{Imports}
\label{\detokenize{valid/modules:valid-importdesc}}\label{\detokenize{valid/modules:index-8}}\label{\detokenize{valid/modules:valid-import}}\label{\detokenize{valid/modules:imports}}
Imports \(\hyperref[syntax/modules:syntax-import]{\mathit{import}}\) and import descriptions \(\hyperref[syntax/modules:syntax-importdesc]{\mathit{importdesc}}\) are classified by {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external types}}}}.


\subsubsection{\protect\(\{ \hyperref[syntax/modules:syntax-import]{\mathsf{module}}~\hyperref[syntax/values:syntax-name]{\mathit{name}}_1, \hyperref[syntax/modules:syntax-import]{\mathsf{name}}~\hyperref[syntax/values:syntax-name]{\mathit{name}}_2, \hyperref[syntax/modules:syntax-import]{\mathsf{desc}}~\hyperref[syntax/modules:syntax-importdesc]{\mathit{importdesc}} \}\protect\)}
\label{\detokenize{valid/modules:id13}}\begin{itemize}
\item {} 
The import description \(\hyperref[syntax/modules:syntax-importdesc]{\mathit{importdesc}}\) must be valid with type \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}\).

\item {} 
Then the import is valid with type \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C \hyperref[valid/modules:valid-importdesc]{\vdash} \hyperref[syntax/modules:syntax-importdesc]{\mathit{importdesc}} : \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}
}{
  C \hyperref[valid/modules:valid-import]{\vdash} \{ \hyperref[syntax/modules:syntax-import]{\mathsf{module}}~\hyperref[syntax/values:syntax-name]{\mathit{name}}_1, \hyperref[syntax/modules:syntax-import]{\mathsf{name}}~\hyperref[syntax/values:syntax-name]{\mathit{name}}_2, \hyperref[syntax/modules:syntax-import]{\mathsf{desc}}~\hyperref[syntax/modules:syntax-importdesc]{\mathit{importdesc}} \} : \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/modules:syntax-importdesc]{\mathsf{func}}~x\protect\)}
\label{\detokenize{valid/modules:id14}}\begin{itemize}
\item {} 
The function \(C.\hyperref[valid/conventions:context]{\mathsf{types}}[x]\) must be defined in the context.

\item {} 
Let \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\) be the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(C.\hyperref[valid/conventions:context]{\mathsf{types}}[x]\).

\item {} 
Then the import description is valid with type \(\hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~[t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  C.\hyperref[valid/conventions:context]{\mathsf{types}}[x] = [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}{
  C \hyperref[valid/modules:valid-importdesc]{\vdash} \hyperref[syntax/modules:syntax-importdesc]{\mathsf{func}}~x : \hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~[t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/modules:syntax-importdesc]{\mathsf{table}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}\protect\)}
\label{\detokenize{valid/modules:id15}}\begin{itemize}
\item {} 
The table type \(\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}\) must be {\hyperref[\detokenize{valid/types:valid-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}.

\item {} 
Then the import description is valid with type \(\hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \hyperref[valid/modules:valid-table]{\vdash} \hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}} \mathrel{\mbox{ok}}
}{
  C \hyperref[valid/modules:valid-importdesc]{\vdash} \hyperref[syntax/modules:syntax-importdesc]{\mathsf{table}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}} : \hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/modules:syntax-importdesc]{\mathsf{mem}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}\protect\)}
\label{\detokenize{valid/modules:id16}}\begin{itemize}
\item {} 
The memory type \(\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}\) must be {\hyperref[\detokenize{valid/types:valid-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}.

\item {} 
Then the import description is valid with type \(\hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \hyperref[valid/types:valid-memtype]{\vdash} \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}} \mathrel{\mbox{ok}}
}{
  C \hyperref[valid/modules:valid-importdesc]{\vdash} \hyperref[syntax/modules:syntax-importdesc]{\mathsf{mem}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}} : \hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}
}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/modules:syntax-importdesc]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}\protect\)}
\label{\detokenize{valid/modules:id17}}\begin{itemize}
\item {} 
The global type \(\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}\) must be {\hyperref[\detokenize{valid/types:valid-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}.

\item {} 
Then the import description is valid with type \(\hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \hyperref[valid/types:valid-globaltype]{\vdash} \hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}} \mathrel{\mbox{ok}}
}{
  C \hyperref[valid/modules:valid-importdesc]{\vdash} \hyperref[syntax/modules:syntax-importdesc]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}} : \hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}
}\end{split}
\end{equation*}
\index{module}\index{type definition}\index{function type}\index{function}\index{table}\index{memory}\index{global}\index{element}\index{data}\index{start function}\index{import}\index{export}\index{context}\index{validation!module}\index{module!validation}\index{abstract syntax!module}\ignorespaces 

\subsection{Modules}
\label{\detokenize{valid/modules:index-9}}\label{\detokenize{valid/modules:id18}}\label{\detokenize{valid/modules:valid-module}}
Modules are classified by their mapping from the {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external types}}}} of their {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}} to those of their {\hyperref[\detokenize{syntax/modules:syntax-export}]{\sphinxcrossref{\DUrole{std,std-ref}{exports}}}}.

A module is entirely \sphinxstyleemphasis{closed},
that is, its components can only refer to definitions that appear in the module itself.
Consequently, no initial {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} is required.
Instead, the context \(C\) for validation of the module’s content is constructed from the definitions in the module.
\begin{itemize}
\item {} 
Let \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}\) be the module to validate.

\item {} 
Let \(C\) be a {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} where:
\begin{itemize}
\item {} 
\(C.\hyperref[valid/conventions:context]{\mathsf{types}}\) is \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{types}}\),

\item {} 
\(C.\hyperref[valid/conventions:context]{\mathsf{funcs}}\) is \(\hyperref[syntax/types:syntax-externtype]{\mathrm{funcs}}(\mathit{it}^\ast)\) concatenated with \(\mathit{ft}^\ast\),
with the import’s {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external types}}}} \(\mathit{it}^\ast\) and the internal {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function types}}}} \(\mathit{ft}^\ast\) as determined below,

\item {} 
\(C.\hyperref[valid/conventions:context]{\mathsf{tables}}\) is \(\hyperref[syntax/types:syntax-externtype]{\mathrm{tables}}(\mathit{it}^\ast)\) concatenated with \(\mathit{tt}^\ast\),
with the import’s {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external types}}}} \(\mathit{it}^\ast\) and the internal {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table types}}}} \(\mathit{tt}^\ast\) as determined below,

\item {} 
\(C.\hyperref[valid/conventions:context]{\mathsf{mems}}\) is \(\hyperref[syntax/types:syntax-externtype]{\mathrm{mems}}(\mathit{it}^\ast)\) concatenated with \(\mathit{mt}^\ast\),
with the import’s {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external types}}}} \(\mathit{it}^\ast\) and the internal {\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory types}}}} \(\mathit{mt}^\ast\) as determined below,

\item {} 
\(C.\hyperref[valid/conventions:context]{\mathsf{globals}}\) is \(\hyperref[syntax/types:syntax-externtype]{\mathrm{globals}}(\mathit{it}^\ast)\) concatenated with \(\mathit{gt}^\ast\),
with the import’s {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external types}}}} \(\mathit{it}^\ast\) and the internal {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global types}}}} \(\mathit{gt}^\ast\) as determined below,

\item {} 
\(C.\hyperref[valid/conventions:context]{\mathsf{locals}}\) is empty,

\item {} 
\(C.\hyperref[valid/conventions:context]{\mathsf{labels}}\) is empty,

\item {} 
\(C.\hyperref[valid/conventions:context]{\mathsf{return}}\) is empty.

\end{itemize}

\item {} 
Let \(C'\) be the {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} where \(C'.\hyperref[valid/conventions:context]{\mathsf{globals}}\) is the sequence \(\hyperref[syntax/types:syntax-externtype]{\mathrm{globals}}(\mathit{it}^\ast)\) and all other fields are empty.

\item {} 
Under the context \(C\):
\begin{itemize}
\item {} 
For each \(\hyperref[syntax/modules:syntax-func]{\mathit{func}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{funcs}}\),
the definition \(\hyperref[syntax/modules:syntax-func]{\mathit{func}}_i\) must be {\hyperref[\detokenize{valid/modules:valid-func}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with a {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(\mathit{ft}_i\).

\item {} 
For each \(\hyperref[syntax/modules:syntax-table]{\mathit{table}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{tables}}\),
the definition \(\hyperref[syntax/modules:syntax-table]{\mathit{table}}_i\) must be {\hyperref[\detokenize{valid/modules:valid-table}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with a {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table type}}}} \(\mathit{tt}_i\).

\item {} 
For each \(\hyperref[syntax/modules:syntax-mem]{\mathit{mem}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{mems}}\),
the definition \(\hyperref[syntax/modules:syntax-mem]{\mathit{mem}}_i\) must be {\hyperref[\detokenize{valid/modules:valid-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with a {\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory type}}}} \(\mathit{mt}_i\).

\item {} 
For each \(\hyperref[syntax/modules:syntax-global]{\mathit{global}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{globals}}\):
\begin{itemize}
\item {} 
Under the context \(C'\),
the definition \(\hyperref[syntax/modules:syntax-global]{\mathit{global}}_i\) must be {\hyperref[\detokenize{valid/modules:valid-global}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with a {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global type}}}} \(\mathit{gt}_i\).

\end{itemize}

\item {} 
For each \(\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{elem}}\),
the segment \(\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}_i\) must be {\hyperref[\detokenize{valid/modules:valid-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}.

\item {} 
For each \(\hyperref[syntax/modules:syntax-data]{\mathit{data}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{data}}\),
the segment \(\hyperref[syntax/modules:syntax-data]{\mathit{data}}_i\) must be {\hyperref[\detokenize{valid/modules:valid-data}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}.

\item {} 
If \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{start}}\) is non-empty,
then \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{start}}\) must be {\hyperref[\detokenize{valid/modules:valid-start}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}.

\item {} 
For each \(\hyperref[syntax/modules:syntax-import]{\mathit{import}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{imports}}\),
the segment \(\hyperref[syntax/modules:syntax-import]{\mathit{import}}_i\) must be {\hyperref[\detokenize{valid/modules:valid-import}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with an {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\mathit{it}_i\).

\item {} 
For each \(\hyperref[syntax/modules:syntax-export]{\mathit{export}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{exports}}\),
the segment \(\hyperref[syntax/modules:syntax-export]{\mathit{export}}_i\) must be {\hyperref[\detokenize{valid/modules:valid-export}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\mathit{et}_i\).

\end{itemize}

\item {} 
The length of \(C.\hyperref[valid/conventions:context]{\mathsf{tables}}\) must not be larger than \(1\).

\item {} 
The length of \(C.\hyperref[valid/conventions:context]{\mathsf{mems}}\) must not be larger than \(1\).

\item {} 
All export names \(\hyperref[syntax/modules:syntax-export]{\mathit{export}}_i.\hyperref[syntax/modules:syntax-export]{\mathsf{name}}\) must be different.

\item {} 
Let \(\mathit{ft}^\ast\) be the concatenation of the internal {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function types}}}} \(\mathit{ft}_i\), in index order.

\item {} 
Let \(\mathit{tt}^\ast\) be the concatenation of the internal {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table types}}}} \(\mathit{tt}_i\), in index order.

\item {} 
Let \(\mathit{mt}^\ast\) be the concatenation of the internal {\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory types}}}} \(\mathit{mt}_i\), in index order.

\item {} 
Let \(\mathit{gt}^\ast\) be the concatenation of the internal {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global types}}}} \(\mathit{gt}_i\), in index order.

\item {} 
Let \(\mathit{it}^\ast\) be the concatenation of {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external types}}}} \(\mathit{it}_i\) of the imports, in index order.

\item {} 
Let \(\mathit{et}^\ast\) be the concatenation of {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external types}}}} \(\mathit{et}_i\) of the exports, in index order.

\item {} 
Then the module is valid with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external types}}}} \(\mathit{it}^\ast \hyperref[syntax/types:syntax-functype]{\rightarrow} \mathit{et}^\ast\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \begin{array}{@{}c@{}}
  (C \hyperref[valid/modules:valid-func]{\vdash} \hyperref[syntax/modules:syntax-func]{\mathit{func}} : \mathit{ft})^\ast
  \quad
  (C \hyperref[valid/modules:valid-table]{\vdash} \hyperref[syntax/modules:syntax-table]{\mathit{table}} : \mathit{tt})^\ast
  \quad
  (C \hyperref[valid/modules:valid-mem]{\vdash} \hyperref[syntax/modules:syntax-mem]{\mathit{mem}} : \mathit{mt})^\ast
  \quad
  (C' \hyperref[valid/modules:valid-global]{\vdash} \hyperref[syntax/modules:syntax-global]{\mathit{global}} : \mathit{gt})^\ast
  \\
  (C \hyperref[valid/modules:valid-elem]{\vdash} \hyperref[syntax/modules:syntax-elem]{\mathit{elem}} \mathrel{\mbox{ok}})^\ast
  \quad
  (C \hyperref[valid/modules:valid-data]{\vdash} \hyperref[syntax/modules:syntax-data]{\mathit{data}} \mathrel{\mbox{ok}})^\ast
  \quad
  (C \hyperref[valid/modules:valid-start]{\vdash} \hyperref[syntax/modules:syntax-start]{\mathit{start}} \mathrel{\mbox{ok}})^?
  \quad
  (C \hyperref[valid/modules:valid-import]{\vdash} \hyperref[syntax/modules:syntax-import]{\mathit{import}} : \mathit{it})^\ast
  \quad
  (C \hyperref[valid/modules:valid-export]{\vdash} \hyperref[syntax/modules:syntax-export]{\mathit{export}} : \mathit{et})^\ast
  \\
  \mathit{ift}^\ast = \hyperref[syntax/types:syntax-externtype]{\mathrm{funcs}}(\mathit{it}^\ast)
  \qquad
  \mathit{itt}^\ast = \hyperref[syntax/types:syntax-externtype]{\mathrm{tables}}(\mathit{it}^\ast)
  \qquad
  \mathit{imt}^\ast = \hyperref[syntax/types:syntax-externtype]{\mathrm{mems}}(\mathit{it}^\ast)
  \qquad
  \mathit{igt}^\ast = \hyperref[syntax/types:syntax-externtype]{\mathrm{globals}}(\mathit{it}^\ast)
  \\
  C = \{ \hyperref[valid/conventions:context]{\mathsf{types}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}^\ast, \hyperref[valid/conventions:context]{\mathsf{funcs}}~\mathit{ift}^\ast~\mathit{ft}^\ast, \hyperref[valid/conventions:context]{\mathsf{tables}}~\mathit{itt}^\ast~\mathit{tt}^\ast, \hyperref[valid/conventions:context]{\mathsf{mems}}~\mathit{imt}^\ast~\mathit{mt}^\ast, \hyperref[valid/conventions:context]{\mathsf{globals}}~\mathit{igt}^\ast~\mathit{gt}^\ast \}
  \\
  C' = \{ \hyperref[valid/conventions:context]{\mathsf{globals}}~\mathit{igt}^\ast \}
  \qquad
  |C.\hyperref[valid/conventions:context]{\mathsf{tables}}| \leq 1
  \qquad
  |C.\hyperref[valid/conventions:context]{\mathsf{mems}}| \leq 1
  \qquad
  (\hyperref[syntax/modules:syntax-export]{\mathit{export}}.\hyperref[syntax/modules:syntax-export]{\mathsf{name}})^\ast ~\mathrm{disjoint}
  \end{array}
}{
  \hyperref[valid/modules:valid-module]{\vdash} \{
    \begin{array}[t]{@{}l@{}}
      \hyperref[syntax/modules:syntax-module]{\mathsf{types}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}^\ast,
      \hyperref[syntax/modules:syntax-module]{\mathsf{funcs}}~\hyperref[syntax/modules:syntax-func]{\mathit{func}}^\ast,
      \hyperref[syntax/modules:syntax-module]{\mathsf{tables}}~\hyperref[syntax/modules:syntax-table]{\mathit{table}}^\ast,
      \hyperref[syntax/modules:syntax-module]{\mathsf{mems}}~\hyperref[syntax/modules:syntax-mem]{\mathit{mem}}^\ast,
      \hyperref[syntax/modules:syntax-module]{\mathsf{globals}}~\hyperref[syntax/modules:syntax-global]{\mathit{global}}^\ast, \\
      \hyperref[syntax/modules:syntax-module]{\mathsf{elem}}~\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}^\ast,
      \hyperref[syntax/modules:syntax-module]{\mathsf{data}}~\hyperref[syntax/modules:syntax-data]{\mathit{data}}^\ast,
      \hyperref[syntax/modules:syntax-module]{\mathsf{start}}~\hyperref[syntax/modules:syntax-start]{\mathit{start}}^?,
      \hyperref[syntax/modules:syntax-module]{\mathsf{imports}}~\hyperref[syntax/modules:syntax-import]{\mathit{import}}^\ast,
      \hyperref[syntax/modules:syntax-module]{\mathsf{exports}}~\hyperref[syntax/modules:syntax-export]{\mathit{export}}^\ast \} : \mathit{it}^\ast \hyperref[syntax/types:syntax-functype]{\rightarrow} \mathit{et}^\ast \\
    \end{array}
}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
Most definitions in a module \textendash{} particularly functions \textendash{} are mutually recursive.
Consequently, the definition of the {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} \(C\) in this rule is recursive:
it depends on the outcome of validation of the function, table, memory, and global definitions contained in the module,
which itself depends on \(C\).
However, this recursion is just a specification device.
All types needed to construct \(C\) can easily be determined from a simple pre-pass over the module that does not perform any actual validation.

Globals, however, are not recursive.
The effect of defining the limited context \(C'\) for validating the module’s globals is that their initialization expressions can only access imported globals and nothing else.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
The restriction on the number of tables and memories may be lifted in future versions of WebAssembly.
\end{sphinxadmonition}


\chapter{Execution}
\label{\detokenize{exec/index:execution}}\label{\detokenize{exec/index:exec}}\label{\detokenize{exec/index::doc}}
\index{execution|textbf}\index{stack}\index{store}\ignorespaces 

\section{Conventions}
\label{\detokenize{exec/conventions:conventions}}\label{\detokenize{exec/conventions::doc}}\label{\detokenize{exec/conventions:index-0}}
WebAssembly code is \sphinxstyleemphasis{executed} when {\hyperref[\detokenize{exec/modules:exec-instantiation}]{\sphinxcrossref{\DUrole{std,std-ref}{instantiating}}}} a module or {\hyperref[\detokenize{exec/modules:exec-invocation}]{\sphinxcrossref{\DUrole{std,std-ref}{invoking}}}} an {\hyperref[\detokenize{syntax/modules:syntax-export}]{\sphinxcrossref{\DUrole{std,std-ref}{exported}}}} function on the resulting module {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{instance}}}}.

Execution behavior is defined in terms of an \sphinxstyleemphasis{abstract machine} that models the \sphinxstyleemphasis{program state}.
It includes a \sphinxstyleemphasis{stack}, which records operand values and control constructs, and an abstract \sphinxstyleemphasis{store} containing global state.

For each instruction, there is a rule that specifies the effect of its execution on the program state.
Furthermore, there are rules describing the instantiation of a module.
As with {\hyperref[\detokenize{intro/overview:validation}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, all rules are given in two \sphinxstyleemphasis{equivalent} forms:
\begin{enumerate}
\item {} 
In \sphinxstyleemphasis{prose}, describing the execution in intuitive form.

\item {} 
In \sphinxstyleemphasis{formal notation}, describing the rule in mathematical form. %
\begin{footnote}[17]\sphinxAtStartFootnote
The semantics is derived from the following article:
Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke Wagner, Alon Zakai, JF Bastien, Michael Holman. \sphinxhref{https://dl.acm.org/citation.cfm?doid=3062341.3062363}{Bringing the Web up to Speed with WebAssembly}. Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.
%
\end{footnote}

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
As with validation, the prose and formal rules are equivalent,
so that understanding of the formal notation is \sphinxstyleemphasis{not} required to read this specification.
The formalism offers a more concise description in notation that is used widely in programming languages semantics and is readily amenable to mathematical proof.
\end{sphinxadmonition}


\subsection{Prose Notation}
\label{\detokenize{exec/conventions:exec-notation-textual}}\label{\detokenize{exec/conventions:prose-notation}}
Execution is specified by stylised, step-wise rules for each {\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instruction}}}} of the {\hyperref[\detokenize{syntax/index:syntax}]{\sphinxcrossref{\DUrole{std,std-ref}{abstract syntax}}}}.
The following conventions are adopted in stating these rules.
\begin{itemize}
\item {} 
The execution rules implicitly assume a given {\hyperref[\detokenize{exec/runtime:store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} \(S\).

\item {} 
The execution rules also assume the presence of an implicit {\hyperref[\detokenize{exec/runtime:stack}]{\sphinxcrossref{\DUrole{std,std-ref}{stack}}}}
that is modified by \sphinxstyleemphasis{pushing} or \sphinxstyleemphasis{popping}
{\hyperref[\detokenize{syntax/values:syntax-value}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}}, {\hyperref[\detokenize{exec/runtime:syntax-label}]{\sphinxcrossref{\DUrole{std,std-ref}{labels}}}}, and {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frames}}}}.

\item {} 
Certain rules require the stack to contain at least one frame.
The most recent frame is referred to as the \sphinxstyleemphasis{current} frame.

\item {} 
Both the store and the current frame are mutated by \sphinxstyleemphasis{replacing} some of their components.
Such replacement is assumed to apply globally.

\item {} 
The execution of an instruction may \sphinxstyleemphasis{trap},
in which case the entire computation is aborted and no further modifications to the store are performed by it. (Other computations can still be initiated afterwards.)

\item {} 
The execution of an instruction may also end in a \sphinxstyleemphasis{jump} to a designated target,
which defines the next instruction to execute.

\item {} 
Execution can \sphinxstyleemphasis{enter} and \sphinxstyleemphasis{exit} {\hyperref[\detokenize{syntax/instructions:syntax-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{instruction sequences}}}} that form {\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{blocks}}}}.

\item {} 
{\hyperref[\detokenize{syntax/instructions:syntax-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{Instruction sequences}}}} are implicitly executed in order, unless a trap or jump occurs.

\item {} 
In various places the rules contain \sphinxstyleemphasis{assertions} expressing crucial invariants about the program state.

\end{itemize}

\index{reduction rules|textbf}\index{configuration}\index{evaluation context}\ignorespaces 

\subsection{Formal Notation}
\label{\detokenize{exec/conventions:exec-notation}}\label{\detokenize{exec/conventions:formal-notation}}\label{\detokenize{exec/conventions:index-1}}
\begin{sphinxadmonition}{note}{Note:}
This section gives a brief explanation of the notation for specifying execution formally.
For the interested reader, a more thorough introduction can be found in respective text books. %
\begin{footnote}[19]\sphinxAtStartFootnote
For example: Benjamin Pierce. \sphinxhref{https://www.cis.upenn.edu/~bcpierce/tapl/}{Types and Programming Languages}. The MIT Press 2002
%
\end{footnote}
\end{sphinxadmonition}

The formal execution rules use a standard approach for specifying operational semantics, rendering them into \sphinxstyleemphasis{reduction rules}.
Every rule has the following general form:
\begin{equation*}
\begin{split}\mathit{configuration} \quad\hyperref[exec/conventions:formal-notation]{\hookrightarrow}\quad \mathit{configuration}\end{split}
\end{equation*}
A \sphinxstyleemphasis{configuration} is a syntactic description of a program state.
Each rule specifies one \sphinxstyleemphasis{step} of execution.
As long as there is at most one reduction rule applicable to a given configuration, reduction \textendash{} and thereby execution \textendash{} is \sphinxstyleemphasis{deterministic}.
WebAssembly has only very few exceptions to this, which are noted explicitly in this specification.

For WebAssembly, a configuration typically is a tuple \((S; F; \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast)\) consisting of the current {\hyperref[\detokenize{exec/runtime:store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} \(S\), the {\hyperref[\detokenize{exec/runtime:frame}]{\sphinxcrossref{\DUrole{std,std-ref}{call frame}}}} \(F\) of the current function, and the sequence of {\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instructions}}}} that is to be executed.
(A more precise definition is given {\hyperref[\detokenize{exec/runtime:syntax-config}]{\sphinxcrossref{\DUrole{std,std-ref}{later}}}}.)

To avoid unnecessary clutter, the store \(S\) and the frame \(F\) are omitted from reduction rules that do not touch them.

There is no separate representation of the {\hyperref[\detokenize{exec/runtime:stack}]{\sphinxcrossref{\DUrole{std,std-ref}{stack}}}}.
Instead, it is conveniently represented as part of the configuration’s instruction sequence.
In particular, {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} are defined to coincide with \(\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}\) instructions,
and a sequence of \(\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}\) instructions can be interpreted as an operand “stack” that grows to the right.

\begin{sphinxadmonition}{note}{Note:}
For example, the {\hyperref[\detokenize{exec/instructions:exec-binop}]{\sphinxcrossref{\DUrole{std,std-ref}{reduction rule}}}} for the \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}}\) instruction can be given as follows:
\begin{equation*}
\begin{split}(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~n_1)~(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~n_2)~\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}} \quad\hyperref[exec/conventions:formal-notation]{\hookrightarrow}\quad (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~(n_1 + n_2) \mathbin{\mathrm{mod}} 2^{32})\end{split}
\end{equation*}
Per this rule, two \(\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}\) instructions and the \(\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}}\) instruction itself are removed from the instruction stream and replaced with one new \(\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}\) instruction.
This can be interpreted as popping two value off the stack and pushing the result.

When no result is produced, an instruction reduces to the empty sequence:
\begin{equation*}
\begin{split}\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{nop}} \quad\hyperref[exec/conventions:formal-notation]{\hookrightarrow}\quad \epsilon\end{split}
\end{equation*}\end{sphinxadmonition}

{\hyperref[\detokenize{exec/runtime:label}]{\sphinxcrossref{\DUrole{std,std-ref}{Labels}}}} and {\hyperref[\detokenize{exec/runtime:frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frames}}}} are similarly {\hyperref[\detokenize{exec/runtime:syntax-instr-admin}]{\sphinxcrossref{\DUrole{std,std-ref}{defined}}}} to be part of an instruction sequence.

The order of reduction is determined by the definition of an appropriate {\hyperref[\detokenize{exec/runtime:syntax-ctxt-eval}]{\sphinxcrossref{\DUrole{std,std-ref}{evaluation context}}}}.

Reduction \sphinxstyleemphasis{terminates} when no more reduction rules are applicable.
{\hyperref[\detokenize{appendix/properties:soundness}]{\sphinxcrossref{\DUrole{std,std-ref}{Soundness}}}} of the WebAssembly {\hyperref[\detokenize{valid/conventions:type-system}]{\sphinxcrossref{\DUrole{std,std-ref}{type system}}}} guarantees that this is only the case when the original instruction sequence has either been reduced to a sequence of \(\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}\) instructions, which can be interpreted as the {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} of the resulting operand stack,
or if a {\hyperref[\detokenize{exec/runtime:syntax-trap}]{\sphinxcrossref{\DUrole{std,std-ref}{trap}}}} occurred.

\begin{sphinxadmonition}{note}{Note:}
For example, the following instruction sequence,
\begin{equation*}
\begin{split}(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_1)~(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_2)~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{neg}}~(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_3)~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}}~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{mul}}\end{split}
\end{equation*}
terminates after three steps:
\begin{equation*}
\begin{split}\begin{array}{ll}
& (\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_1)~(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_2)~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{neg}}~(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_3)~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}}~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{mul}} \\
\hyperref[exec/conventions:formal-notation]{\hookrightarrow} & (\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_1)~(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_4)~(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_3)~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}}~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{mul}} \\
\hyperref[exec/conventions:formal-notation]{\hookrightarrow} & (\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_1)~(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_5)~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{mul}} \\
\hyperref[exec/conventions:formal-notation]{\hookrightarrow} & (\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_6) \\
\end{array}\end{split}
\end{equation*}
where \(x_4 = -x_2\) and \(x_5 = -x_2 + x_3\) and \(x_6 = x_1 \cdot (-x_2 + x_3)\).
\end{sphinxadmonition}

\index{runtime|textbf}\ignorespaces 

\section{Runtime Structure}
\label{\detokenize{exec/runtime::doc}}\label{\detokenize{exec/runtime:syntax-runtime}}\label{\detokenize{exec/runtime:index-0}}\label{\detokenize{exec/runtime:runtime-structure}}
{\hyperref[\detokenize{exec/runtime:store}]{\sphinxcrossref{\DUrole{std,std-ref}{Store}}}}, {\hyperref[\detokenize{exec/runtime:stack}]{\sphinxcrossref{\DUrole{std,std-ref}{stack}}}}, and other \sphinxstyleemphasis{runtime structure} forming the WebAssembly abstract machine, such as {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} or {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instances}}}}, are made precise in terms of additional auxiliary syntax.

\index{value|textbf}\index{constant}\index{value type}\index{integer}\index{floating-point}\index{abstract syntax!value}\index{value!abstract syntax}\ignorespaces 

\subsection{Values}
\label{\detokenize{exec/runtime:values}}\label{\detokenize{exec/runtime:syntax-val}}\label{\detokenize{exec/runtime:index-1}}
WebAssembly computations manipulate \sphinxstyleemphasis{values} of the four basic {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}}: {\hyperref[\detokenize{syntax/values:syntax-int}]{\sphinxcrossref{\DUrole{std,std-ref}{integers}}}} and {\hyperref[\detokenize{syntax/values:syntax-float}]{\sphinxcrossref{\DUrole{std,std-ref}{floating-point data}}}} of 32 or 64 bit width each, respectively.

In most places of the semantics, values of different types can occur.
In order to avoid ambiguities, values are therefore represented with an abstract syntax that makes their type explicit.
It is convenient to reuse the same notation as for the \(\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}\) {\hyperref[\detokenize{syntax/instructions:syntax-const}]{\sphinxcrossref{\DUrole{std,std-ref}{instructions}}}} producing them:
\begin{equation*}
\begin{split}\begin{array}{llcl}
\def\mathdef1658#1{{}}\mathdef1658{(value)} & \hyperref[exec/runtime:syntax-val]{\mathit{val}} &::=&
  \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\hyperref[syntax/values:syntax-int]{\def\mathdef1675#1{{\mathit{i}#1}}\mathdef1675{\mathit{32}}} \\&&|&
  \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\hyperref[syntax/values:syntax-int]{\def\mathdef1676#1{{\mathit{i}#1}}\mathdef1676{\mathit{64}}} \\&&|&
  \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\hyperref[syntax/values:syntax-float]{\def\mathdef1679#1{{\mathit{f}#1}}\mathdef1679{\mathit{32}}} \\&&|&
  \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\hyperref[syntax/values:syntax-float]{\def\mathdef1680#1{{\mathit{f}#1}}\mathdef1680{\mathit{64}}}
\end{array}\end{split}
\end{equation*}
\index{result|textbf}\index{value}\index{trap}\index{abstract syntax!result}\index{result!abstract syntax}\ignorespaces 

\subsection{Results}
\label{\detokenize{exec/runtime:results}}\label{\detokenize{exec/runtime:index-2}}\label{\detokenize{exec/runtime:syntax-result}}
A \sphinxstyleemphasis{result} is the outcome of a computation.
It is either a sequence of {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} or a {\hyperref[\detokenize{exec/runtime:syntax-trap}]{\sphinxcrossref{\DUrole{std,std-ref}{trap}}}}.
\begin{equation*}
\begin{split}\begin{array}{llcl}
\def\mathdef1658#1{{}}\mathdef1658{(result)} & \hyperref[exec/runtime:syntax-result]{\mathit{result}} &::=&
  \hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast \\&&|&
  \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
In the current version of WebAssembly, a result can consist of at most one value.
\end{sphinxadmonition}

\index{store|textbf}\index{function instance}\index{table instance}\index{memory instance}\index{global instance}\index{module}\index{allocation}\index{abstract syntax!store}\index{store!abstract syntax}\ignorespaces \phantomsection\label{\detokenize{exec/runtime:syntax-store}}

\subsection{Store}
\label{\detokenize{exec/runtime:id1}}\label{\detokenize{exec/runtime:store}}\label{\detokenize{exec/runtime:syntax-store}}\label{\detokenize{exec/runtime:index-3}}
The \sphinxstyleemphasis{store} represents all global state that can be manipulated by WebAssembly programs.
It consists of the runtime representation of all \sphinxstyleemphasis{instances} of {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{functions}}}}, {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{tables}}}}, {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memories}}}}, and {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{globals}}}} that have been {\hyperref[\detokenize{exec/modules:alloc}]{\sphinxcrossref{\DUrole{std,std-ref}{allocated}}}} during the life time of the abstract machine. %
\begin{footnote}[21]\sphinxAtStartFootnote
In practice, implementations may apply techniques like garbage collection to remove objects from the store that are no longer referenced.
However, such techniques are not semantically observable,
and hence outside the scope of this specification.
%
\end{footnote}

Syntactically, the store is defined as a {\hyperref[\detokenize{syntax/conventions:notation-record}]{\sphinxcrossref{\DUrole{std,std-ref}{record}}}} listing the existing instances of each category:
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef1658#1{{}}\mathdef1658{(store)} & \hyperref[exec/runtime:syntax-store]{\mathit{store}} &::=& \{~
  \begin{array}[t]{l@{~}ll}
  \hyperref[exec/runtime:syntax-store]{\mathsf{funcs}} & \hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}^\ast, \\
  \hyperref[exec/runtime:syntax-store]{\mathsf{tables}} & \hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}^\ast, \\
  \hyperref[exec/runtime:syntax-store]{\mathsf{mems}} & \hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}^\ast, \\
  \hyperref[exec/runtime:syntax-store]{\mathsf{globals}} & \hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}^\ast ~\} \\
  \end{array}
\end{array}\end{split}
\end{equation*}

\subsubsection{Convention}
\label{\detokenize{exec/runtime:convention}}\begin{itemize}
\item {} 
The meta variable \(S\) ranges over stores where clear from context.

\end{itemize}

\index{address|textbf}\index{store}\index{function instance}\index{table instance}\index{memory instance}\index{global instance}\index{embedder}\index{abstract syntax!function address}\index{function address!abstract syntax}\index{abstract syntax!table address}\index{table address!abstract syntax}\index{abstract syntax!memory address}\index{memory address!abstract syntax}\index{abstract syntax!global address}\index{global address!abstract syntax}\index{function!address}\index{address!function}\index{table!address}\index{address!table}\index{memory!address}\index{address!memory}\index{global!address}\index{address!global}\ignorespaces \phantomsection\label{\detokenize{exec/runtime:syntax-funcaddr}}\phantomsection\label{\detokenize{exec/runtime:syntax-tableaddr}}\phantomsection\label{\detokenize{exec/runtime:syntax-memaddr}}\phantomsection\label{\detokenize{exec/runtime:syntax-globaladdr}}

\subsection{Addresses}
\label{\detokenize{exec/runtime:syntax-addr}}\label{\detokenize{exec/runtime:syntax-globaladdr}}\label{\detokenize{exec/runtime:syntax-tableaddr}}\label{\detokenize{exec/runtime:index-4}}\label{\detokenize{exec/runtime:syntax-funcaddr}}\label{\detokenize{exec/runtime:addresses}}\label{\detokenize{exec/runtime:syntax-memaddr}}
{\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{Function instances}}}}, {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instances}}}}, {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instances}}}}, and {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{global instances}}}} in the {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} are referenced with abstract \sphinxstyleemphasis{addresses}.
These are simply indices into the respective store component.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef1658#1{{}}\mathdef1658{(address)} & \hyperref[exec/runtime:syntax-addr]{\mathit{addr}} &::=&
  0 ~|~ 1 ~|~ 2 ~|~ \dots \\
\def\mathdef1658#1{{}}\mathdef1658{(function address)} & \hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}} &::=&
  \hyperref[exec/runtime:syntax-addr]{\mathit{addr}} \\
\def\mathdef1658#1{{}}\mathdef1658{(table address)} & \hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}} &::=&
  \hyperref[exec/runtime:syntax-addr]{\mathit{addr}} \\
\def\mathdef1658#1{{}}\mathdef1658{(memory address)} & \hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}} &::=&
  \hyperref[exec/runtime:syntax-addr]{\mathit{addr}} \\
\def\mathdef1658#1{{}}\mathdef1658{(global address)} & \hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}} &::=&
  \hyperref[exec/runtime:syntax-addr]{\mathit{addr}} \\
\end{array}\end{split}
\end{equation*}
An {\hyperref[\detokenize{intro/overview:embedder}]{\sphinxcrossref{\DUrole{std,std-ref}{embedder}}}} may assign identity to {\hyperref[\detokenize{syntax/modules:syntax-export}]{\sphinxcrossref{\DUrole{std,std-ref}{exported}}}} store objects corresponding to their addresses,
even where this identity is not observable from within WebAssembly code itself
(such as for {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{function instances}}}} or immutable {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{globals}}}}).

\begin{sphinxadmonition}{note}{Note:}
Addresses are \sphinxstyleemphasis{dynamic}, globally unique references to runtime objects,
in contrast to {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{indices}}}},
which are \sphinxstyleemphasis{static}, module-local references to their original definitions.
A \sphinxstyleemphasis{memory address} \(\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}\) denotes the abstract address \sphinxstyleemphasis{of} a memory \sphinxstyleemphasis{instance} in the store,
not an offset \sphinxstyleemphasis{inside} a memory instance.

There is no specific limit on the number of allocations of store objects,
hence logical addresses can be arbitrarily large natural numbers.
\end{sphinxadmonition}

\index{instance|textbf}\index{function type}\index{function instance}\index{table instance}\index{memory instance}\index{global instance}\index{export instance}\index{table address}\index{memory address}\index{global address}\index{index}\index{name}\index{abstract syntax!module instance}\index{module instance!abstract syntax}\index{module!instance}\index{instance!module}\ignorespaces 

\subsection{Module Instances}
\label{\detokenize{exec/runtime:index-5}}\label{\detokenize{exec/runtime:syntax-moduleinst}}\label{\detokenize{exec/runtime:module-instances}}
A \sphinxstyleemphasis{module instance} is the runtime representation of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}.
It is created by {\hyperref[\detokenize{exec/modules:exec-instantiation}]{\sphinxcrossref{\DUrole{std,std-ref}{instantiating}}}} a module,
and collects runtime representations of all entities that are imported, defined, or exported by the module.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef1658#1{{}}\mathdef1658{(module instance)} & \hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}} &::=& \{
  \begin{array}[t]{l@{~}ll}
  \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{types}} & \hyperref[syntax/types:syntax-functype]{\mathit{functype}}^\ast, \\
  \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}} & \hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}^\ast, \\
  \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{tableaddrs}} & \hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}^\ast, \\
  \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}} & \hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}^\ast, \\
  \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{globaladdrs}} & \hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}^\ast, \\
  \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{exports}} & \hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}^\ast ~\} \\
  \end{array}
\end{array}\end{split}
\end{equation*}
Each component references runtime instances corresponding to respective declarations from the original module \textendash{} whether imported or defined \textendash{} in the order of their static {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{indices}}}}.
{\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{Function instances}}}}, {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instances}}}}, {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instances}}}}, and {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{global instances}}}} are referenced with an indirection through their respective {\hyperref[\detokenize{exec/runtime:syntax-addr}]{\sphinxcrossref{\DUrole{std,std-ref}{addresses}}}} in the {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}}.

It is an invariant of the semantics that all {\hyperref[\detokenize{exec/runtime:syntax-exportinst}]{\sphinxcrossref{\DUrole{std,std-ref}{export instances}}}} in a given module instance have different {\hyperref[\detokenize{syntax/values:syntax-name}]{\sphinxcrossref{\DUrole{std,std-ref}{names}}}}.

\index{function instance|textbf}\index{module instance}\index{function}\index{closure}\index{module}\index{host function|textbf}\index{invocation}\index{abstract syntax!function instance}\index{function instance!abstract syntax}\index{function!instance}\index{instance!function}\ignorespaces \phantomsection\label{\detokenize{exec/runtime:syntax-hostfunc}}

\subsection{Function Instances}
\label{\detokenize{exec/runtime:index-6}}\label{\detokenize{exec/runtime:syntax-funcinst}}\label{\detokenize{exec/runtime:function-instances}}\label{\detokenize{exec/runtime:syntax-hostfunc}}
A \sphinxstyleemphasis{function instance} is the runtime representation of a {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}}.
It effectively is a \sphinxstyleemphasis{closure} of the original function over the runtime {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instance}}}} of its originating {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}.
The module instance is used to resolve references to other definitions during execution of the function.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef1658#1{{}}\mathdef1658{(function instance)} & \hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}} &::=&
  \{ \hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}, \hyperref[exec/runtime:syntax-funcinst]{\mathsf{module}}~\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}, \hyperref[exec/runtime:syntax-funcinst]{\mathsf{code}}~\hyperref[syntax/modules:syntax-func]{\mathit{func}} \} \\ &&|&
  \{ \hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}, \hyperref[exec/runtime:syntax-funcinst]{\mathsf{hostcode}}~\hyperref[exec/runtime:syntax-hostfunc]{\mathit{hostfunc}} \} \\
\def\mathdef1658#1{{}}\mathdef1658{(host function)} & \hyperref[exec/runtime:syntax-hostfunc]{\mathit{hostfunc}} &::=& \dots \\
\end{array}\end{split}
\end{equation*}
A \sphinxstyleemphasis{host function} is a function expressed outside WebAssembly but passed to a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}} as an {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{import}}}}.
The definition and behavior of host functions are outside the scope of this specification.
For the purpose of this specification, it is assumed that when {\hyperref[\detokenize{exec/instructions:exec-invoke-host}]{\sphinxcrossref{\DUrole{std,std-ref}{invoked}}}},
a host function behaves non-deterministically,
but within certain {\hyperref[\detokenize{exec/instructions:exec-invoke-host}]{\sphinxcrossref{\DUrole{std,std-ref}{constraints}}}} that ensure the integrity of the runtime.

\begin{sphinxadmonition}{note}{Note:}
Function instances are immutable, and their identity is not observable by WebAssembly code.
However, the {\hyperref[\detokenize{intro/overview:embedder}]{\sphinxcrossref{\DUrole{std,std-ref}{embedder}}}} might provide implicit or explicit means for distinguishing their {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{addresses}}}}.
\end{sphinxadmonition}

\index{table instance|textbf}\index{table}\index{function address}\index{table type}\index{embedder}\index{element segment}\index{abstract syntax!table instance}\index{table instance!abstract syntax}\index{table!instance}\index{instance!table}\ignorespaces \phantomsection\label{\detokenize{exec/runtime:syntax-funcelem}}

\subsection{Table Instances}
\label{\detokenize{exec/runtime:syntax-funcelem}}\label{\detokenize{exec/runtime:table-instances}}\label{\detokenize{exec/runtime:syntax-tableinst}}\label{\detokenize{exec/runtime:index-7}}
A \sphinxstyleemphasis{table instance} is the runtime representation of a {\hyperref[\detokenize{syntax/modules:syntax-table}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}}.
It holds a vector of \sphinxstyleemphasis{function elements} and an optional maximum size, if one was specified in the {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table type}}}} at the table’s definition site.

Each function element is either empty, representing an uninitialized table entry, or a {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{function address}}}}.
Function elements can be mutated through the execution of an {\hyperref[\detokenize{syntax/modules:syntax-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{element segment}}}} or by external means provided by the {\hyperref[\detokenize{intro/overview:embedder}]{\sphinxcrossref{\DUrole{std,std-ref}{embedder}}}}.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef1658#1{{}}\mathdef1658{(table instance)} & \hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}} &::=&
  \{ \hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[exec/runtime:syntax-funcelem]{\mathit{funcelem}}), \hyperref[exec/runtime:syntax-tableinst]{\mathsf{max}}~\hyperref[syntax/values:syntax-int]{\def\mathdef1664#1{{\mathit{u}#1}}\mathdef1664{\mathit{32}}}^? \} \\
\def\mathdef1658#1{{}}\mathdef1658{(function element)} & \hyperref[exec/runtime:syntax-funcelem]{\mathit{funcelem}} &::=&
  \hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}^? \\
\end{array}\end{split}
\end{equation*}
It is an invariant of the semantics that the length of the element vector never exceeds the maximum size, if present.

\begin{sphinxadmonition}{note}{Note:}
Other table elements may be added in future versions of WebAssembly.
\end{sphinxadmonition}

\index{memory instance|textbf}\index{memory}\index{byte}\index{page size|textbf}\index{memory type}\index{embedder}\index{data segment}\index{instruction}\index{abstract syntax!memory instance}\index{memory instance!abstract syntax}\index{memory!instance}\index{instance!memory}\ignorespaces \phantomsection\label{\detokenize{exec/runtime:page-size}}

\subsection{Memory Instances}
\label{\detokenize{exec/runtime:index-8}}\label{\detokenize{exec/runtime:memory-instances}}\label{\detokenize{exec/runtime:syntax-meminst}}\label{\detokenize{exec/runtime:page-size}}
A \sphinxstyleemphasis{memory instance} is the runtime representation of a linear {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memory}}}}.
It holds a vector of {\hyperref[\detokenize{syntax/values:syntax-byte}]{\sphinxcrossref{\DUrole{std,std-ref}{bytes}}}} and an optional maximum size, if one was specified at the definition site of the memory.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef1658#1{{}}\mathdef1658{(memory instance)} & \hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}} &::=&
  \{ \hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}~\hyperref[syntax/conventions:syntax-vec]{\mathit{vec}}(\hyperref[syntax/values:syntax-byte]{\mathit{byte}}), \hyperref[exec/runtime:syntax-meminst]{\mathsf{max}}~\hyperref[syntax/values:syntax-int]{\def\mathdef1664#1{{\mathit{u}#1}}\mathdef1664{\mathit{32}}}^? \} \\
\end{array}\end{split}
\end{equation*}
The length of the vector always is a multiple of the WebAssembly \sphinxstyleemphasis{page size}, which is defined to be the constant \(65536\) \textendash{} abbreviated \(64\,\mathrm{Ki}\).
Like in a {\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory type}}}}, the maximum size in a memory instance is given in units of this page size.

The bytes can be mutated through {\hyperref[\detokenize{syntax/instructions:syntax-instr-memory}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instructions}}}}, the execution of a {\hyperref[\detokenize{syntax/modules:syntax-data}]{\sphinxcrossref{\DUrole{std,std-ref}{data segment}}}}, or by external means provided by the {\hyperref[\detokenize{intro/overview:embedder}]{\sphinxcrossref{\DUrole{std,std-ref}{embedder}}}}.

It is an invariant of the semantics that the length of the byte vector, divided by page size, never exceeds the maximum size, if present.

\index{global instance|textbf}\index{global}\index{value}\index{mutability}\index{instruction}\index{embedder}\index{abstract syntax!global instance}\index{global instance!abstract syntax}\index{global!instance}\index{instance!global}\ignorespaces 

\subsection{Global Instances}
\label{\detokenize{exec/runtime:global-instances}}\label{\detokenize{exec/runtime:syntax-globalinst}}\label{\detokenize{exec/runtime:index-9}}
A \sphinxstyleemphasis{global instance} is the runtime representation of a {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}} variable.
It holds an individual {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{value}}}} and a flag indicating whether it is mutable.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef1658#1{{}}\mathdef1658{(global instance)} & \hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}} &::=&
  \{ \hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}~\hyperref[exec/runtime:syntax-val]{\mathit{val}}, \hyperref[exec/runtime:syntax-globalinst]{\mathsf{mut}}~\hyperref[syntax/types:syntax-mut]{\mathit{mut}} \} \\
\end{array}\end{split}
\end{equation*}
The value of mutable globals can be mutated through {\hyperref[\detokenize{syntax/instructions:syntax-instr-variable}]{\sphinxcrossref{\DUrole{std,std-ref}{variable instructions}}}} or by external means provided by the {\hyperref[\detokenize{intro/overview:embedder}]{\sphinxcrossref{\DUrole{std,std-ref}{embedder}}}}.

\index{export instance|textbf}\index{export}\index{name}\index{external value}\index{abstract syntax!export instance}\index{export instance!abstract syntax}\index{export!instance}\index{instance!export}\ignorespaces 

\subsection{Export Instances}
\label{\detokenize{exec/runtime:index-10}}\label{\detokenize{exec/runtime:export-instances}}\label{\detokenize{exec/runtime:syntax-exportinst}}
An \sphinxstyleemphasis{export instance} is the runtime representation of an {\hyperref[\detokenize{syntax/modules:syntax-export}]{\sphinxcrossref{\DUrole{std,std-ref}{export}}}}.
It defines the export’s {\hyperref[\detokenize{syntax/values:syntax-name}]{\sphinxcrossref{\DUrole{std,std-ref}{name}}}} and the associated {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}}.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef1658#1{{}}\mathdef1658{(export instance)} & \hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}} &::=&
  \{ \hyperref[exec/runtime:syntax-exportinst]{\mathsf{name}}~\hyperref[syntax/values:syntax-name]{\mathit{name}}, \hyperref[exec/runtime:syntax-exportinst]{\mathsf{value}}~\hyperref[exec/runtime:syntax-externval]{\mathit{externval}} \} \\
\end{array}\end{split}
\end{equation*}
\index{external value|textbf}\index{function address}\index{table address}\index{memory address}\index{global address}\index{store}\index{function}\index{table}\index{memory}\index{global}\index{abstract syntax!external value}\index{external value!abstract syntax}\index{external!value}\index{value!external}\ignorespaces 

\subsection{External Values}
\label{\detokenize{exec/runtime:index-11}}\label{\detokenize{exec/runtime:external-values}}\label{\detokenize{exec/runtime:syntax-externval}}
An \sphinxstyleemphasis{external value} is the runtime representation of an entity that can be imported or exported.
It is an {\hyperref[\detokenize{exec/runtime:syntax-addr}]{\sphinxcrossref{\DUrole{std,std-ref}{address}}}} denoting either a {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{function instance}}}}, {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instance}}}}, {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}}, or {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{global instances}}}} in the shared {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}}.
\begin{equation*}
\begin{split}\begin{array}{llcl}
\def\mathdef1658#1{{}}\mathdef1658{(external value)} & \hyperref[exec/runtime:syntax-externval]{\mathit{externval}} &::=&
  \hyperref[exec/runtime:syntax-externval]{\mathsf{func}}~\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}} \\&&|&
  \hyperref[exec/runtime:syntax-externval]{\mathsf{table}}~\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}} \\&&|&
  \hyperref[exec/runtime:syntax-externval]{\mathsf{mem}}~\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}} \\&&|&
  \hyperref[exec/runtime:syntax-externval]{\mathsf{global}}~\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}} \\
\end{array}\end{split}
\end{equation*}

\subsubsection{Conventions}
\label{\detokenize{exec/runtime:conventions}}
The following auxiliary notation is defined for sequences of external values.
It filters out entries of a specific kind in an order-preserving fashion:
\begin{itemize}
\item {} 
\(\hyperref[exec/runtime:syntax-externval]{\mathrm{funcs}}(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^\ast) = [\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}} ~|~ (\hyperref[exec/runtime:syntax-externval]{\mathsf{func}}~\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}) \in \hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^\ast]\)

\item {} 
\(\hyperref[exec/runtime:syntax-externval]{\mathrm{tables}}(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^\ast) = [\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}} ~|~ (\hyperref[exec/runtime:syntax-externval]{\mathsf{table}}~\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}) \in \hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^\ast]\)

\item {} 
\(\hyperref[exec/runtime:syntax-externval]{\mathrm{mems}}(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^\ast) = [\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}} ~|~ (\hyperref[exec/runtime:syntax-externval]{\mathsf{mem}}~\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}) \in \hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^\ast]\)

\item {} 
\(\hyperref[exec/runtime:syntax-externval]{\mathrm{globals}}(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^\ast) = [\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}} ~|~ (\hyperref[exec/runtime:syntax-externval]{\mathsf{global}}~\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}) \in \hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^\ast]\)

\end{itemize}

\index{stack|textbf}\index{frame|textbf}\index{label|textbf}\index{instruction}\index{store}\index{activation}\index{function}\index{call}\index{local}\index{module instance}\index{abstract syntax!frame}\index{frame!abstract syntax}\index{abstract syntax!label}\index{label!abstract syntax}\ignorespaces \phantomsection\label{\detokenize{exec/runtime:syntax-frame}}\phantomsection\label{\detokenize{exec/runtime:syntax-label}}\phantomsection\label{\detokenize{exec/runtime:frame}}\phantomsection\label{\detokenize{exec/runtime:label}}

\subsection{Stack}
\label{\detokenize{exec/runtime:label}}\label{\detokenize{exec/runtime:index-12}}\label{\detokenize{exec/runtime:syntax-label}}\label{\detokenize{exec/runtime:stack}}\label{\detokenize{exec/runtime:frame}}\label{\detokenize{exec/runtime:syntax-frame}}\label{\detokenize{exec/runtime:id3}}
Besides the {\hyperref[\detokenize{exec/runtime:store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}}, most {\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instructions}}}} interact with an implicit \sphinxstyleemphasis{stack}.
The stack contains three kinds of entries:
\begin{itemize}
\item {} 
\sphinxstyleemphasis{Values}: the \sphinxstyleemphasis{operands} of instructions.

\item {} 
\sphinxstyleemphasis{Labels}: active {\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{structured control instructions}}}} that can be targeted by branches.

\item {} 
\sphinxstyleemphasis{Activations}: the \sphinxstyleemphasis{call frames} of active {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}} calls.

\end{itemize}

These entries can occur on the stack in any order during the execution of a program.
Stack entries are described by abstract syntax as follows.

\begin{sphinxadmonition}{note}{Note:}
It is possible to model the WebAssembly semantics using separate stacks for operands, control constructs, and calls.
However, because the stacks are interdependent, additional book keeping about associated stack heights would be required.
For the purpose of this specification, an interleaved representation is simpler.
\end{sphinxadmonition}


\subsubsection{Values}
\label{\detokenize{exec/runtime:id4}}
Values are represented by {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{themselves}}}}.


\subsubsection{Labels}
\label{\detokenize{exec/runtime:labels}}
Labels carry an argument arity \(n\) and their associated branch \sphinxstyleemphasis{target}, which is expressed syntactically as an {\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instruction}}}} sequence:
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef1658#1{{}}\mathdef1658{(label)} & \hyperref[exec/runtime:syntax-label]{\mathit{label}} &::=&
  \hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\} \\
\end{array}\end{split}
\end{equation*}
Intuitively, \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\) is the \sphinxstyleemphasis{continuation} to execute when the branch is taken, in place of the original control construct.

\begin{sphinxadmonition}{note}{Note:}
For example, a loop label has the form
\begin{equation*}
\begin{split}\hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{loop}}~\dots~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\}\end{split}
\end{equation*}
When performing a branch to this label, this executes the loop, effectively restarting it from the beginning.
Conversely, a simple block label has the form
\begin{equation*}
\begin{split}\hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\epsilon\}\end{split}
\end{equation*}
When branching, the empty continuation ends the targeted block, such that execution can proceed with consecutive instructions.
\end{sphinxadmonition}


\subsubsection{Frames}
\label{\detokenize{exec/runtime:frames}}
Activation frames carry the return arity of the respective function,
hold the values of its {\hyperref[\detokenize{syntax/modules:syntax-local}]{\sphinxcrossref{\DUrole{std,std-ref}{locals}}}} (including arguments) in the order corresponding to their static {\hyperref[\detokenize{syntax/modules:syntax-localidx}]{\sphinxcrossref{\DUrole{std,std-ref}{local indices}}}},
and a reference to the function’s own {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instance}}}}:
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef1658#1{{}}\mathdef1658{(activation)} & \mathit{activation} &::=&
  \hyperref[exec/runtime:syntax-frame]{\mathsf{frame}}_n\{\hyperref[exec/runtime:syntax-frame]{\mathit{frame}}\} \\
\def\mathdef1658#1{{}}\mathdef1658{(frame)} & \hyperref[exec/runtime:syntax-frame]{\mathit{frame}} &::=&
  \{ \hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}~\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast, \hyperref[exec/runtime:syntax-frame]{\mathsf{module}}~\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}} \} \\
\end{array}\end{split}
\end{equation*}
The values of the locals are mutated by respective {\hyperref[\detokenize{syntax/instructions:syntax-instr-variable}]{\sphinxcrossref{\DUrole{std,std-ref}{variable instructions}}}}.


\subsubsection{Conventions}
\label{\detokenize{exec/runtime:id5}}\begin{itemize}
\item {} 
The meta variable \(L\) ranges over labels where clear from context.

\item {} 
The meta variable \(F\) ranges over frames where clear from context.

\item {} 
The following auxiliary definition takes a {\hyperref[\detokenize{syntax/instructions:syntax-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{block type}}}} and looks up the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} that it denotes in the current frame:

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{lll}
\hyperref[exec/runtime:syntax-frame]{\mathrm{expand}}_F(\hyperref[syntax/modules:syntax-typeidx]{\mathit{typeidx}}) &=& F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{types}}[\hyperref[syntax/modules:syntax-typeidx]{\mathit{typeidx}}] \\
\hyperref[exec/runtime:syntax-frame]{\mathrm{expand}}_F([\hyperref[syntax/types:syntax-valtype]{\mathit{valtype}}^?]) &=& [] \hyperref[syntax/types:syntax-functype]{\rightarrow} [\hyperref[syntax/types:syntax-valtype]{\mathit{valtype}}^?] \\
\end{array}\end{split}
\end{equation*}
\index{administrative instructions|textbf}\index{function}\index{function instance}\index{function address}\index{label}\index{frame}\index{instruction}\index{trap}\index{call}\index{memory}\index{memory instance}\index{table}\index{table instance}\index{element}\index{data}\index{segment}\index{: abstract syntax!administrative instruction}\index{administrative instruction!: abstract syntax}\ignorespaces \phantomsection\label{\detokenize{exec/runtime:syntax-trap}}\phantomsection\label{\detokenize{exec/runtime:syntax-invoke}}\phantomsection\label{\detokenize{exec/runtime:syntax-init-elem}}\phantomsection\label{\detokenize{exec/runtime:syntax-init-data}}

\subsection{Administrative Instructions}
\label{\detokenize{exec/runtime:syntax-instr-admin}}\label{\detokenize{exec/runtime:syntax-trap}}\label{\detokenize{exec/runtime:index-13}}\label{\detokenize{exec/runtime:administrative-instructions}}\label{\detokenize{exec/runtime:syntax-init-elem}}\label{\detokenize{exec/runtime:syntax-init-data}}\label{\detokenize{exec/runtime:syntax-invoke}}
\begin{sphinxadmonition}{note}{Note:}
This section is only relevant for the {\hyperref[\detokenize{exec/conventions:exec-notation}]{\sphinxcrossref{\DUrole{std,std-ref}{formal notation}}}}.
\end{sphinxadmonition}

In order to express the reduction of {\hyperref[\detokenize{intro/overview:trap}]{\sphinxcrossref{\DUrole{std,std-ref}{traps}}}}, {\hyperref[\detokenize{syntax/instructions:syntax-call}]{\sphinxcrossref{\DUrole{std,std-ref}{calls}}}}, and {\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{control instructions}}}}, the syntax of instructions is extended to include the following \sphinxstyleemphasis{administrative instructions}:
\begin{equation*}
\begin{split}\begin{array}{llcl}
\def\mathdef1658#1{{}}\mathdef1658{(administrative instruction)} & \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}} &::=&
  \dots \\ &&|&
  \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}} \\ &&|&
  \hyperref[exec/runtime:syntax-invoke]{\mathsf{invoke}}~\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}} \\ &&|&
  \hyperref[exec/runtime:syntax-init-elem]{\mathsf{init\_elem}}~\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}~\hyperref[syntax/values:syntax-int]{\def\mathdef1664#1{{\mathit{u}#1}}\mathdef1664{\mathit{32}}}~\hyperref[syntax/modules:syntax-funcidx]{\mathit{funcidx}}^\ast \\ &&|&
  \hyperref[exec/runtime:syntax-init-data]{\mathsf{init\_data}}~\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}~\hyperref[syntax/values:syntax-int]{\def\mathdef1664#1{{\mathit{u}#1}}\mathdef1664{\mathit{32}}}~\hyperref[syntax/values:syntax-byte]{\mathit{byte}}^\ast \\ &&|&
  \hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \\ &&|&
  \hyperref[exec/runtime:syntax-frame]{\mathsf{frame}}_n\{\hyperref[exec/runtime:syntax-frame]{\mathit{frame}}\}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \\
\end{array}\end{split}
\end{equation*}
The \(\hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}\) instruction represents the occurrence of a trap.
Traps are bubbled up through nested instruction sequences, ultimately reducing the entire program to a single \(\hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}\) instruction, signalling abrupt termination.

The \(\hyperref[exec/runtime:syntax-invoke]{\mathsf{invoke}}\) instruction represents the imminent invocation of a {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{function instance}}}}, identified by its {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{address}}}}.
It unifies the handling of different forms of calls.

The \(\hyperref[exec/runtime:syntax-init-elem]{\mathsf{init\_elem}}\) and \(\hyperref[exec/runtime:syntax-init-data]{\mathsf{init\_data}}\) instructions perform initialization of {\hyperref[\detokenize{syntax/modules:syntax-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{element}}}} and {\hyperref[\detokenize{syntax/modules:syntax-data}]{\sphinxcrossref{\DUrole{std,std-ref}{data}}}} segments during module {\hyperref[\detokenize{exec/modules:exec-instantiation}]{\sphinxcrossref{\DUrole{std,std-ref}{instantiation}}}}.

\begin{sphinxadmonition}{note}{Note:}
The reason for splitting instantiation into individual reduction steps is to provide a semantics that is compatible with future extensions like threads.
\end{sphinxadmonition}

The \(\hyperref[exec/runtime:syntax-label]{\mathsf{label}}\) and \(\hyperref[exec/runtime:syntax-frame]{\mathsf{frame}}\) instructions model {\hyperref[\detokenize{exec/runtime:syntax-label}]{\sphinxcrossref{\DUrole{std,std-ref}{labels}}}} and {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frames}}}} {\hyperref[\detokenize{exec/conventions:exec-notation}]{\sphinxcrossref{\DUrole{std,std-ref}{“on the stack”}}}}.
Moreover, the administrative syntax maintains the nesting structure of the original {\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{structured control instruction}}}} or {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function body}}}} and their {\hyperref[\detokenize{syntax/instructions:syntax-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{instruction sequences}}}} with an \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\) marker.
That way, the end of the inner instruction sequence is known when part of an outer sequence.

\begin{sphinxadmonition}{note}{Note:}
For example, the {\hyperref[\detokenize{exec/instructions:exec-block}]{\sphinxcrossref{\DUrole{std,std-ref}{reduction rule}}}} for \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}\) is:
\begin{equation*}
\begin{split}\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}~[t^n]~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \quad\hyperref[exec/conventions:formal-notation]{\hookrightarrow}\quad
\hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\epsilon\}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\end{split}
\end{equation*}
This replaces the block with a label instruction,
which can be interpreted as “pushing” the label on the stack.
When \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\) is reached, i.e., the inner instruction sequence has been reduced to the empty sequence \textendash{} or rather, a sequence of \(n\) \(\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}\) instructions representing the resulting values \textendash{} then the \(\hyperref[exec/runtime:syntax-label]{\mathsf{label}}\) instruction is eliminated courtesy of its own {\hyperref[\detokenize{exec/instructions:exec-label}]{\sphinxcrossref{\DUrole{std,std-ref}{reduction rule}}}}:
\begin{equation*}
\begin{split}\hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^n\}~\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \quad\hyperref[exec/conventions:formal-notation]{\hookrightarrow}\quad \hyperref[exec/runtime:syntax-val]{\mathit{val}}^n\end{split}
\end{equation*}
This can be interpreted as removing the label from the stack and only leaving the locally accumulated operand values.
\end{sphinxadmonition}

\index{block context|textbf}\index{instruction}\index{branch}\ignorespaces 

\subsubsection{Block Contexts}
\label{\detokenize{exec/runtime:block-contexts}}\label{\detokenize{exec/runtime:syntax-ctxt-block}}\label{\detokenize{exec/runtime:index-14}}
In order to specify the reduction of {\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{branches}}}}, the following syntax of \sphinxstyleemphasis{block contexts} is defined, indexed by the count \(k\) of labels surrounding the hole:
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef1658#1{{}}\mathdef1658{(block contexts)} & \hyperref[exec/runtime:syntax-ctxt-block]{B}^0 &::=&
  \hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast~[\_]~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast \\
\def\mathdef1658#1{{}}\mathdef1658{(block contexts)} & \hyperref[exec/runtime:syntax-ctxt-block]{B}^{k+1} &::=&
  \hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast~\hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\}~\hyperref[exec/runtime:syntax-ctxt-block]{B}^k~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast \\
\end{array}\end{split}
\end{equation*}
This definition allows to index active labels surrounding a {\hyperref[\detokenize{syntax/instructions:syntax-br}]{\sphinxcrossref{\DUrole{std,std-ref}{branch}}}} or {\hyperref[\detokenize{syntax/instructions:syntax-return}]{\sphinxcrossref{\DUrole{std,std-ref}{return}}}} instruction.

\begin{sphinxadmonition}{note}{Note:}
For example, the {\hyperref[\detokenize{exec/instructions:exec-br}]{\sphinxcrossref{\DUrole{std,std-ref}{reduction}}}} of a simple branch can be defined as follows:
\begin{equation*}
\begin{split}\hyperref[exec/runtime:syntax-label]{\mathsf{label}}_0\{\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\}~\hyperref[exec/runtime:syntax-ctxt-block]{B}^l[\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}~l]~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \quad\hyperref[exec/conventions:formal-notation]{\hookrightarrow}\quad \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\end{split}
\end{equation*}
Here, the hole \([\_]\) of the context is instantiated with a branch instruction.
When a branch occurs,
this rule replaces the targeted label and associated instruction sequence with the label’s continuation.
The selected label is identified through the {\hyperref[\detokenize{syntax/modules:syntax-labelidx}]{\sphinxcrossref{\DUrole{std,std-ref}{label index}}}} \(l\), which corresponds to the number of surrounding \(\hyperref[exec/runtime:syntax-label]{\mathsf{label}}\) instructions that must be hopped over \textendash{} which is exactly the count encoded in the index of a block context.
\end{sphinxadmonition}

\index{configuration|textbf}\index{thread|textbf}\index{store}\index{frame}\index{instruction}\index{module instruction}\ignorespaces \phantomsection\label{\detokenize{exec/runtime:syntax-thread}}

\subsubsection{Configurations}
\label{\detokenize{exec/runtime:syntax-thread}}\label{\detokenize{exec/runtime:index-15}}\label{\detokenize{exec/runtime:syntax-config}}\label{\detokenize{exec/runtime:configurations}}
A \sphinxstyleemphasis{configuration} consists of the current {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} and an executing \sphinxstyleemphasis{thread}.

A thread is a computation over {\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instructions}}}}
that operates relative to a current {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}} referring to the home {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instance}}}} that the computation runs in.
\begin{equation*}
\begin{split}\begin{array}{llcl}
\def\mathdef1658#1{{}}\mathdef1658{(configuration)} & \hyperref[exec/runtime:syntax-config]{\mathit{config}} &::=&
  \hyperref[exec/runtime:syntax-store]{\mathit{store}}; \hyperref[exec/runtime:syntax-thread]{\mathit{thread}} \\
\def\mathdef1658#1{{}}\mathdef1658{(thread)} & \hyperref[exec/runtime:syntax-thread]{\mathit{thread}} &::=&
  \hyperref[exec/runtime:syntax-frame]{\mathit{frame}}; \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The current version of WebAssembly is single-threaded,
but configurations with multiple threads may be supported in the future.
\end{sphinxadmonition}

\index{evaluation context|textbf}\index{instruction}\index{trap}\index{label}\index{frame}\index{value}\ignorespaces 

\subsubsection{Evaluation Contexts}
\label{\detokenize{exec/runtime:evaluation-contexts}}\label{\detokenize{exec/runtime:syntax-ctxt-eval}}\label{\detokenize{exec/runtime:index-16}}
Finally, the following definition of \sphinxstyleemphasis{evaluation context} and associated structural rules enable reduction inside instruction sequences and administrative forms as well as the propagation of traps:
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef1658#1{{}}\mathdef1658{(evaluation contexts)} & E &::=&
  [\_] ~|~
  \hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast~E~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast ~|~
  \hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\}~E~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \\
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{rcl}
S; F; E[\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast] &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S'; F'; E[{\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}'}^\ast] \\
  && (\mathrel{\mbox{if}} S; F; \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast \hyperref[exec/conventions:formal-notation]{\hookrightarrow} S'; F'; {\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}'}^\ast) \\
S; F; \hyperref[exec/runtime:syntax-frame]{\mathsf{frame}}_n\{F'\}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S'; F; \hyperref[exec/runtime:syntax-frame]{\mathsf{frame}}_n\{F''\}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}'^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \\
  && (\mathrel{\mbox{if}} S; F'; \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast \hyperref[exec/conventions:formal-notation]{\hookrightarrow} S'; F''; {\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}'}^\ast) \\[1ex]
S; F; E[\hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}] &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S; F; \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}
  \qquad (\mathrel{\mbox{if}} E \neq [\_]) \\
S; F; \hyperref[exec/runtime:syntax-frame]{\mathsf{frame}}_n\{F'\}~\hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S; F; \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}} \\
\end{array}\end{split}
\end{equation*}
Reduction terminates when a thread’s instruction sequence has been reduced to a {\hyperref[\detokenize{exec/runtime:syntax-result}]{\sphinxcrossref{\DUrole{std,std-ref}{result}}}},
that is, either a sequence of {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} or to a \(\hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}\).

\begin{sphinxadmonition}{note}{Note:}
The restriction on evaluation contexts rules out contexts like \([\_]\) and \(\epsilon~[\_]~\epsilon\) for which \(E[\hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}] = \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}\).

For an example of reduction under evaluation contexts, consider the following instruction sequence.
\begin{equation*}
\begin{split}(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_1)~(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_2)~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{neg}}~(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_3)~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}}~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{mul}}\end{split}
\end{equation*}
This can be decomposed into \(E[(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_2)~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{neg}}]\) where
\begin{equation*}
\begin{split}E = (\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_1)~[\_]~(\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~x_3)~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}}~\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{mul}}\end{split}
\end{equation*}
Moreover, this is the \sphinxstyleemphasis{only} possible choice of evaluation context where the contents of the hole matches the left-hand side of a reduction rule.
\end{sphinxadmonition}

\index{value}\index{integer}\index{floating-point}\index{bit width}\index{determinism}\index{NaN}\ignorespaces \phantomsection\label{\detokenize{exec/numerics:exec-op-partial}}

\section{Numerics}
\label{\detokenize{exec/numerics:exec-numeric}}\label{\detokenize{exec/numerics:numerics}}\label{\detokenize{exec/numerics:exec-op-partial}}\label{\detokenize{exec/numerics::doc}}\label{\detokenize{exec/numerics:index-0}}
Numeric primitives are defined in a generic manner, by operators indexed over a bit width \(N\).

Some operators are \sphinxstyleemphasis{non-deterministic}, because they can return one of several possible results (such as different {\hyperref[\detokenize{syntax/values:syntax-nan}]{\sphinxcrossref{\DUrole{std,std-ref}{NaN}}}} values).
Technically, each operator thus returns a \sphinxstyleemphasis{set} of allowed values.
For convenience, deterministic results are expressed as plain values, which are assumed to be identified with a respective singleton set.

Some operators are \sphinxstyleemphasis{partial}, because they are not defined on certain inputs.
Technically, an empty set of results is returned for these inputs.

In formal notation, each operator is defined by equational clauses that apply in decreasing order of precedence.
That is, the first clause that is applicable to the given arguments defines the result.
In some cases, similar clauses are combined into one by using the notation \(\pm\) or \(\mp\).
When several of these placeholders occur in a single clause, then they must be resolved consistently: either the upper sign is chosen for all of them or the lower sign.

\begin{sphinxadmonition}{note}{Note:}
For example, the \(\hyperref[exec/numerics:op-fcopysign]{\mathrm{fcopysign}}\) operator is defined as follows:
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fcopysign]{\mathrm{fcopysign}}_N(\pm p_1, \pm p_2) &=& \pm p_1 \\
\hyperref[exec/numerics:op-fcopysign]{\mathrm{fcopysign}}_N(\pm p_1, \mp p_2) &=& \mp p_1 \\
\end{array}\end{split}
\end{equation*}
This definition is to be read as a shorthand for the following expansion of each clause into two separate ones:
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fcopysign]{\mathrm{fcopysign}}_N(+ p_1, + p_2) &=& + p_1 \\
\hyperref[exec/numerics:op-fcopysign]{\mathrm{fcopysign}}_N(- p_1, - p_2) &=& - p_1 \\
\hyperref[exec/numerics:op-fcopysign]{\mathrm{fcopysign}}_N(+ p_1, - p_2) &=& - p_1 \\
\hyperref[exec/numerics:op-fcopysign]{\mathrm{fcopysign}}_N(- p_1, + p_2) &=& + p_1 \\
\end{array}\end{split}
\end{equation*}\end{sphinxadmonition}
\phantomsection\label{\detokenize{exec/numerics:aux-trunc}}
Conventions:
\begin{itemize}
\item {} 
The meta variable \(d\) is used to range over single bits.

\item {} 
The meta variable \(p\) is used to range over (signless) {\hyperref[\detokenize{syntax/values:syntax-float}]{\sphinxcrossref{\DUrole{std,std-ref}{magnitudes}}}} of floating-point values, including \(\hyperref[syntax/values:syntax-float]{\mathsf{nan}}\) and \(\infty\).

\item {} 
The meta variable \(q\) is used to range over (signless) \sphinxstyleemphasis{rational} {\hyperref[\detokenize{syntax/values:syntax-float}]{\sphinxcrossref{\DUrole{std,std-ref}{magnitudes}}}}, excluding \(\hyperref[syntax/values:syntax-float]{\mathsf{nan}}\) or \(\infty\).

\item {} 
The notation \(f^{-1}\) denotes the inverse of a bijective function \(f\).

\item {} 
Truncation of rational values is written \(\hyperref[exec/numerics:aux-trunc]{\mathrm{trunc}}(\pm q)\), with the usual mathematical definition:
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:aux-trunc]{\mathrm{trunc}}(\pm q) &=& \pm i & (\mathrel{\mbox{if}} i \in \mathbb{N} \wedge q - 1 < i \leq q) \\
\end{array}\end{split}
\end{equation*}
\end{itemize}

\index{bit}\index{integer}\index{floating-point}\ignorespaces 

\subsection{Representations}
\label{\detokenize{exec/numerics:representations}}\label{\detokenize{exec/numerics:index-1}}\label{\detokenize{exec/numerics:aux-bits}}
Numbers have an underlying binary representation as a sequence of bits:
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:aux-bits]{\mathrm{bits}}_{\mathsf{i}N}(i) &=& \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i) \\
\hyperref[exec/numerics:aux-bits]{\mathrm{bits}}_{\mathsf{f}N}(z) &=& \hyperref[exec/numerics:aux-fbits]{\mathrm{fbits}}_N(z) \\
\end{array}\end{split}
\end{equation*}
Each of these functions is a bijection, hence they are invertible.

\index{Boolean}\ignorespaces 

\subsubsection{Integers}
\label{\detokenize{exec/numerics:integers}}\label{\detokenize{exec/numerics:index-2}}\label{\detokenize{exec/numerics:aux-ibits}}
{\hyperref[\detokenize{syntax/values:syntax-int}]{\sphinxcrossref{\DUrole{std,std-ref}{Integers}}}} are represented as base two unsigned numbers:
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i) &=& d_{N-1}~\dots~d_0 & (i = 2^{N-1}\cdot d_{N-1} + \dots + 2^0\cdot d_0) \\
\end{array}\end{split}
\end{equation*}
Boolean operators like \(\wedge\), \(\vee\), or \(\veebar\) are lifted to bit sequences of equal length by applying them pointwise.

\index{IEEE 754}\index{significand}\index{exponent}\ignorespaces \phantomsection\label{\detokenize{exec/numerics:aux-fbias}}\phantomsection\label{\detokenize{exec/numerics:aux-fsign}}

\subsubsection{Floating-Point}
\label{\detokenize{exec/numerics:floating-point}}\label{\detokenize{exec/numerics:aux-fbias}}\label{\detokenize{exec/numerics:index-3}}\label{\detokenize{exec/numerics:aux-fbits}}\label{\detokenize{exec/numerics:aux-fsign}}
{\hyperref[\detokenize{syntax/values:syntax-float}]{\sphinxcrossref{\DUrole{std,std-ref}{Floating-point values}}}} are represented in the respective binary format defined by \sphinxhref{http://ieeexplore.ieee.org/document/4610935/}{IEEE 754-2008}%
\begin{footnote}[22]\sphinxAtStartFootnote
\sphinxnolinkurl{http://ieeexplore.ieee.org/document/4610935/}
%
\end{footnote} (Section 3.4):
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:aux-fbits]{\mathrm{fbits}}_N(\pm (1+m\cdot 2^{-M})\cdot 2^e) &=& \hyperref[exec/numerics:aux-fsign]{\mathrm{fsign}}({\pm})~\hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_E(e+\hyperref[exec/numerics:aux-fbias]{\mathrm{fbias}}_N)~\hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_M(m) \\
\hyperref[exec/numerics:aux-fbits]{\mathrm{fbits}}_N(\pm (0+m\cdot 2^{-M})\cdot 2^e) &=& \hyperref[exec/numerics:aux-fsign]{\mathrm{fsign}}({\pm})~(0)^E~\hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_M(m) \\
\hyperref[exec/numerics:aux-fbits]{\mathrm{fbits}}_N(\pm \infty) &=& \hyperref[exec/numerics:aux-fsign]{\mathrm{fsign}}({\pm})~(1)^E~(0)^M \\
\hyperref[exec/numerics:aux-fbits]{\mathrm{fbits}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-fsign]{\mathrm{fsign}}({\pm})~(1)^E~\hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_M(n) \\[1ex]
\hyperref[exec/numerics:aux-fbias]{\mathrm{fbias}}_N &=& 2^{E-1}-1 \\
\hyperref[exec/numerics:aux-fsign]{\mathrm{fsign}}({+}) &=& 0 \\
\hyperref[exec/numerics:aux-fsign]{\mathrm{fsign}}({-}) &=& 1 \\
\end{array}\end{split}
\end{equation*}
where \(M = \hyperref[syntax/values:aux-significand]{\mathrm{signif}}(N)\) and \(E = \hyperref[syntax/values:aux-exponent]{\mathrm{expon}}(N)\).

\index{byte}\index{little endian}\index{memory}\ignorespaces \phantomsection\label{\detokenize{exec/numerics:aux-littleendian}}

\subsubsection{Storage}
\label{\detokenize{exec/numerics:index-4}}\label{\detokenize{exec/numerics:storage}}\label{\detokenize{exec/numerics:aux-bytes}}\label{\detokenize{exec/numerics:aux-littleendian}}
When a number is stored into {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memory}}}}, it is converted into a sequence of {\hyperref[\detokenize{syntax/values:syntax-byte}]{\sphinxcrossref{\DUrole{std,std-ref}{bytes}}}} in \sphinxhref{https://en.wikipedia.org/wiki/Endianness\#Little-endian}{little endian}%
\begin{footnote}[23]\sphinxAtStartFootnote
\sphinxnolinkurl{https://en.wikipedia.org/wiki/Endianness\#Little-endian}
%
\end{footnote} byte order:
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:aux-bytes]{\mathrm{bytes}}_t(i) &=& \hyperref[exec/numerics:aux-littleendian]{\mathrm{littleendian}}(\hyperref[exec/numerics:aux-bits]{\mathrm{bits}}_t(i)) \\[1ex]
\hyperref[exec/numerics:aux-littleendian]{\mathrm{littleendian}}(\epsilon) &=& \epsilon \\
\hyperref[exec/numerics:aux-littleendian]{\mathrm{littleendian}}(d_1^8~d_2^{N-8}) &=& \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_8^{-1}(d_1^8)~\hyperref[exec/numerics:aux-littleendian]{\mathrm{littleendian}}(d_2^{N-8}) \\
\end{array}\end{split}
\end{equation*}
Again these functions are invertable bijections.

\index{integer}\ignorespaces 

\subsection{Integer Operations}
\label{\detokenize{exec/numerics:index-5}}\label{\detokenize{exec/numerics:int-ops}}\label{\detokenize{exec/numerics:integer-operations}}
\index{sign}\index{signed integer}\index{unsigned integer}\index{uninterpreted integer}\index{two's complement}\ignorespaces 

\subsubsection{Sign Interpretation}
\label{\detokenize{exec/numerics:sign-interpretation}}\label{\detokenize{exec/numerics:index-6}}\label{\detokenize{exec/numerics:aux-signed}}
Integer operators are defined on \(\hyperref[syntax/values:syntax-int]{\def\mathdef1613#1{{\mathit{i}#1}}\mathdef1613{N}}\) values.
Operators that use a signed interpretation convert the value using the following definition, which takes the two’s complement when the value lies in the upper half of the value range (i.e., its most significant bit is \(1\)):
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i) &=& i & (0 \leq i < 2^{N-1}) \\
\hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i) &=& i - 2^N & (2^{N-1} \leq i < 2^N) \\
\end{array}\end{split}
\end{equation*}
This function is bijective, and hence invertible.

\index{Boolean}\ignorespaces 

\subsubsection{Boolean Interpretation}
\label{\detokenize{exec/numerics:aux-bool}}\label{\detokenize{exec/numerics:boolean-interpretation}}\label{\detokenize{exec/numerics:index-7}}
The integer result of predicates \textendash{} i.e., {\hyperref[\detokenize{syntax/instructions:syntax-testop}]{\sphinxcrossref{\DUrole{std,std-ref}{tests}}}} and {\hyperref[\detokenize{syntax/instructions:syntax-relop}]{\sphinxcrossref{\DUrole{std,std-ref}{relational}}}} operators \textendash{} is defined with the help of the following auxiliary function producing the value \(1\) or \(0\) depending on a condition.
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(C) &=& 1 & (\mathrel{\mbox{if}} C) \\
\hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(C) &=& 0 & (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-iadd]{\mathrm{iadd}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:id1}}\label{\detokenize{exec/numerics:op-iadd}}\begin{itemize}
\item {} 
Return the result of adding \(i_1\) and \(i_2\) modulo \(2^N\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-iadd]{\mathrm{iadd}}_N(i_1, i_2) &=& (i_1 + i_2) \mathbin{\mathrm{mod}} 2^N
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-isub]{\mathrm{isub}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-isub}}\label{\detokenize{exec/numerics:id2}}\begin{itemize}
\item {} 
Return the result of subtracting \(i_2\) from \(i_1\) modulo \(2^N\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-isub]{\mathrm{isub}}_N(i_1, i_2) &=& (i_1 - i_2 + 2^N) \mathbin{\mathrm{mod}} 2^N
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-imul]{\mathrm{imul}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-imul}}\label{\detokenize{exec/numerics:id3}}\begin{itemize}
\item {} 
Return the result of multiplying \(i_1\) and \(i_2\) modulo \(2^N\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-imul]{\mathrm{imul}}_N(i_1, i_2) &=& (i_1 \cdot i_2) \mathbin{\mathrm{mod}} 2^N
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-idiv-u]{\mathrm{idiv\_u}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:id4}}\label{\detokenize{exec/numerics:op-idiv-u}}\begin{itemize}
\item {} 
If \(i_2\) is \(0\), then the result is undefined.

\item {} 
Else, return the result of dividing \(i_1\) by \(i_2\), truncated toward zero.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-idiv-u]{\mathrm{idiv\_u}}_N(i_1, 0) &=& \{\} \\
\hyperref[exec/numerics:op-idiv-u]{\mathrm{idiv\_u}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-trunc]{\mathrm{trunc}}(i_1 / i_2) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
This operator is {\hyperref[\detokenize{exec/numerics:exec-op-partial}]{\sphinxcrossref{\DUrole{std,std-ref}{partial}}}}.
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[exec/numerics:op-idiv-s]{\mathrm{idiv\_s}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-idiv-s}}\label{\detokenize{exec/numerics:id5}}\begin{itemize}
\item {} 
Let \(j_1\) be the {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{signed interpretation}}}} of \(i_1\).

\item {} 
Let \(j_2\) be the {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{signed interpretation}}}} of \(i_2\).

\item {} 
If \(j_2\) is \(0\), then the result is undefined.

\item {} 
Else if \(j_1\) divided by \(j_2\) is \(2^{N-1}\), then the result is undefined.

\item {} 
Else, return the result of dividing \(j_1\) by \(j_2\), truncated toward zero.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-idiv-s]{\mathrm{idiv\_s}}_N(i_1, 0) &=& \{\} \\
\hyperref[exec/numerics:op-idiv-s]{\mathrm{idiv\_s}}_N(i_1, i_2) &=& \{\} \qquad\qquad (\mathrel{\mbox{if}} \hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i_1) / \hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i_2) = 2^{N-1}) \\
\hyperref[exec/numerics:op-idiv-s]{\mathrm{idiv\_s}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N^{-1}(\hyperref[exec/numerics:aux-trunc]{\mathrm{trunc}}(\hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i_1) / \hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i_2))) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
This operator is {\hyperref[\detokenize{exec/numerics:exec-op-partial}]{\sphinxcrossref{\DUrole{std,std-ref}{partial}}}}.
Besides division by \(0\), the result of \((-2^{N-1})/(-1) = +2^{N-1}\) is not representable as an \(N\)-bit signed integer.
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[exec/numerics:op-irem-u]{\mathrm{irem\_u}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-irem-u}}\label{\detokenize{exec/numerics:id6}}\begin{itemize}
\item {} 
If \(i_2\) is \(0\), then the result is undefined.

\item {} 
Else, return the remainder of dividing \(i_1\) by \(i_2\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-irem-u]{\mathrm{irem\_u}}_N(i_1, 0) &=& \{\} \\
\hyperref[exec/numerics:op-irem-u]{\mathrm{irem\_u}}_N(i_1, i_2) &=& i_1 - i_2 \cdot \hyperref[exec/numerics:aux-trunc]{\mathrm{trunc}}(i_1 / i_2) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
This operator is {\hyperref[\detokenize{exec/numerics:exec-op-partial}]{\sphinxcrossref{\DUrole{std,std-ref}{partial}}}}.

As long as both operators are defined,
it holds that \(i_1 = i_2\cdot\hyperref[exec/numerics:op-idiv-u]{\mathrm{idiv\_u}}(i_1, i_2) + \hyperref[exec/numerics:op-irem-u]{\mathrm{irem\_u}}(i_1, i_2)\).
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[exec/numerics:op-irem-s]{\mathrm{irem\_s}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-irem-s}}\label{\detokenize{exec/numerics:id7}}\begin{itemize}
\item {} 
Let \(j_1\) be the {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{signed interpretation}}}} of \(i_1\).

\item {} 
Let \(j_2\) be the {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{signed interpretation}}}} of \(i_2\).

\item {} 
If \(i_2\) is \(0\), then the result is undefined.

\item {} 
Else, return the remainder of dividing \(j_1\) by \(j_2\), with the sign of the dividend \(j_1\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-irem-s]{\mathrm{irem\_s}}_N(i_1, 0) &=& \{\} \\
\hyperref[exec/numerics:op-irem-s]{\mathrm{irem\_s}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N^{-1}(j_1 - j_2 \cdot \hyperref[exec/numerics:aux-trunc]{\mathrm{trunc}}(j_1 / j_2)) \\
  && (\mathrel{\mbox{where}} j_1 = \hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i_1) \wedge j_2 = \hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i_2)) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
This operator is {\hyperref[\detokenize{exec/numerics:exec-op-partial}]{\sphinxcrossref{\DUrole{std,std-ref}{partial}}}}.

As long as both operators are defined,
it holds that \(i_1 = i_2\cdot\hyperref[exec/numerics:op-idiv-s]{\mathrm{idiv\_s}}(i_1, i_2) + \hyperref[exec/numerics:op-irem-s]{\mathrm{irem\_s}}(i_1, i_2)\).
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[exec/numerics:op-iand]{\mathrm{iand}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:id8}}\label{\detokenize{exec/numerics:op-iand}}\begin{itemize}
\item {} 
Return the bitwise conjunction of \(i_1\) and \(i_2\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-iand]{\mathrm{iand}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N^{-1}(\hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i_1) \wedge \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i_2))
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ior]{\mathrm{ior}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-ior}}\label{\detokenize{exec/numerics:id9}}\begin{itemize}
\item {} 
Return the bitwise disjunction of \(i_1\) and \(i_2\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ior]{\mathrm{ior}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N^{-1}(\hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i_1) \vee \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i_2))
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ixor]{\mathrm{ixor}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-ixor}}\label{\detokenize{exec/numerics:id10}}\begin{itemize}
\item {} 
Return the bitwise exclusive disjunction of \(i_1\) and \(i_2\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ixor]{\mathrm{ixor}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N^{-1}(\hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i_1) \veebar \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i_2))
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ishl]{\mathrm{ishl}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-ishl}}\label{\detokenize{exec/numerics:id11}}\begin{itemize}
\item {} 
Let \(k\) be \(i_2\) modulo \(N\).

\item {} 
Return the result of shifting \(i_1\) left by \(k\) bits, modulo \(2^N\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ishl]{\mathrm{ishl}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N^{-1}(d_2^{N-k}~0^k)
  & (\mathrel{\mbox{if}} \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i_1) = d_1^k~d_2^{N-k} \wedge k = i_2 \mathbin{\mathrm{mod}} N)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ishr-u]{\mathrm{ishr\_u}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-ishr-u}}\label{\detokenize{exec/numerics:id12}}\begin{itemize}
\item {} 
Let \(j_2\) be \(i_2\) modulo \(N\).

\item {} 
Return the result of shifting \(i_1\) right by \(j_2\) bits, extended with \(0\) bits.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ishr-u]{\mathrm{ishr\_u}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N^{-1}(0^k~d_1^{N-k})
  & (\mathrel{\mbox{if}} \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i_1) = d_1^{N-k}~d_2^k \wedge k = i_2 \mathbin{\mathrm{mod}} N)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ishr-s]{\mathrm{ishr\_s}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-ishr-s}}\label{\detokenize{exec/numerics:id13}}\begin{itemize}
\item {} 
Let \(j_2\) be \(i_2\) modulo \(N\).

\item {} 
Return the result of shifting \(i_1\) right by \(j_2\) bits, extended with the most significant bit of the original value.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ishr-s]{\mathrm{ishr\_s}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N^{-1}(d_0^{k+1}~d_1^{N-k-1})
  & (\mathrel{\mbox{if}} \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i_1) = d_0~d_1^{N-k-1}~d_2^k \wedge k = i_2 \mathbin{\mathrm{mod}} N)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-irotl]{\mathrm{irotl}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:id14}}\label{\detokenize{exec/numerics:op-irotl}}\begin{itemize}
\item {} 
Let \(j_2\) be \(i_2\) modulo \(N\).

\item {} 
Return the result of rotating \(i_1\) left by \(j_2\) bits.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-irotl]{\mathrm{irotl}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N^{-1}(d_2^{N-k}~d_1^k)
  & (\mathrel{\mbox{if}} \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i_1) = d_1^k~d_2^{N-k} \wedge k = i_2 \mathbin{\mathrm{mod}} N)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-irotr]{\mathrm{irotr}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-irotr}}\label{\detokenize{exec/numerics:id15}}\begin{itemize}
\item {} 
Let \(j_2\) be \(i_2\) modulo \(N\).

\item {} 
Return the result of rotating \(i_1\) right by \(j_2\) bits.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-irotr]{\mathrm{irotr}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N^{-1}(d_2^k~d_1^{N-k})
  & (\mathrel{\mbox{if}} \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i_1) = d_1^{N-k}~d_2^k \wedge k = i_2 \mathbin{\mathrm{mod}} N)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-iclz]{\mathrm{iclz}}_N(i)\protect\)}
\label{\detokenize{exec/numerics:op-iclz}}\label{\detokenize{exec/numerics:id16}}\begin{itemize}
\item {} 
Return the count of leading zero bits in \(i\); all bits are considered leading zeros if \(i\) is \(0\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-iclz]{\mathrm{iclz}}_N(i) &=& k & (\mathrel{\mbox{if}} \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i) = 0^k~(1~d^\ast)^?)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ictz]{\mathrm{ictz}}_N(i)\protect\)}
\label{\detokenize{exec/numerics:id17}}\label{\detokenize{exec/numerics:op-ictz}}\begin{itemize}
\item {} 
Return the count of trailing zero bits in \(i\); all bits are considered trailing zeros if \(i\) is \(0\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ictz]{\mathrm{ictz}}_N(i) &=& k & (\mathrel{\mbox{if}} \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i) = (d^\ast~1)^?~0^k)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ipopcnt]{\mathrm{ipopcnt}}_N(i)\protect\)}
\label{\detokenize{exec/numerics:op-ipopcnt}}\label{\detokenize{exec/numerics:id18}}\begin{itemize}
\item {} 
Return the count of non-zero bits in \(i\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ipopcnt]{\mathrm{ipopcnt}}_N(i) &=& k & (\mathrel{\mbox{if}} \hyperref[exec/numerics:aux-ibits]{\mathrm{ibits}}_N(i) = (0^\ast~1)^k~0^\ast)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ieqz]{\mathrm{ieqz}}_N(i)\protect\)}
\label{\detokenize{exec/numerics:id19}}\label{\detokenize{exec/numerics:op-ieqz}}\begin{itemize}
\item {} 
Return \(1\) if \(i\) is zero, \(0\) otherwise.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ieqz]{\mathrm{ieqz}}_N(i) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(i = 0)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ieq]{\mathrm{ieq}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:id20}}\label{\detokenize{exec/numerics:op-ieq}}\begin{itemize}
\item {} 
Return \(1\) if \(i_1\) equals \(i_2\), \(0\) otherwise.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ieq]{\mathrm{ieq}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(i_1 = i_2)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ine]{\mathrm{ine}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:id21}}\label{\detokenize{exec/numerics:op-ine}}\begin{itemize}
\item {} 
Return \(1\) if \(i_1\) does not equal \(i_2\), \(0\) otherwise.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ine]{\mathrm{ine}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(i_1 \neq i_2)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ilt-u]{\mathrm{ilt\_u}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-ilt-u}}\label{\detokenize{exec/numerics:id22}}\begin{itemize}
\item {} 
Return \(1\) if \(i_1\) is less than \(i_2\), \(0\) otherwise.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ilt-u]{\mathrm{ilt\_u}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(i_1 < i_2)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ilt-s]{\mathrm{ilt\_s}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-ilt-s}}\label{\detokenize{exec/numerics:id23}}\begin{itemize}
\item {} 
Let \(j_1\) be the {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{signed interpretation}}}} of \(i_1\).

\item {} 
Let \(j_2\) be the {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{signed interpretation}}}} of \(i_2\).

\item {} 
Return \(1\) if \(j_1\) is less than \(j_2\), \(0\) otherwise.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ilt-s]{\mathrm{ilt\_s}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(\hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i_1) < \hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i_2))
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-igt-u]{\mathrm{igt\_u}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-igt-u}}\label{\detokenize{exec/numerics:id24}}\begin{itemize}
\item {} 
Return \(1\) if \(i_1\) is greater than \(i_2\), \(0\) otherwise.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-igt-u]{\mathrm{igt\_u}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(i_1 > i_2)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-igt-s]{\mathrm{igt\_s}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:id25}}\label{\detokenize{exec/numerics:op-igt-s}}\begin{itemize}
\item {} 
Let \(j_1\) be the {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{signed interpretation}}}} of \(i_1\).

\item {} 
Let \(j_2\) be the {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{signed interpretation}}}} of \(i_2\).

\item {} 
Return \(1\) if \(j_1\) is greater than \(j_2\), \(0\) otherwise.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-igt-s]{\mathrm{igt\_s}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(\hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i_1) > \hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i_2))
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ile-u]{\mathrm{ile\_u}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-ile-u}}\label{\detokenize{exec/numerics:id26}}\begin{itemize}
\item {} 
Return \(1\) if \(i_1\) is less than or equal to \(i_2\), \(0\) otherwise.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ile-u]{\mathrm{ile\_u}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(i_1 \leq i_2)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ile-s]{\mathrm{ile\_s}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:id27}}\label{\detokenize{exec/numerics:op-ile-s}}\begin{itemize}
\item {} 
Let \(j_1\) be the {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{signed interpretation}}}} of \(i_1\).

\item {} 
Let \(j_2\) be the {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{signed interpretation}}}} of \(i_2\).

\item {} 
Return \(1\) if \(j_1\) is less than or equal to \(j_2\), \(0\) otherwise.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ile-s]{\mathrm{ile\_s}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(\hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i_1) \leq \hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i_2))
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ige-u]{\mathrm{ige\_u}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:id28}}\label{\detokenize{exec/numerics:op-ige-u}}\begin{itemize}
\item {} 
Return \(1\) if \(i_1\) is greater than or equal to \(i_2\), \(0\) otherwise.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ige-u]{\mathrm{ige\_u}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(i_1 \geq i_2)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ige-s]{\mathrm{ige\_s}}_N(i_1, i_2)\protect\)}
\label{\detokenize{exec/numerics:op-ige-s}}\label{\detokenize{exec/numerics:id29}}\begin{itemize}
\item {} 
Let \(j_1\) be the {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{signed interpretation}}}} of \(i_1\).

\item {} 
Let \(j_2\) be the {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{signed interpretation}}}} of \(i_2\).

\item {} 
Return \(1\) if \(j_1\) is greater than or equal to \(j_2\), \(0\) otherwise.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ige-s]{\mathrm{ige\_s}}_N(i_1, i_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(\hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i_1) \geq \hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N(i_2))
\end{array}\end{split}
\end{equation*}
\index{floating-point}\index{IEEE 754}\ignorespaces 

\subsection{Floating-Point Operations}
\label{\detokenize{exec/numerics:index-8}}\label{\detokenize{exec/numerics:float-ops}}\label{\detokenize{exec/numerics:floating-point-operations}}
Floating-point arithmetic follows the \sphinxhref{http://ieeexplore.ieee.org/document/4610935/}{IEEE 754-2008}%
\begin{footnote}[24]\sphinxAtStartFootnote
\sphinxnolinkurl{http://ieeexplore.ieee.org/document/4610935/}
%
\end{footnote} standard,
with the following qualifications:
\begin{itemize}
\item {} 
All operators use round-to-nearest ties-to-even, except where otherwise specified.
Non-default directed rounding attributes are not supported.

\item {} 
Following the recommendation that operators propagate {\hyperref[\detokenize{syntax/values:syntax-nan}]{\sphinxcrossref{\DUrole{std,std-ref}{NaN}}}} payloads from their operands is permitted but not required.

\item {} 
All operators use “non-stop” mode, and floating-point exceptions are not otherwise observable.
In particular, neither alternate floating-point exception handling attributes nor operators on status flags are supported.
There is no observable difference between quiet and signalling NaNs.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
Some of these limitations may be lifted in future versions of WebAssembly.
\end{sphinxadmonition}

\index{rounding}\ignorespaces 

\subsubsection{Rounding}
\label{\detokenize{exec/numerics:rounding}}\label{\detokenize{exec/numerics:aux-ieee}}\label{\detokenize{exec/numerics:index-9}}
Rounding always is round-to-nearest ties-to-even, in correspondance with \sphinxhref{http://ieeexplore.ieee.org/document/4610935/}{IEEE 754-2008}%
\begin{footnote}[25]\sphinxAtStartFootnote
\sphinxnolinkurl{http://ieeexplore.ieee.org/document/4610935/}
%
\end{footnote} (Section 4.3.1).

An \sphinxstyleemphasis{exact} floating-point number is a rational number that is exactly representable as a {\hyperref[\detokenize{syntax/values:syntax-float}]{\sphinxcrossref{\DUrole{std,std-ref}{floating-point number}}}} of given bit width \(N\).

A \sphinxstyleemphasis{limit} number for a given floating-point bit width \(N\) is a positive or negative number whose magnitude is the smallest power of \(2\) that is not exactly representable as a floating-point number of width \(N\) (that magnitude is \(2^{128}\) for \(N = 32\) and \(2^{1024}\) for \(N = 64\)).

A \sphinxstyleemphasis{candidate} number is either an exact floating-point number or a positive or negative limit number for the given bit width \(N\).

A \sphinxstyleemphasis{candidate pair} is a pair \(z_1,z_2\) of candidate numbers, such that no candidate number exists that lies between the two.

A real number \(r\) is converted to a floating-point value of bit width \(N\) as follows:
\begin{itemize}
\item {} 
If \(r\) is \(0\), then return \(+0\).

\item {} 
Else if \(r\) is an exact floating-point number, then return \(r\).

\item {} 
Else if \(r\) greater than or equal to the positive limit, then return \(+\infty\).

\item {} 
Else if \(r\) is less than or equal to the negative limit, then return \(-\infty\).

\item {} 
Else if \(z_1\) and \(z_2\) are a candidate pair such that \(z_1 < r < z_2\), then:
\begin{itemize}
\item {} 
If \(|r - z_1| < |r - z_2|\), then let \(z\) be \(z_1\).

\item {} 
Else if \(|r - z_1| > |r - z_2|\), then let \(z\) be \(z_2\).

\item {} 
Else if \(|r - z_1| = |r - z_2|\) and the {\hyperref[\detokenize{syntax/values:syntax-float}]{\sphinxcrossref{\DUrole{std,std-ref}{significand}}}} of \(z_1\) is even, then let \(z\) be \(z_1\).

\item {} 
Else, let \(z\) be \(z_2\).

\end{itemize}

\item {} 
If \(z\) is \(0\), then:
\begin{itemize}
\item {} 
If \(r < 0\), then return \(-0\).

\item {} 
Else, return \(+0\).

\end{itemize}

\item {} 
Else if \(z\) is a limit number, then:
\begin{itemize}
\item {} 
If \(r < 0\), then return \(-\infty\).

\item {} 
Else, return \(+\infty\).

\end{itemize}

\item {} 
Else, return \(z\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(0) &=& +0 \\
\hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(r) &=& r & (\mathrel{\mbox{if}} r \in \mathrm{exact}_N) \\
\hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(r) &=& +\infty & (\mathrel{\mbox{if}} r \geq +\mathrm{limit}_N) \\
\hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(r) &=& -\infty & (\mathrel{\mbox{if}} r \leq -\mathrm{limit}_N) \\
\hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(r) &=& \mathrm{closest}_N(r, z_1, z_2) & (\mathrel{\mbox{if}} z_1 < r < z_2 \wedge (z_1,z_2) \in \mathrm{candidatepair}_N) \\[1ex]
\mathrm{closest}_N(r, z_1, z_2) &=& \mathrm{rectify}_N(r, z_1) & (\mathrel{\mbox{if}} |r-z_1|<|r-z_2|) \\
\mathrm{closest}_N(r, z_1, z_2) &=& \mathrm{rectify}_N(r, z_2) & (\mathrel{\mbox{if}} |r-z_1|>|r-z_2|) \\
\mathrm{closest}_N(r, z_1, z_2) &=& \mathrm{rectify}_N(r, z_1) & (\mathrel{\mbox{if}} |r-z_1|=|r-z_2| \wedge \mathrm{even}_N(z_1)) \\
\mathrm{closest}_N(r, z_1, z_2) &=& \mathrm{rectify}_N(r, z_2) & (\mathrel{\mbox{if}} |r-z_1|=|r-z_2| \wedge \mathrm{even}_N(z_2)) \\[1ex]
\mathrm{rectify}_N(r, \pm \mathrm{limit}_N) &=& \pm \infty \\
\mathrm{rectify}_N(r, 0) &=& +0 \qquad (r \geq 0) \\
\mathrm{rectify}_N(r, 0) &=& -0 \qquad (r < 0) \\
\mathrm{rectify}_N(r, z) &=& z \\
\end{array}\end{split}
\end{equation*}
where:
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\mathrm{exact}_N &=& \hyperref[syntax/values:syntax-float]{\def\mathdef1618#1{{\mathit{f}#1}}\mathdef1618{N}} \cap \mathbb{Q} \\
\mathrm{limit}_N &=& 2^{2^{\hyperref[syntax/values:aux-exponent]{\mathrm{expon}}(N)-1}} \\
\mathrm{candidate}_N &=& \mathrm{exact}_N \cup \{+\mathrm{limit}_N, -\mathrm{limit}_N\} \\
\mathrm{candidatepair}_N &=& \{ (z_1, z_2) \in \mathrm{candidate}_N^2 ~|~ z_1 < z_2 \wedge \forall z \in \mathrm{candidate}_N, z \leq z_1 \vee z \geq z_2\} \\[1ex]
\mathrm{even}_N((d + m\cdot 2^{-M}) \cdot 2^e) &\Leftrightarrow& m \mathbin{\mathrm{mod}} 2 = 0 \\
\mathrm{even}_N(\pm \mathrm{limit}_N) &\Leftrightarrow& \mathrm{true} \\
\end{array}\end{split}
\end{equation*}
\index{NaN}\ignorespaces 

\subsubsection{NaN Propagation}
\label{\detokenize{exec/numerics:index-10}}\label{\detokenize{exec/numerics:nan-propagation}}\label{\detokenize{exec/numerics:aux-nans}}
When the result of a floating-point operator other than \(\hyperref[exec/numerics:op-fneg]{\mathrm{fneg}}\), \(\hyperref[exec/numerics:op-fabs]{\mathrm{fabs}}\), or \(\hyperref[exec/numerics:op-fcopysign]{\mathrm{fcopysign}}\) is a {\hyperref[\detokenize{syntax/values:syntax-nan}]{\sphinxcrossref{\DUrole{std,std-ref}{NaN}}}},
then its sign is non-deterministic and the {\hyperref[\detokenize{syntax/values:syntax-payload}]{\sphinxcrossref{\DUrole{std,std-ref}{payload}}}} is computed as follows:
\begin{itemize}
\item {} 
If the payload of all NaN inputs to the operator is {\hyperref[\detokenize{syntax/values:canonical-nan}]{\sphinxcrossref{\DUrole{std,std-ref}{canonical}}}} (including the case that there are no NaN inputs), then the payload of the output is canonical as well.

\item {} 
Otherwise the payload is picked non-determinsitically among all {\hyperref[\detokenize{syntax/values:arithmetic-nan}]{\sphinxcrossref{\DUrole{std,std-ref}{arithmetic NaNs}}}}; that is, its most significant bit is \(1\) and all others are unspecified.

\end{itemize}

This non-deterministic result is expressed by the following auxiliary function producing a set of allowed outputs from a set of inputs:
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z^\ast\} &=& \{ + \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), - \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n) ~|~ n = \hyperref[syntax/values:aux-canon]{\mathrm{canon}}_N \}
  & (\mathrel{\mbox{if}} \forall \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n) \in z^\ast,~ n = \hyperref[syntax/values:aux-canon]{\mathrm{canon}}_N) \\
\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z^\ast\} &=& \{ + \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), - \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n) ~|~ n \geq \hyperref[syntax/values:aux-canon]{\mathrm{canon}}_N \}
  & (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fadd]{\mathrm{fadd}}_N(z_1, z_2)\protect\)}
\label{\detokenize{exec/numerics:id30}}\label{\detokenize{exec/numerics:op-fadd}}\begin{itemize}
\item {} 
If either \(z_1\) or \(z_2\) is a NaN, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z_1, z_2\}\).

\item {} 
Else if both \(z_1\) and \(z_2\) are infinities of opposite signs, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z_1, z_2\}\).

\item {} 
Else if both \(z_1\) and \(z_2\) are infinities of equal sign, then return that infinity.

\item {} 
Else if one of \(z_1\) or \(z_2\) is an infinity, then return that infinity.

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes of opposite sign, then return positive zero.

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes of equal sign, then return that zero.

\item {} 
Else if one of \(z_1\) or \(z_2\) is a zero, then return the other operand.

\item {} 
Else if both \(z_1\) and \(z_2\) are values with the same magnitude but opposite signs, then return positive zero.

\item {} 
Else return the result of adding \(z_1\) and \(z_2\), {\hyperref[\detokenize{exec/numerics:aux-ieee}]{\sphinxcrossref{\DUrole{std,std-ref}{rounded}}}} to the nearest representable value.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fadd]{\mathrm{fadd}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2\} \\
\hyperref[exec/numerics:op-fadd]{\mathrm{fadd}}_N(z_1, \pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_1\} \\
\hyperref[exec/numerics:op-fadd]{\mathrm{fadd}}_N(\pm \infty, \mp \infty) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\} \\
\hyperref[exec/numerics:op-fadd]{\mathrm{fadd}}_N(\pm \infty, \pm \infty) &=& \pm \infty \\
\hyperref[exec/numerics:op-fadd]{\mathrm{fadd}}_N(z_1, \pm \infty) &=& \pm \infty \\
\hyperref[exec/numerics:op-fadd]{\mathrm{fadd}}_N(\pm \infty, z_2) &=& \pm \infty \\
\hyperref[exec/numerics:op-fadd]{\mathrm{fadd}}_N(\pm 0, \mp 0) &=& +0 \\
\hyperref[exec/numerics:op-fadd]{\mathrm{fadd}}_N(\pm 0, \pm 0) &=& \pm 0 \\
\hyperref[exec/numerics:op-fadd]{\mathrm{fadd}}_N(z_1, \pm 0) &=& z_1 \\
\hyperref[exec/numerics:op-fadd]{\mathrm{fadd}}_N(\pm 0, z_2) &=& z_2 \\
\hyperref[exec/numerics:op-fadd]{\mathrm{fadd}}_N(\pm q, \mp q) &=& +0 \\
\hyperref[exec/numerics:op-fadd]{\mathrm{fadd}}_N(z_1, z_2) &=& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(z_1 + z_2) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fsub]{\mathrm{fsub}}_N(z_1, z_2)\protect\)}
\label{\detokenize{exec/numerics:op-fsub}}\label{\detokenize{exec/numerics:id31}}\begin{itemize}
\item {} 
If either \(z_1\) or \(z_2\) is a NaN, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z_1, z_2\}\).

\item {} 
Else if both \(z_1\) and \(z_2\) are infinities of equal signs, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z_1, z_2\}\).

\item {} 
Else if both \(z_1\) and \(z_2\) are infinities of opposite sign, then return \(z_1\).

\item {} 
Else if \(z_1\) is an infinity, then return that infinity.

\item {} 
Else if \(z_2\) is an infinity, then return that infinity negated.

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes of equal sign, then return positive zero.

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes of opposite sign, then return \(z_1\).

\item {} 
Else if \(z_2\) is a zero, then return \(z_1\).

\item {} 
Else if \(z_1\) is a zero, then return \(z_2\) negated.

\item {} 
Else if both \(z_1\) and \(z_2\) are the same value, then return positive zero.

\item {} 
Else return the result of subtracting \(z_2\) from \(z_1\), {\hyperref[\detokenize{exec/numerics:aux-ieee}]{\sphinxcrossref{\DUrole{std,std-ref}{rounded}}}} to the nearest representable value.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fsub]{\mathrm{fsub}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2\} \\
\hyperref[exec/numerics:op-fsub]{\mathrm{fsub}}_N(z_1, \pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_1\} \\
\hyperref[exec/numerics:op-fsub]{\mathrm{fsub}}_N(\pm \infty, \pm \infty) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\} \\
\hyperref[exec/numerics:op-fsub]{\mathrm{fsub}}_N(\pm \infty, \mp \infty) &=& \pm \infty \\
\hyperref[exec/numerics:op-fsub]{\mathrm{fsub}}_N(z_1, \pm \infty) &=& \mp \infty \\
\hyperref[exec/numerics:op-fsub]{\mathrm{fsub}}_N(\pm \infty, z_2) &=& \pm \infty \\
\hyperref[exec/numerics:op-fsub]{\mathrm{fsub}}_N(\pm 0, \pm 0) &=& +0 \\
\hyperref[exec/numerics:op-fsub]{\mathrm{fsub}}_N(\pm 0, \mp 0) &=& \pm 0 \\
\hyperref[exec/numerics:op-fsub]{\mathrm{fsub}}_N(z_1, \pm 0) &=& z_1 \\
\hyperref[exec/numerics:op-fsub]{\mathrm{fsub}}_N(\pm 0, \pm q_2) &=& \mp q_2 \\
\hyperref[exec/numerics:op-fsub]{\mathrm{fsub}}_N(\pm q, \pm q) &=& +0 \\
\hyperref[exec/numerics:op-fsub]{\mathrm{fsub}}_N(z_1, z_2) &=& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(z_1 - z_2) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
Up to the non-determinism regarding NaNs, it always holds that \(\hyperref[exec/numerics:op-fsub]{\mathrm{fsub}}_N(z_1, z_2) = \hyperref[exec/numerics:op-fadd]{\mathrm{fadd}}_N(z_1, \hyperref[exec/numerics:op-fneg]{\mathrm{fneg}}_N(z_2))\).
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(z_1, z_2)\protect\)}
\label{\detokenize{exec/numerics:op-fmul}}\label{\detokenize{exec/numerics:id32}}\begin{itemize}
\item {} 
If either \(z_1\) or \(z_2\) is a NaN, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z_1, z_2\}\).

\item {} 
Else if one of \(z_1\) and \(z_2\) is a zero and the other an infinity, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z_1, z_2\}\).

\item {} 
Else if both \(z_1\) and \(z_2\) are infinities of equal sign, then return positive infinity.

\item {} 
Else if both \(z_1\) and \(z_2\) are infinities of opposite sign, then return negative infinity.

\item {} 
Else if one of \(z_1\) or \(z_2\) is an infinity and the other a value with equal sign, then return positive infinity.

\item {} 
Else if one of \(z_1\) or \(z_2\) is an infinity and the other a value with opposite sign, then return negative infinity.

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes of equal sign, then return positive zero.

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes of opposite sign, then return negative zero.

\item {} 
Else return the result of multiplying \(z_1\) and \(z_2\), {\hyperref[\detokenize{exec/numerics:aux-ieee}]{\sphinxcrossref{\DUrole{std,std-ref}{rounded}}}} to the nearest representable value.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2\} \\
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(z_1, \pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_1\} \\
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(\pm \infty, \pm 0) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\} \\
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(\pm \infty, \mp 0) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\} \\
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(\pm 0, \pm \infty) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\} \\
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(\pm 0, \mp \infty) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\} \\
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(\pm \infty, \pm \infty) &=& +\infty \\
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(\pm \infty, \mp \infty) &=& -\infty \\
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(\pm q_1, \pm \infty) &=& +\infty \\
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(\pm q_1, \mp \infty) &=& -\infty \\
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(\pm \infty, \pm q_2) &=& +\infty \\
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(\pm \infty, \mp q_2) &=& -\infty \\
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(\pm 0, \pm 0) &=& + 0 \\
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(\pm 0, \mp 0) &=& - 0 \\
\hyperref[exec/numerics:op-fmul]{\mathrm{fmul}}_N(z_1, z_2) &=& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(z_1 \cdot z_2) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(z_1, z_2)\protect\)}
\label{\detokenize{exec/numerics:id33}}\label{\detokenize{exec/numerics:op-fdiv}}\begin{itemize}
\item {} 
If either \(z_1\) or \(z_2\) is a NaN, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z_1, z_2\}\).

\item {} 
Else if both \(z_1\) and \(z_2\) are infinities, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z_1, z_2\}\).

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z_1, z_2\}\).

\item {} 
Else if \(z_1\) is an infinity and \(z_2\) a value with equal sign, then return positive infinity.

\item {} 
Else if \(z_1\) is an infinity and \(z_2\) a value with opposite sign, then return negative infinity.

\item {} 
Else if \(z_2\) is an infinity and \(z_1\) a value with equal sign, then return positive zero.

\item {} 
Else if \(z_2\) is an infinity and \(z_1\) a value with opposite sign, then return negative zero.

\item {} 
Else if \(z_1\) is a zero and \(z_2\) a value with equal sign, then return positive zero.

\item {} 
Else if \(z_1\) is a zero and \(z_2\) a value with opposite sign, then return negative zero.

\item {} 
Else if \(z_2\) is a zero and \(z_1\) a value with equal sign, then return positive infinity.

\item {} 
Else if \(z_2\) is a zero and \(z_1\) a value with opposite sign, then return negative infinity.

\item {} 
Else return the result of dividing \(z_1\) by \(z_2\), {\hyperref[\detokenize{exec/numerics:aux-ieee}]{\sphinxcrossref{\DUrole{std,std-ref}{rounded}}}} to the nearest representable value.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2\} \\
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(z_1, \pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_1\} \\
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(\pm \infty, \pm \infty) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\} \\
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(\pm \infty, \mp \infty) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\} \\
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(\pm 0, \pm 0) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\} \\
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(\pm 0, \mp 0) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\} \\
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(\pm \infty, \pm q_2) &=& +\infty \\
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(\pm \infty, \mp q_2) &=& -\infty \\
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(\pm q_1, \pm \infty) &=& +0 \\
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(\pm q_1, \mp \infty) &=& -0 \\
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(\pm 0, \pm q_2) &=& +0 \\
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(\pm 0, \mp q_2) &=& -0 \\
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(\pm q_1, \pm 0) &=& +\infty \\
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(\pm q_1, \mp 0) &=& -\infty \\
\hyperref[exec/numerics:op-fdiv]{\mathrm{fdiv}}_N(z_1, z_2) &=& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(z_1 / z_2) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fmin]{\mathrm{fmin}}_N(z_1, z_2)\protect\)}
\label{\detokenize{exec/numerics:id34}}\label{\detokenize{exec/numerics:op-fmin}}\begin{itemize}
\item {} 
If either \(z_1\) or \(z_2\) is a NaN, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z_1, z_2\}\).

\item {} 
Else if one of \(z_1\) or \(z_2\) is a negative infinity, then return negative infinity.

\item {} 
Else if one of \(z_1\) or \(z_2\) is a positive infinity, then return the other value.

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes of opposite signs, then return negative zero.

\item {} 
Else return the smaller value of \(z_1\) and \(z_2\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fmin]{\mathrm{fmin}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2\} \\
\hyperref[exec/numerics:op-fmin]{\mathrm{fmin}}_N(z_1, \pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_1\} \\
\hyperref[exec/numerics:op-fmin]{\mathrm{fmin}}_N(+ \infty, z_2) &=& z_2 \\
\hyperref[exec/numerics:op-fmin]{\mathrm{fmin}}_N(- \infty, z_2) &=& - \infty \\
\hyperref[exec/numerics:op-fmin]{\mathrm{fmin}}_N(z_1, + \infty) &=& z_1 \\
\hyperref[exec/numerics:op-fmin]{\mathrm{fmin}}_N(z_1, - \infty) &=& - \infty \\
\hyperref[exec/numerics:op-fmin]{\mathrm{fmin}}_N(\pm 0, \mp 0) &=& -0 \\
\hyperref[exec/numerics:op-fmin]{\mathrm{fmin}}_N(z_1, z_2) &=& z_1 & (\mathrel{\mbox{if}} z_1 \leq z_2) \\
\hyperref[exec/numerics:op-fmin]{\mathrm{fmin}}_N(z_1, z_2) &=& z_2 & (\mathrel{\mbox{if}} z_2 \leq z_1) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fmax]{\mathrm{fmax}}_N(z_1, z_2)\protect\)}
\label{\detokenize{exec/numerics:id35}}\label{\detokenize{exec/numerics:op-fmax}}\begin{itemize}
\item {} 
If either \(z_1\) or \(z_2\) is a NaN, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z_1, z_2\}\).

\item {} 
Else if one of \(z_1\) or \(z_2\) is a positive infinity, then return positive infinity.

\item {} 
Else if one of \(z_1\) or \(z_2\) is a negative infinity, then return the other value.

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes of opposite signs, then return positive zero.

\item {} 
Else return the larger value of \(z_1\) and \(z_2\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fmax]{\mathrm{fmax}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2\} \\
\hyperref[exec/numerics:op-fmax]{\mathrm{fmax}}_N(z_1, \pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_1\} \\
\hyperref[exec/numerics:op-fmax]{\mathrm{fmax}}_N(+ \infty, z_2) &=& + \infty \\
\hyperref[exec/numerics:op-fmax]{\mathrm{fmax}}_N(- \infty, z_2) &=& z_2 \\
\hyperref[exec/numerics:op-fmax]{\mathrm{fmax}}_N(z_1, + \infty) &=& + \infty \\
\hyperref[exec/numerics:op-fmax]{\mathrm{fmax}}_N(z_1, - \infty) &=& z_1 \\
\hyperref[exec/numerics:op-fmax]{\mathrm{fmax}}_N(\pm 0, \mp 0) &=& +0 \\
\hyperref[exec/numerics:op-fmax]{\mathrm{fmax}}_N(z_1, z_2) &=& z_1 & (\mathrel{\mbox{if}} z_1 \geq z_2) \\
\hyperref[exec/numerics:op-fmax]{\mathrm{fmax}}_N(z_1, z_2) &=& z_2 & (\mathrel{\mbox{if}} z_2 \geq z_1) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fcopysign]{\mathrm{fcopysign}}_N(z_1, z_2)\protect\)}
\label{\detokenize{exec/numerics:op-fcopysign}}\label{\detokenize{exec/numerics:id36}}\begin{itemize}
\item {} 
If \(z_1\) and \(z_2\) have the same sign, then return \(z_1\).

\item {} 
Else return \(z_1\) with negated sign.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fcopysign]{\mathrm{fcopysign}}_N(\pm p_1, \pm p_2) &=& \pm p_1 \\
\hyperref[exec/numerics:op-fcopysign]{\mathrm{fcopysign}}_N(\pm p_1, \mp p_2) &=& \mp p_1 \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fabs]{\mathrm{fabs}}_N(z)\protect\)}
\label{\detokenize{exec/numerics:id37}}\label{\detokenize{exec/numerics:op-fabs}}\begin{itemize}
\item {} 
If \(z\) is a NaN, then return \(z\) with positive sign.

\item {} 
Else if \(z\) is an infinity, then return positive infinity.

\item {} 
Else if \(z\) is a zero, then return positive zero.

\item {} 
Else if \(z\) is a positive value, then \(z\).

\item {} 
Else return \(z\) negated.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fabs]{\mathrm{fabs}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& +\hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n) \\
\hyperref[exec/numerics:op-fabs]{\mathrm{fabs}}_N(\pm \infty) &=& +\infty \\
\hyperref[exec/numerics:op-fabs]{\mathrm{fabs}}_N(\pm 0) &=& +0 \\
\hyperref[exec/numerics:op-fabs]{\mathrm{fabs}}_N(\pm q) &=& +q \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fneg]{\mathrm{fneg}}_N(z)\protect\)}
\label{\detokenize{exec/numerics:id38}}\label{\detokenize{exec/numerics:op-fneg}}\begin{itemize}
\item {} 
If \(z\) is a NaN, then return \(z\) with negated sign.

\item {} 
Else if \(z\) is an infinity, then return that infinity negated.

\item {} 
Else if \(z\) is a zero, then return that zero negated.

\item {} 
Else return \(z\) negated.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fneg]{\mathrm{fneg}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \mp \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n) \\
\hyperref[exec/numerics:op-fneg]{\mathrm{fneg}}_N(\pm \infty) &=& \mp \infty \\
\hyperref[exec/numerics:op-fneg]{\mathrm{fneg}}_N(\pm 0) &=& \mp 0 \\
\hyperref[exec/numerics:op-fneg]{\mathrm{fneg}}_N(\pm q) &=& \mp q \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fsqrt]{\mathrm{fsqrt}}_N(z)\protect\)}
\label{\detokenize{exec/numerics:op-fsqrt}}\label{\detokenize{exec/numerics:id39}}\begin{itemize}
\item {} 
If \(z\) is a NaN, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z\}\).

\item {} 
Else if \(z\) has a negative sign, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z\}\).

\item {} 
Else if \(z\) is positive infinity, then return positive infinity.

\item {} 
Else if \(z\) is a zero, then return that zero.

\item {} 
Else return the square root of \(z\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fsqrt]{\mathrm{fsqrt}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)\} \\
\hyperref[exec/numerics:op-fsqrt]{\mathrm{fsqrt}}_N(- \infty) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\} \\
\hyperref[exec/numerics:op-fsqrt]{\mathrm{fsqrt}}_N(+ \infty) &=& + \infty \\
\hyperref[exec/numerics:op-fsqrt]{\mathrm{fsqrt}}_N(\pm 0) &=& \pm 0 \\
\hyperref[exec/numerics:op-fsqrt]{\mathrm{fsqrt}}_N(- q) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\} \\
\hyperref[exec/numerics:op-fsqrt]{\mathrm{fsqrt}}_N(+ q) &=& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N\left(\sqrt{q}\right) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fceil]{\mathrm{fceil}}_N(z)\protect\)}
\label{\detokenize{exec/numerics:op-fceil}}\label{\detokenize{exec/numerics:id40}}\begin{itemize}
\item {} 
If \(z\) is a NaN, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z\}\).

\item {} 
Else if \(z\) is an infinity, then return \(z\).

\item {} 
Else if \(z\) is a zero, then return \(z\).

\item {} 
Else if \(z\) is smaller than \(0\) but greater than \(-1\), then return negative zero.

\item {} 
Else return the smallest integral value that is not smaller than \(z\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fceil]{\mathrm{fceil}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)\} \\
\hyperref[exec/numerics:op-fceil]{\mathrm{fceil}}_N(\pm \infty) &=& \pm \infty \\
\hyperref[exec/numerics:op-fceil]{\mathrm{fceil}}_N(\pm 0) &=& \pm 0 \\
\hyperref[exec/numerics:op-fceil]{\mathrm{fceil}}_N(- q) &=& -0 & (\mathrel{\mbox{if}} -1 < -q < 0) \\
\hyperref[exec/numerics:op-fceil]{\mathrm{fceil}}_N(\pm q) &=& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(i) & (\mathrel{\mbox{if}} \pm q \leq i < \pm q + 1) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ffloor]{\mathrm{ffloor}}_N(z)\protect\)}
\label{\detokenize{exec/numerics:id41}}\label{\detokenize{exec/numerics:op-ffloor}}\begin{itemize}
\item {} 
If \(z\) is a NaN, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z\}\).

\item {} 
Else if \(z\) is an infinity, then return \(z\).

\item {} 
Else if \(z\) is a zero, then return \(z\).

\item {} 
Else if \(z\) is greater than \(0\) but smaller than \(1\), then return positive zero.

\item {} 
Else return the largest integral value that is not larger than \(z\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ffloor]{\mathrm{ffloor}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)\} \\
\hyperref[exec/numerics:op-ffloor]{\mathrm{ffloor}}_N(\pm \infty) &=& \pm \infty \\
\hyperref[exec/numerics:op-ffloor]{\mathrm{ffloor}}_N(\pm 0) &=& \pm 0 \\
\hyperref[exec/numerics:op-ffloor]{\mathrm{ffloor}}_N(+ q) &=& +0 & (\mathrel{\mbox{if}} 0 < +q < 1) \\
\hyperref[exec/numerics:op-ffloor]{\mathrm{ffloor}}_N(\pm q) &=& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(i) & (\mathrel{\mbox{if}} \pm q - 1 < i \leq \pm q) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-ftrunc]{\mathrm{ftrunc}}_N(z)\protect\)}
\label{\detokenize{exec/numerics:id42}}\label{\detokenize{exec/numerics:op-ftrunc}}\begin{itemize}
\item {} 
If \(z\) is a NaN, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z\}\).

\item {} 
Else if \(z\) is an infinity, then return \(z\).

\item {} 
Else if \(z\) is a zero, then return \(z\).

\item {} 
Else if \(z\) is greater than \(0\) but smaller than \(1\), then return positive zero.

\item {} 
Else if \(z\) is smaller than \(0\) but greater than \(-1\), then return negative zero.

\item {} 
Else return the integral value with the same sign as \(z\) and the largest magnitude that is not larger than the magnitude of \(z\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-ftrunc]{\mathrm{ftrunc}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)\} \\
\hyperref[exec/numerics:op-ftrunc]{\mathrm{ftrunc}}_N(\pm \infty) &=& \pm \infty \\
\hyperref[exec/numerics:op-ftrunc]{\mathrm{ftrunc}}_N(\pm 0) &=& \pm 0 \\
\hyperref[exec/numerics:op-ftrunc]{\mathrm{ftrunc}}_N(+ q) &=& +0 & (\mathrel{\mbox{if}} 0 < +q < 1) \\
\hyperref[exec/numerics:op-ftrunc]{\mathrm{ftrunc}}_N(- q) &=& -0 & (\mathrel{\mbox{if}} -1 < -q < 0) \\
\hyperref[exec/numerics:op-ftrunc]{\mathrm{ftrunc}}_N(\pm q) &=& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(\pm i) & (\mathrel{\mbox{if}} +q - 1 < i \leq +q) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fnearest]{\mathrm{fnearest}}_N(z)\protect\)}
\label{\detokenize{exec/numerics:id43}}\label{\detokenize{exec/numerics:op-fnearest}}\begin{itemize}
\item {} 
If \(z\) is a NaN, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{z\}\).

\item {} 
Else if \(z\) is an infinity, then return \(z\).

\item {} 
Else if \(z\) is a zero, then return \(z\).

\item {} 
Else if \(z\) is greater than \(0\) but smaller than or equal to \(0.5\), then return positive zero.

\item {} 
Else if \(z\) is smaller than \(0\) but greater than or equal to \(-0.5\), then return negative zero.

\item {} 
Else return the integral value that is nearest to \(z\); if two values are equally near, return the even one.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fnearest]{\mathrm{fnearest}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)\} \\
\hyperref[exec/numerics:op-fnearest]{\mathrm{fnearest}}_N(\pm \infty) &=& \pm \infty \\
\hyperref[exec/numerics:op-fnearest]{\mathrm{fnearest}}_N(\pm 0) &=& \pm 0 \\
\hyperref[exec/numerics:op-fnearest]{\mathrm{fnearest}}_N(+ q) &=& +0 & (\mathrel{\mbox{if}} 0 < +q \leq 0.5) \\
\hyperref[exec/numerics:op-fnearest]{\mathrm{fnearest}}_N(- q) &=& -0 & (\mathrel{\mbox{if}} -0.5 \leq -q < 0) \\
\hyperref[exec/numerics:op-fnearest]{\mathrm{fnearest}}_N(\pm q) &=& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(\pm i) & (\mathrel{\mbox{if}} |i - q| < 0.5) \\
\hyperref[exec/numerics:op-fnearest]{\mathrm{fnearest}}_N(\pm q) &=& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(\pm i) & (\mathrel{\mbox{if}} |i - q| = 0.5 \wedge i~\mbox{even}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-feq]{\mathrm{feq}}_N(z_1, z_2)\protect\)}
\label{\detokenize{exec/numerics:id44}}\label{\detokenize{exec/numerics:op-feq}}\begin{itemize}
\item {} 
If either \(z_1\) or \(z_2\) is a NaN, then return \(0\).

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes, then return \(1\).

\item {} 
Else if both \(z_1\) and \(z_2\) are the same value, then return \(1\).

\item {} 
Else return \(0\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-feq]{\mathrm{feq}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2) &=& 0 \\
\hyperref[exec/numerics:op-feq]{\mathrm{feq}}_N(z_1, \pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& 0 \\
\hyperref[exec/numerics:op-feq]{\mathrm{feq}}_N(\pm 0, \mp 0) &=& 1 \\
\hyperref[exec/numerics:op-feq]{\mathrm{feq}}_N(z_1, z_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(z_1 = z_2) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fne]{\mathrm{fne}}_N(z_1, z_2)\protect\)}
\label{\detokenize{exec/numerics:id45}}\label{\detokenize{exec/numerics:op-fne}}\begin{itemize}
\item {} 
If either \(z_1\) or \(z_2\) is a NaN, then return \(1\).

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes, then return \(0\).

\item {} 
Else if both \(z_1\) and \(z_2\) are the same value, then return \(0\).

\item {} 
Else return \(1\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fne]{\mathrm{fne}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2) &=& 1 \\
\hyperref[exec/numerics:op-fne]{\mathrm{fne}}_N(z_1, \pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& 1 \\
\hyperref[exec/numerics:op-fne]{\mathrm{fne}}_N(\pm 0, \mp 0) &=& 0 \\
\hyperref[exec/numerics:op-fne]{\mathrm{fne}}_N(z_1, z_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(z_1 \neq z_2) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-flt]{\mathrm{flt}}_N(z_1, z_2)\protect\)}
\label{\detokenize{exec/numerics:op-flt}}\label{\detokenize{exec/numerics:id46}}\begin{itemize}
\item {} 
If either \(z_1\) or \(z_2\) is a NaN, then return \(0\).

\item {} 
Else if \(z_1\) and \(z_2\) are the same value, then return \(0\).

\item {} 
Else if \(z_1\) is positive infinity, then return \(0\).

\item {} 
Else if \(z_1\) is negative infinity, then return \(1\).

\item {} 
Else if \(z_2\) is positive infinity, then return \(1\).

\item {} 
Else if \(z_2\) is negative infinity, then return \(0\).

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes, then return \(0\).

\item {} 
Else if \(z_1\) is smaller than \(z_2\), then return \(1\).

\item {} 
Else return \(0\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-flt]{\mathrm{flt}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2) &=& 0 \\
\hyperref[exec/numerics:op-flt]{\mathrm{flt}}_N(z_1, \pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& 0 \\
\hyperref[exec/numerics:op-flt]{\mathrm{flt}}_N(z, z) &=& 0 \\
\hyperref[exec/numerics:op-flt]{\mathrm{flt}}_N(+ \infty, z_2) &=& 0 \\
\hyperref[exec/numerics:op-flt]{\mathrm{flt}}_N(- \infty, z_2) &=& 1 \\
\hyperref[exec/numerics:op-flt]{\mathrm{flt}}_N(z_1, + \infty) &=& 1 \\
\hyperref[exec/numerics:op-flt]{\mathrm{flt}}_N(z_1, - \infty) &=& 0 \\
\hyperref[exec/numerics:op-flt]{\mathrm{flt}}_N(\pm 0, \mp 0) &=& 0 \\
\hyperref[exec/numerics:op-flt]{\mathrm{flt}}_N(z_1, z_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(z_1 < z_2) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fgt]{\mathrm{fgt}}_N(z_1, z_2)\protect\)}
\label{\detokenize{exec/numerics:id47}}\label{\detokenize{exec/numerics:op-fgt}}\begin{itemize}
\item {} 
If either \(z_1\) or \(z_2\) is a NaN, then return \(0\).

\item {} 
Else if \(z_1\) and \(z_2\) are the same value, then return \(0\).

\item {} 
Else if \(z_1\) is positive infinity, then return \(1\).

\item {} 
Else if \(z_1\) is negative infinity, then return \(0\).

\item {} 
Else if \(z_2\) is positive infinity, then return \(0\).

\item {} 
Else if \(z_2\) is negative infinity, then return \(1\).

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes, then return \(0\).

\item {} 
Else if \(z_1\) is larger than \(z_2\), then return \(1\).

\item {} 
Else return \(0\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fgt]{\mathrm{fgt}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2) &=& 0 \\
\hyperref[exec/numerics:op-fgt]{\mathrm{fgt}}_N(z_1, \pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& 0 \\
\hyperref[exec/numerics:op-fgt]{\mathrm{fgt}}_N(z, z) &=& 0 \\
\hyperref[exec/numerics:op-fgt]{\mathrm{fgt}}_N(+ \infty, z_2) &=& 1 \\
\hyperref[exec/numerics:op-fgt]{\mathrm{fgt}}_N(- \infty, z_2) &=& 0 \\
\hyperref[exec/numerics:op-fgt]{\mathrm{fgt}}_N(z_1, + \infty) &=& 0 \\
\hyperref[exec/numerics:op-fgt]{\mathrm{fgt}}_N(z_1, - \infty) &=& 1 \\
\hyperref[exec/numerics:op-fgt]{\mathrm{fgt}}_N(\pm 0, \mp 0) &=& 0 \\
\hyperref[exec/numerics:op-fgt]{\mathrm{fgt}}_N(z_1, z_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(z_1 > z_2) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fle]{\mathrm{fle}}_N(z_1, z_2)\protect\)}
\label{\detokenize{exec/numerics:id48}}\label{\detokenize{exec/numerics:op-fle}}\begin{itemize}
\item {} 
If either \(z_1\) or \(z_2\) is a NaN, then return \(0\).

\item {} 
Else if \(z_1\) and \(z_2\) are the same value, then return \(1\).

\item {} 
Else if \(z_1\) is positive infinity, then return \(0\).

\item {} 
Else if \(z_1\) is negative infinity, then return \(1\).

\item {} 
Else if \(z_2\) is positive infinity, then return \(1\).

\item {} 
Else if \(z_2\) is negative infinity, then return \(0\).

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes, then return \(1\).

\item {} 
Else if \(z_1\) is smaller than or equal to \(z_2\), then return \(1\).

\item {} 
Else return \(0\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fle]{\mathrm{fle}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2) &=& 0 \\
\hyperref[exec/numerics:op-fle]{\mathrm{fle}}_N(z_1, \pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& 0 \\
\hyperref[exec/numerics:op-fle]{\mathrm{fle}}_N(z, z) &=& 1 \\
\hyperref[exec/numerics:op-fle]{\mathrm{fle}}_N(+ \infty, z_2) &=& 0 \\
\hyperref[exec/numerics:op-fle]{\mathrm{fle}}_N(- \infty, z_2) &=& 1 \\
\hyperref[exec/numerics:op-fle]{\mathrm{fle}}_N(z_1, + \infty) &=& 1 \\
\hyperref[exec/numerics:op-fle]{\mathrm{fle}}_N(z_1, - \infty) &=& 0 \\
\hyperref[exec/numerics:op-fle]{\mathrm{fle}}_N(\pm 0, \mp 0) &=& 1 \\
\hyperref[exec/numerics:op-fle]{\mathrm{fle}}_N(z_1, z_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(z_1 \leq z_2) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-fge]{\mathrm{fge}}_N(z_1, z_2)\protect\)}
\label{\detokenize{exec/numerics:op-fge}}\label{\detokenize{exec/numerics:id49}}\begin{itemize}
\item {} 
If either \(z_1\) or \(z_2\) is a NaN, then return \(0\).

\item {} 
Else if \(z_1\) and \(z_2\) are the same value, then return \(1\).

\item {} 
Else if \(z_1\) is positive infinity, then return \(1\).

\item {} 
Else if \(z_1\) is negative infinity, then return \(0\).

\item {} 
Else if \(z_2\) is positive infinity, then return \(0\).

\item {} 
Else if \(z_2\) is negative infinity, then return \(1\).

\item {} 
Else if both \(z_1\) and \(z_2\) are zeroes, then return \(1\).

\item {} 
Else if \(z_1\) is smaller than or equal to \(z_2\), then return \(1\).

\item {} 
Else return \(0\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{@{}lcll}
\hyperref[exec/numerics:op-fge]{\mathrm{fge}}_N(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n), z_2) &=& 0 \\
\hyperref[exec/numerics:op-fge]{\mathrm{fge}}_N(z_1, \pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& 0 \\
\hyperref[exec/numerics:op-fge]{\mathrm{fge}}_N(z, z) &=& 1 \\
\hyperref[exec/numerics:op-fge]{\mathrm{fge}}_N(+ \infty, z_2) &=& 1 \\
\hyperref[exec/numerics:op-fge]{\mathrm{fge}}_N(- \infty, z_2) &=& 0 \\
\hyperref[exec/numerics:op-fge]{\mathrm{fge}}_N(z_1, + \infty) &=& 0 \\
\hyperref[exec/numerics:op-fge]{\mathrm{fge}}_N(z_1, - \infty) &=& 1 \\
\hyperref[exec/numerics:op-fge]{\mathrm{fge}}_N(\pm 0, \mp 0) &=& 1 \\
\hyperref[exec/numerics:op-fge]{\mathrm{fge}}_N(z_1, z_2) &=& \hyperref[exec/numerics:aux-bool]{\mathrm{bool}}(z_1 \geq z_2) \\
\end{array}\end{split}
\end{equation*}

\subsection{Conversions}
\label{\detokenize{exec/numerics:conversions}}\label{\detokenize{exec/numerics:convert-ops}}

\subsubsection{\protect\(\hyperref[exec/numerics:op-extend-u]{\mathrm{extend}^{\mathsf{u}}}_{M,N}(i)\protect\)}
\label{\detokenize{exec/numerics:op-extend-u}}\label{\detokenize{exec/numerics:id50}}\begin{itemize}
\item {} 
Return \(i\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:op-extend-u]{\mathrm{extend}^{\mathsf{u}}}_{M,N}(i) &=& i \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
In the abstract syntax, unsigned extension just reinterprets the same value.
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[exec/numerics:op-extend-s]{\mathrm{extend}^{\mathsf{s}}}_{M,N}(i)\protect\)}
\label{\detokenize{exec/numerics:op-extend-s}}\label{\detokenize{exec/numerics:id51}}\begin{itemize}
\item {} 
Let \(j\) be the {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{signed interpretation}}}} of \(i\) of size \(M\).

\item {} 
Return the two’s complement of \(j\) relative to size \(N\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:op-extend-s]{\mathrm{extend}^{\mathsf{s}}}_{M,N}(i) &=& \hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_N^{-1}(\hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_M(i)) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-wrap]{\mathrm{wrap}}_{M,N}(i)\protect\)}
\label{\detokenize{exec/numerics:id52}}\label{\detokenize{exec/numerics:op-wrap}}\begin{itemize}
\item {} 
Return \(i\) modulo \(2^N\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:op-wrap]{\mathrm{wrap}}_{M,N}(i) &=& i \mathbin{\mathrm{mod}} 2^N \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-trunc-u]{\mathrm{trunc}^{\mathsf{u}}}_{M,N}(z)\protect\)}
\label{\detokenize{exec/numerics:op-trunc-u}}\label{\detokenize{exec/numerics:id53}}\begin{itemize}
\item {} 
If \(z\) is a NaN, then the result is undefined.

\item {} 
Else if \(z\) is an infinity, then the result is undefined.

\item {} 
Else if \(z\) is a number and \(\hyperref[exec/numerics:aux-trunc]{\mathrm{trunc}}(z)\) is a value within range of the target type, then return that value.

\item {} 
Else the result is undefined.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:op-trunc-u]{\mathrm{trunc}^{\mathsf{u}}}_{M,N}(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \{\} \\
\hyperref[exec/numerics:op-trunc-u]{\mathrm{trunc}^{\mathsf{u}}}_{M,N}(\pm \infty) &=& \{\} \\
\hyperref[exec/numerics:op-trunc-u]{\mathrm{trunc}^{\mathsf{u}}}_{M,N}(\pm q) &=& \hyperref[exec/numerics:aux-trunc]{\mathrm{trunc}}(\pm q) & (\mathrel{\mbox{if}} -1 < \hyperref[exec/numerics:aux-trunc]{\mathrm{trunc}}(\pm q) < 2^N) \\
\hyperref[exec/numerics:op-trunc-u]{\mathrm{trunc}^{\mathsf{u}}}_{M,N}(\pm q) &=& \{\} & (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
This operator is {\hyperref[\detokenize{exec/numerics:exec-op-partial}]{\sphinxcrossref{\DUrole{std,std-ref}{partial}}}}.
It is not defined for NaNs, infinities, or values for which the result is out of range.
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[exec/numerics:op-trunc-s]{\mathrm{trunc}^{\mathsf{s}}}_{M,N}(z)\protect\)}
\label{\detokenize{exec/numerics:op-trunc-s}}\label{\detokenize{exec/numerics:id54}}\begin{itemize}
\item {} 
If \(z\) is a NaN, then the result is undefined.

\item {} 
Else if \(z\) is an infinity, then the result is undefined.

\item {} 
If \(z\) is a number and \(\hyperref[exec/numerics:aux-trunc]{\mathrm{trunc}}(z)\) is a value within range of the target type, then return that value.

\item {} 
Else the result is undefined.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:op-trunc-s]{\mathrm{trunc}^{\mathsf{s}}}_{M,N}(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \{\} \\
\hyperref[exec/numerics:op-trunc-s]{\mathrm{trunc}^{\mathsf{s}}}_{M,N}(\pm \infty) &=& \{\} \\
\hyperref[exec/numerics:op-trunc-s]{\mathrm{trunc}^{\mathsf{s}}}_{M,N}(\pm q) &=& \hyperref[exec/numerics:aux-trunc]{\mathrm{trunc}}(\pm q) & (\mathrel{\mbox{if}} -2^{N-1} - 1 < \hyperref[exec/numerics:aux-trunc]{\mathrm{trunc}}(\pm q) < 2^{N-1}) \\
\hyperref[exec/numerics:op-trunc-s]{\mathrm{trunc}^{\mathsf{s}}}_{M,N}(\pm q) &=& \{\} & (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
This operator is {\hyperref[\detokenize{exec/numerics:exec-op-partial}]{\sphinxcrossref{\DUrole{std,std-ref}{partial}}}}.
It is not defined for NaNs, infinities, or values for which the result is out of range.
\end{sphinxadmonition}


\subsubsection{\protect\(\hyperref[exec/numerics:op-promote]{\mathrm{promote}}_{M,N}(z)\protect\)}
\label{\detokenize{exec/numerics:id55}}\label{\detokenize{exec/numerics:op-promote}}\begin{itemize}
\item {} 
If \(z\) is a {\hyperref[\detokenize{syntax/values:canonical-nan}]{\sphinxcrossref{\DUrole{std,std-ref}{canonical NaN}}}}, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\}\) (i.e., a canonical NaN of size \(N\)).

\item {} 
Else if \(z\) is a NaN, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(1)\}\) (i.e., any NaN of size \(N\)).

\item {} 
Else, return \(z\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:op-promote]{\mathrm{promote}}_{M,N}(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\} & (\mathrel{\mbox{if}} n = \hyperref[syntax/values:aux-canon]{\mathrm{canon}}_N) \\
\hyperref[exec/numerics:op-promote]{\mathrm{promote}}_{M,N}(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{+ \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(1)\} & (\mathrel{\mbox{otherwise}}) \\
\hyperref[exec/numerics:op-promote]{\mathrm{promote}}_{M,N}(z) &=& z \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-demote]{\mathrm{demote}}_{M,N}(z)\protect\)}
\label{\detokenize{exec/numerics:op-demote}}\label{\detokenize{exec/numerics:id56}}\begin{itemize}
\item {} 
If \(z\) is a {\hyperref[\detokenize{syntax/values:canonical-nan}]{\sphinxcrossref{\DUrole{std,std-ref}{canonical NaN}}}}, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\}\) (i.e., a canonical NaN of size \(N\)).

\item {} 
Else if \(z\) is a NaN, then return an element of \(\hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(1)\}\) (i.e., any NaN of size \(N\)).

\item {} 
Else if \(z\) is an infinity, then return that infinity.

\item {} 
Else if \(z\) is a zero, then return that zero.

\item {} 
Else, return \(\hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(z)\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:op-demote]{\mathrm{demote}}_{M,N}(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{\} & (\mathrel{\mbox{if}} n = \hyperref[syntax/values:aux-canon]{\mathrm{canon}}_N) \\
\hyperref[exec/numerics:op-demote]{\mathrm{demote}}_{M,N}(\pm \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n)) &=& \hyperref[exec/numerics:aux-nans]{\mathrm{nans}}_N\{+ \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(1)\} & (\mathrel{\mbox{otherwise}}) \\
\hyperref[exec/numerics:op-demote]{\mathrm{demote}}_{M,N}(\pm \infty) &=& \pm \infty \\
\hyperref[exec/numerics:op-demote]{\mathrm{demote}}_{M,N}(\pm 0) &=& \pm 0 \\
\hyperref[exec/numerics:op-demote]{\mathrm{demote}}_{M,N}(\pm q) &=& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(\pm q) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-convert-u]{\mathrm{convert}^{\mathsf{u}}}_{M,N}(i)\protect\)}
\label{\detokenize{exec/numerics:id57}}\label{\detokenize{exec/numerics:op-convert-u}}\begin{itemize}
\item {} 
Return \(\hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(i)\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:op-convert-u]{\mathrm{convert}^{\mathsf{u}}}_{M,N}(i) &=& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(i) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-convert-s]{\mathrm{convert}^{\mathsf{s}}}_{M,N}(i)\protect\)}
\label{\detokenize{exec/numerics:id58}}\label{\detokenize{exec/numerics:op-convert-s}}\begin{itemize}
\item {} 
Let \(j\) be the {\hyperref[\detokenize{exec/numerics:aux-signed}]{\sphinxcrossref{\DUrole{std,std-ref}{signed interpretation}}}} of \(i\).

\item {} 
Return \(\hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(j)\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:op-convert-u]{\mathrm{convert}^{\mathsf{u}}}_{M,N}(i) &=& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(\hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_M(i)) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[exec/numerics:op-reinterpret]{\mathrm{reinterpret}}_{t_1,t_2}(c)\protect\)}
\label{\detokenize{exec/numerics:op-reinterpret}}\label{\detokenize{exec/numerics:id59}}\begin{itemize}
\item {} 
Let \(d^\ast\) be the bit sequence \(\hyperref[exec/numerics:aux-bits]{\mathrm{bits}}_{t_1}(c)\).

\item {} 
Return the constant \(c'\) for which \(\hyperref[exec/numerics:aux-bits]{\mathrm{bits}}_{t_2}(c') = d^\ast\).

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\hyperref[exec/numerics:op-reinterpret]{\mathrm{reinterpret}}_{t_1,t_2}(c) &=& \hyperref[exec/numerics:aux-bits]{\mathrm{bits}}_{t_2}^{-1}(\hyperref[exec/numerics:aux-bits]{\mathrm{bits}}_{t_1}(c)) \\
\end{array}\end{split}
\end{equation*}
\index{instruction}\index{function type}\index{store}\index{validation}\ignorespaces 

\section{Instructions}
\label{\detokenize{exec/instructions:exec-instr}}\label{\detokenize{exec/instructions:instructions}}\label{\detokenize{exec/instructions::doc}}\label{\detokenize{exec/instructions:index-0}}
WebAssembly computation is performed by executing individual {\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instructions}}}}.

\index{numeric instruction}\index{determinism}\index{trap}\index{NaN}\index{value}\index{value type}\index{execution!instruction}\index{instruction!execution}\index{abstract syntax!instruction}\ignorespaces 

\subsection{Numeric Instructions}
\label{\detokenize{exec/instructions:exec-instr-numeric}}\label{\detokenize{exec/instructions:numeric-instructions}}\label{\detokenize{exec/instructions:index-1}}
Numeric instructions are defined in terms of the basic {\hyperref[\detokenize{exec/numerics:exec-numeric}]{\sphinxcrossref{\DUrole{std,std-ref}{numeric operators}}}}.
The mapping of numeric instructions to their underlying operators is expressed by the following definition:
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\mathit{op}_{\mathsf{i}N}(n_1,\dots,n_k) &=& \mathrm{i}\mathit{op}_N(n_1,\dots,n_k) \\
\mathit{op}_{\mathsf{f}N}(z_1,\dots,z_k) &=& \mathrm{f}\mathit{op}_N(z_1,\dots,z_k) \\
\end{array}\end{split}
\end{equation*}
And for {\hyperref[\detokenize{exec/instructions:exec-cvtop}]{\sphinxcrossref{\DUrole{std,std-ref}{conversion operators}}}}:
\begin{equation*}
\begin{split}\begin{array}{lll@{\qquad}l}
\mathit{cvtop}^{\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}^?}_{t_1,t_2}(c) &=& \mathit{cvtop}^{\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}^?}_{|t_1|,|t_2|}(c) \\
\end{array}\end{split}
\end{equation*}
Where the underlying operators are partial, the corresponding instruction will {\hyperref[\detokenize{intro/overview:trap}]{\sphinxcrossref{\DUrole{std,std-ref}{trap}}}} when the result is not defined.
Where the underlying operators are non-deterministic, because they may return one of multiple possible {\hyperref[\detokenize{syntax/values:syntax-nan}]{\sphinxcrossref{\DUrole{std,std-ref}{NaN}}}} values, so are the corresponding instructions.


\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c\protect\)}
\label{\detokenize{exec/instructions:exec-const}}\label{\detokenize{exec/instructions:id1}}\begin{enumerate}
\item {} 
Push the value \(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c\) to the stack.

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
No formal reduction rule is required for this instruction, since \(\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}\) instructions coincide with {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}}.
\end{sphinxadmonition}


\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-unop]{\mathit{unop}}\protect\)}
\label{\detokenize{exec/instructions:exec-unop}}\label{\detokenize{exec/instructions:id2}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-unop}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t\) is on the top of the stack.

\item {} 
Pop the value \(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_1\) from the stack.

\item {} 
If \(\hyperref[syntax/instructions:syntax-unop]{\mathit{unop}}_t(c_1)\) is defined, then:
\begin{enumerate}
\item {} 
Let \(c\) be a possible result of computing \(\hyperref[syntax/instructions:syntax-unop]{\mathit{unop}}_t(c_1)\).

\item {} 
Push the value \(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c\) to the stack.

\end{enumerate}

\item {} 
Else:
\begin{enumerate}
\item {} 
Trap.

\end{enumerate}

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad}l}
(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_1)~t\mathsf{.}\hyperref[syntax/instructions:syntax-unop]{\mathit{unop}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& (t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)
  & (\mathrel{\mbox{if}} c \in \hyperref[syntax/instructions:syntax-unop]{\mathit{unop}}_t(c_1)) \\
(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_1)~t\mathsf{.}\hyperref[syntax/instructions:syntax-unop]{\mathit{unop}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}
  & (\mathrel{\mbox{if}} \hyperref[syntax/instructions:syntax-unop]{\mathit{unop}}_{t}(c_1) = \{\})
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-binop]{\mathit{binop}}\protect\)}
\label{\detokenize{exec/instructions:exec-binop}}\label{\detokenize{exec/instructions:id3}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-binop}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, two values of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t\) are on the top of the stack.

\item {} 
Pop the value \(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_2\) from the stack.

\item {} 
Pop the value \(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_1\) from the stack.

\item {} 
If \(\hyperref[syntax/instructions:syntax-binop]{\mathit{binop}}_t(c_1, c_2)\) is defined, then:
\begin{enumerate}
\item {} 
Let \(c\) be a possible result of computing \(\hyperref[syntax/instructions:syntax-binop]{\mathit{binop}}_t(c_1, c_2)\).

\item {} 
Push the value \(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c\) to the stack.

\end{enumerate}

\item {} 
Else:
\begin{enumerate}
\item {} 
Trap.

\end{enumerate}

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad}l}
(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_1)~(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_2)~t\mathsf{.}\hyperref[syntax/instructions:syntax-binop]{\mathit{binop}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& (t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)
  & (\mathrel{\mbox{if}} c \in \hyperref[syntax/instructions:syntax-binop]{\mathit{binop}}_t(c_1,c_2)) \\
(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_1)~(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_2)~t\mathsf{.}\hyperref[syntax/instructions:syntax-binop]{\mathit{binop}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}
  & (\mathrel{\mbox{if}} \hyperref[syntax/instructions:syntax-binop]{\mathit{binop}}_{t}(c_1,c2) = \{\})
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-testop]{\mathit{testop}}\protect\)}
\label{\detokenize{exec/instructions:exec-testop}}\label{\detokenize{exec/instructions:id4}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-testop}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t\) is on the top of the stack.

\item {} 
Pop the value \(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_1\) from the stack.

\item {} 
Let \(c\) be the result of computing \(\hyperref[syntax/instructions:syntax-testop]{\mathit{testop}}_t(c_1)\).

\item {} 
Push the value \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c\) to the stack.

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad}l}
(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_1)~t\mathsf{.}\hyperref[syntax/instructions:syntax-testop]{\mathit{testop}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)
  & (\mathrel{\mbox{if}} c = \hyperref[syntax/instructions:syntax-testop]{\mathit{testop}}_t(c_1)) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-relop]{\mathit{relop}}\protect\)}
\label{\detokenize{exec/instructions:exec-relop}}\label{\detokenize{exec/instructions:id5}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-relop}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, two values of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t\) are on the top of the stack.

\item {} 
Pop the value \(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_2\) from the stack.

\item {} 
Pop the value \(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_1\) from the stack.

\item {} 
Let \(c\) be the result of computing \(\hyperref[syntax/instructions:syntax-relop]{\mathit{relop}}_t(c_1, c_2)\).

\item {} 
Push the value \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c\) to the stack.

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad}l}
(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_1)~(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_2)~t\mathsf{.}\hyperref[syntax/instructions:syntax-relop]{\mathit{relop}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)
  & (\mathrel{\mbox{if}} c = \hyperref[syntax/instructions:syntax-relop]{\mathit{relop}}_t(c_1,c_2)) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(t_2\mathsf{.}\hyperref[syntax/instructions:syntax-cvtop]{\mathit{cvtop}}\mathsf{\_}t_1\mathsf{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}^?\protect\)}
\label{\detokenize{exec/instructions:exec-cvtop}}\label{\detokenize{exec/instructions:id6}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-cvtop}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t_1\) is on the top of the stack.

\item {} 
Pop the value \(t_1.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_1\) from the stack.

\item {} 
If \(\hyperref[syntax/instructions:syntax-cvtop]{\mathit{cvtop}}^{\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}^?}_{t_1,t_2}(c_1)\) is defined:
\begin{enumerate}
\item {} 
Let \(c_2\) be a possible result of computing \(\hyperref[syntax/instructions:syntax-cvtop]{\mathit{cvtop}}^{\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}^?}_{t_1,t_2}(c_1)\).

\item {} 
Push the value \(t_2.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_2\) to the stack.

\end{enumerate}

\item {} 
Else:
\begin{enumerate}
\item {} 
Trap.

\end{enumerate}

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad}l}
(t_1\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_1)~t_2\mathsf{.}\hyperref[syntax/instructions:syntax-cvtop]{\mathit{cvtop}}\mathsf{\_}t_1\mathsf{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}^? &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& (t_2\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_2)
  & (\mathrel{\mbox{if}} c_2 \in \hyperref[syntax/instructions:syntax-cvtop]{\mathit{cvtop}}^{\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}^?}_{t_1,t_2}(c_1)) \\
(t_1\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_1)~t_2\mathsf{.}\hyperref[syntax/instructions:syntax-cvtop]{\mathit{cvtop}}\mathsf{\_}t_1\mathsf{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}^? &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}
  & (\mathrel{\mbox{if}} \hyperref[syntax/instructions:syntax-cvtop]{\mathit{cvtop}}^{\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}^?}_{t_1,t_2}(c_1) = \{\})
\end{array}\end{split}
\end{equation*}
\index{parametric instructions}\index{value}\index{execution!instruction}\index{instruction!execution}\index{abstract syntax!instruction}\ignorespaces 

\subsection{Parametric Instructions}
\label{\detokenize{exec/instructions:parametric-instructions}}\label{\detokenize{exec/instructions:index-2}}\label{\detokenize{exec/instructions:exec-instr-parametric}}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{drop}}\protect\)}
\label{\detokenize{exec/instructions:id7}}\label{\detokenize{exec/instructions:exec-drop}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-drop}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value is on the top of the stack.

\item {} 
Pop the value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\) from the stack.

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad}l}
\hyperref[exec/runtime:syntax-val]{\mathit{val}}~~\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{drop}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& \epsilon
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}}\protect\)}
\label{\detokenize{exec/instructions:id8}}\label{\detokenize{exec/instructions:exec-select}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-select}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\) is on the top of the stack.

\item {} 
Pop the value \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c\) from the stack.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-select}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, two more values (of the same {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}}) are on the top of the stack.

\item {} 
Pop the value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}_2\) from the stack.

\item {} 
Pop the value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}_1\) from the stack.

\item {} 
If \(c\) is not \(0\), then:
\begin{enumerate}
\item {} 
Push the value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}_1\) back to the stack.

\end{enumerate}

\item {} 
Else:
\begin{enumerate}
\item {} 
Push the value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}_2\) back to the stack.

\end{enumerate}

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad}l}
\hyperref[exec/runtime:syntax-val]{\mathit{val}}_1~\hyperref[exec/runtime:syntax-val]{\mathit{val}}_2~(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)~\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& \hyperref[exec/runtime:syntax-val]{\mathit{val}}_1
  & (\mathrel{\mbox{if}} c \neq 0) \\
\hyperref[exec/runtime:syntax-val]{\mathit{val}}_1~\hyperref[exec/runtime:syntax-val]{\mathit{val}}_2~(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{.}\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)~\hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& \hyperref[exec/runtime:syntax-val]{\mathit{val}}_2
  & (\mathrel{\mbox{if}} c = 0) \\
\end{array}\end{split}
\end{equation*}
\index{variable instructions}\index{local index}\index{global index}\index{address}\index{global address}\index{global instance}\index{store}\index{frame}\index{value}\index{execution!instruction}\index{instruction!execution}\index{abstract syntax!instruction}\ignorespaces 

\subsection{Variable Instructions}
\label{\detokenize{exec/instructions:index-3}}\label{\detokenize{exec/instructions:exec-instr-variable}}\label{\detokenize{exec/instructions:variable-instructions}}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.get}}~x\protect\)}
\label{\detokenize{exec/instructions:id9}}\label{\detokenize{exec/instructions:exec-local-get}}\begin{enumerate}
\item {} 
Let \(F\) be the {\hyperref[\detokenize{exec/conventions:exec-notation-textual}]{\sphinxcrossref{\DUrole{std,std-ref}{current}}}} {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}}.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-local-get}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}[x]\) exists.

\item {} 
Let \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\) be the value \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}[x]\).

\item {} 
Push the value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\) to the stack.

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad}l}
F; (\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.get}}~x) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& F; \hyperref[exec/runtime:syntax-val]{\mathit{val}}
  & (\mathrel{\mbox{if}} F.\hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}[x] = \hyperref[exec/runtime:syntax-val]{\mathit{val}}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.set}}~x\protect\)}
\label{\detokenize{exec/instructions:id10}}\label{\detokenize{exec/instructions:exec-local-set}}\begin{enumerate}
\item {} 
Let \(F\) be the {\hyperref[\detokenize{exec/conventions:exec-notation-textual}]{\sphinxcrossref{\DUrole{std,std-ref}{current}}}} {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}}.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-local-set}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}[x]\) exists.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-local-set}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value is on the top of the stack.

\item {} 
Pop the value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\) from the stack.

\item {} 
Replace \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}[x]\) with the value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad}l}
F; \hyperref[exec/runtime:syntax-val]{\mathit{val}}~(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.set}}~x) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& F'; \epsilon
  & (\mathrel{\mbox{if}} F' = F \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}[x] = \hyperref[exec/runtime:syntax-val]{\mathit{val}}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.tee}}~x\protect\)}
\label{\detokenize{exec/instructions:exec-local-tee}}\label{\detokenize{exec/instructions:id11}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-local-tee}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value is on the top of the stack.

\item {} 
Pop the value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\) from the stack.

\item {} 
Push the value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\) to the stack.

\item {} 
Push the value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\) to the stack.

\item {} 
{\hyperref[\detokenize{exec/instructions:exec-local-set}]{\sphinxcrossref{\DUrole{std,std-ref}{Execute}}}} the instruction \((\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.set}}~x)\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad}l}
\hyperref[exec/runtime:syntax-val]{\mathit{val}}~(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.tee}}~x) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& \hyperref[exec/runtime:syntax-val]{\mathit{val}}~\hyperref[exec/runtime:syntax-val]{\mathit{val}}~(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.set}}~x)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.get}}~x\protect\)}
\label{\detokenize{exec/instructions:exec-global-get}}\label{\detokenize{exec/instructions:id12}}\begin{enumerate}
\item {} 
Let \(F\) be the {\hyperref[\detokenize{exec/conventions:exec-notation-textual}]{\sphinxcrossref{\DUrole{std,std-ref}{current}}}} {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}}.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-global-get}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{globaladdrs}}[x]\) exists.

\item {} 
Let \(a\) be the {\hyperref[\detokenize{exec/runtime:syntax-globaladdr}]{\sphinxcrossref{\DUrole{std,std-ref}{global address}}}} \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{globaladdrs}}[x]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-global-get}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[a]\) exists.

\item {} 
Let \(\mathit{glob}\) be the {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{global instance}}}} \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[a]\).

\item {} 
Let \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\) be the value \(\mathit{glob}.\hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}\).

\item {} 
Push the value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\) to the stack.

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{l}
\begin{array}{lcl@{\qquad}l}
S; F; (\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.get}}~x) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S; F; \hyperref[exec/runtime:syntax-val]{\mathit{val}}
\end{array}
\\ \qquad
  (\mathrel{\mbox{if}} S.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{globaladdrs}}[x]].\hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}} = \hyperref[exec/runtime:syntax-val]{\mathit{val}}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.set}}~x\protect\)}
\label{\detokenize{exec/instructions:id13}}\label{\detokenize{exec/instructions:exec-global-set}}\begin{enumerate}
\item {} 
Let \(F\) be the {\hyperref[\detokenize{exec/conventions:exec-notation-textual}]{\sphinxcrossref{\DUrole{std,std-ref}{current}}}} {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}}.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-global-set}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{globaladdrs}}[x]\) exists.

\item {} 
Let \(a\) be the {\hyperref[\detokenize{exec/runtime:syntax-globaladdr}]{\sphinxcrossref{\DUrole{std,std-ref}{global address}}}} \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{globaladdrs}}[x]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-global-set}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[a]\) exists.

\item {} 
Let \(\mathit{glob}\) be the {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{global instance}}}} \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[a]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-global-set}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value is on the top of the stack.

\item {} 
Pop the value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\) from the stack.

\item {} 
Replace \(\mathit{glob}.\hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}\) with the value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{l}
\begin{array}{lcl@{\qquad}l}
S; F; \hyperref[exec/runtime:syntax-val]{\mathit{val}}~(\hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.set}}~x) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S'; F; \epsilon
\end{array}
\\ \qquad
(\mathrel{\mbox{if}} S' = S \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{globaladdrs}}[x]].\hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}} = \hyperref[exec/runtime:syntax-val]{\mathit{val}}) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
{\hyperref[\detokenize{valid/instructions:valid-global-set}]{\sphinxcrossref{\DUrole{std,std-ref}{Validation}}}} ensures that the global is, in fact, marked as mutable.
\end{sphinxadmonition}

\index{memory instruction}\index{memory index}\index{store}\index{frame}\index{address}\index{memory address}\index{memory instance}\index{store}\index{frame}\index{value}\index{integer}\index{limits}\index{value type}\index{bit width}\index{execution!instruction}\index{instruction!execution}\index{abstract syntax!instruction}\ignorespaces \phantomsection\label{\detokenize{exec/instructions:exec-memarg}}

\subsection{Memory Instructions}
\label{\detokenize{exec/instructions:index-4}}\label{\detokenize{exec/instructions:memory-instructions}}\label{\detokenize{exec/instructions:exec-memarg}}\label{\detokenize{exec/instructions:exec-instr-memory}}
\begin{sphinxadmonition}{note}{Note:}
The alignment \(\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{align}}\) in load and store instructions does not affect the semantics.
It is an indication that the offset \(\mathit{ea}\) at which the memory is accessed is intended to satisfy the property \(\mathit{ea} \mathbin{\mathrm{mod}} 2^{\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{align}}} = 0\).
A WebAssembly implementation can use this hint to optimize for the intended use.
Unaligned access violating that property is still allowed and must succeed regardless of the annotation.
However, it may be substantially slower on some hardware.
\end{sphinxadmonition}
\phantomsection\label{\detokenize{exec/instructions:exec-load}}

\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}\protect\) and \protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}{N}\mathsf{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}\protect\)}
\label{\detokenize{exec/instructions:and}}\label{\detokenize{exec/instructions:exec-loadn}}\label{\detokenize{exec/instructions:exec-load}}\begin{enumerate}
\item {} 
Let \(F\) be the {\hyperref[\detokenize{exec/conventions:exec-notation-textual}]{\sphinxcrossref{\DUrole{std,std-ref}{current}}}} {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}}.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-loadn}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]\) exists.

\item {} 
Let \(a\) be the {\hyperref[\detokenize{exec/runtime:syntax-memaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{memory address}}}} \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-loadn}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a]\) exists.

\item {} 
Let \(\mathit{mem}\) be the {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}} \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-loadn}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\) is on the top of the stack.

\item {} 
Pop the value \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~i\) from the stack.

\item {} 
Let \(\mathit{ea}\) be the integer \(i + \hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{offset}}\).

\item {} 
If \(N\) is not part of the instruction, then:
\begin{enumerate}
\item {} 
Let \(N\) be the {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{bit width}}}} \(|t|\) of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t\).

\end{enumerate}

\item {} 
If \(\mathit{ea} + N/8\) is larger than the length of \(\mathit{mem}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}\), then:
\begin{enumerate}
\item {} 
Trap.

\end{enumerate}

\item {} 
Let \(b^\ast\) be the byte sequence \(\mathit{mem}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}[\mathit{ea} \hyperref[syntax/conventions:notation-slice]{\mathrel{\mathbf{:}}} N/8]\).

\item {} 
If \(N\) and \(\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}\) are part of the instruction, then:
\begin{enumerate}
\item {} 
Let \(n\) be the integer for which \(\hyperref[exec/numerics:aux-bytes]{\mathrm{bytes}}_{\hyperref[syntax/values:syntax-int]{\def\mathdef1491#1{{\mathit{i}#1}}\mathdef1491{N}}}(n) = b^\ast\).

\item {} 
Let \(c\) be the result of computing \(\hyperref[exec/numerics:op-extend-u]{\mathrm{extend}}\mathrm{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}_{N,|t|}(n)\).

\end{enumerate}

\item {} 
Else:
\begin{enumerate}
\item {} 
Let \(c\) be the constant for which \(\hyperref[exec/numerics:aux-bytes]{\mathrm{bytes}}_t(c) = b^\ast\).

\end{enumerate}

\item {} 
Push the value \(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c\) to the stack.

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{l}
\begin{array}{lcl@{\qquad}l}
S; F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~i)~(t.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S; F; (t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)
\end{array}
\\ \qquad
  \begin{array}[t]{@{}r@{~}l@{}}
  (\mathrel{\mbox{if}} & \mathit{ea} = i + \hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{offset}} \\
  \wedge & \mathit{ea} + |t|/8 \leq |S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}| \\
  \wedge & \hyperref[exec/numerics:aux-bytes]{\mathrm{bytes}}_t(c) = S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}[\mathit{ea} \hyperref[syntax/conventions:notation-slice]{\mathrel{\mathbf{:}}} |t|/8])
  \end{array}
\\[1ex]
\begin{array}{lcl@{\qquad}l}
S; F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~i)~(t.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}{N}\mathsf{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}&
  S; F; (t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\hyperref[exec/numerics:op-extend-u]{\mathrm{extend}}\mathrm{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}}_{N,|t|}(n))
\end{array}
\\ \qquad
  \begin{array}[t]{@{}r@{~}l@{}}
  (\mathrel{\mbox{if}} & \mathit{ea} = i + \hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{offset}} \\
  \wedge & \mathit{ea} + N/8 \leq |S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}| \\
  \wedge & \hyperref[exec/numerics:aux-bytes]{\mathrm{bytes}}_{\hyperref[syntax/values:syntax-int]{\def\mathdef1491#1{{\mathit{i}#1}}\mathdef1491{N}}}(n) = S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}[\mathit{ea} \hyperref[syntax/conventions:notation-slice]{\mathrel{\mathbf{:}}} N/8])
  \end{array}
\\[1ex]
\begin{array}{lcl@{\qquad}l}
S; F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~k)~(t.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}({N}\mathsf{\_}\hyperref[syntax/instructions:syntax-sx]{\mathit{sx}})^?~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S; F; \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}
\end{array}
\\ \qquad
  (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}\phantomsection\label{\detokenize{exec/instructions:exec-store}}

\subsubsection{\protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}\protect\) and \protect\(t\mathsf{.}\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}{N}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}\protect\)}
\label{\detokenize{exec/instructions:exec-store}}\label{\detokenize{exec/instructions:exec-storen}}\label{\detokenize{exec/instructions:id14}}\begin{enumerate}
\item {} 
Let \(F\) be the {\hyperref[\detokenize{exec/conventions:exec-notation-textual}]{\sphinxcrossref{\DUrole{std,std-ref}{current}}}} {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}}.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-storen}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]\) exists.

\item {} 
Let \(a\) be the {\hyperref[\detokenize{exec/runtime:syntax-memaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{memory address}}}} \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-storen}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a]\) exists.

\item {} 
Let \(\mathit{mem}\) be the {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}} \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-storen}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t\) is on the top of the stack.

\item {} 
Pop the value \(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c\) from the stack.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-storen}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\) is on the top of the stack.

\item {} 
Pop the value \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~i\) from the stack.

\item {} 
Let \(\mathit{ea}\) be the integer \(i + \hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{offset}}\).

\item {} 
If \(N\) is not part of the instruction, then:
\begin{enumerate}
\item {} 
Let \(N\) be the {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{bit width}}}} \(|t|\) of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t\).

\end{enumerate}

\item {} 
If \(\mathit{ea} + N/8\) is larger than the length of \(\mathit{mem}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}\), then:
\begin{enumerate}
\item {} 
Trap.

\end{enumerate}

\item {} 
If \(N\) is part of the instruction, then:
\begin{enumerate}
\item {} 
Let \(n\) be the result of computing \(\hyperref[exec/numerics:op-wrap]{\mathrm{wrap}}_{|t|,N}(c)\).

\item {} 
Let \(b^\ast\) be the byte sequence \(\hyperref[exec/numerics:aux-bytes]{\mathrm{bytes}}_{\hyperref[syntax/values:syntax-int]{\def\mathdef1491#1{{\mathit{i}#1}}\mathdef1491{N}}}(n)\).

\end{enumerate}

\item {} 
Else:
\begin{enumerate}
\item {} 
Let \(b^\ast\) be the byte sequence \(\hyperref[exec/numerics:aux-bytes]{\mathrm{bytes}}_t(c)\).

\end{enumerate}

\item {} 
Replace the bytes \(\mathit{mem}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}[\mathit{ea} \hyperref[syntax/conventions:notation-slice]{\mathrel{\mathbf{:}}} N/8]\) with \(b^\ast\).

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{l}
\begin{array}{lcl@{\qquad}l}
S; F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~i)~(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)~(t.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S'; F; \epsilon
\end{array}
\\ \qquad
  \begin{array}[t]{@{}r@{~}l@{}}
  (\mathrel{\mbox{if}} & \mathit{ea} = i + \hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{offset}} \\
  \wedge & \mathit{ea} + |t|/8 \leq |S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}| \\
  \wedge & S' = S \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}[\mathit{ea} \hyperref[syntax/conventions:notation-slice]{\mathrel{\mathbf{:}}} |t|/8] = \hyperref[exec/numerics:aux-bytes]{\mathrm{bytes}}_t(c)
  \end{array}
\\[1ex]
\begin{array}{lcl@{\qquad}l}
S; F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~i)~(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)~(t.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}{N}~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S'; F; \epsilon
\end{array}
\\ \qquad
  \begin{array}[t]{@{}r@{~}l@{}}
  (\mathrel{\mbox{if}} & \mathit{ea} = i + \hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{offset}} \\
  \wedge & \mathit{ea} + N/8 \leq |S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}| \\
  \wedge & S' = S \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}[\mathit{ea} \hyperref[syntax/conventions:notation-slice]{\mathrel{\mathbf{:}}} N/8] = \hyperref[exec/numerics:aux-bytes]{\mathrm{bytes}}_{\hyperref[syntax/values:syntax-int]{\def\mathdef1491#1{{\mathit{i}#1}}\mathdef1491{N}}}(\hyperref[exec/numerics:op-wrap]{\mathrm{wrap}}_{|t|,N}(c))
  \end{array}
\\[1ex]
\begin{array}{lcl@{\qquad}l}
S; F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~k)~(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)~(t.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}{N}^?~\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S; F; \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}
\end{array}
\\ \qquad
  (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.size}}\protect\)}
\label{\detokenize{exec/instructions:exec-memory-size}}\label{\detokenize{exec/instructions:id15}}\begin{enumerate}
\item {} 
Let \(F\) be the {\hyperref[\detokenize{exec/conventions:exec-notation-textual}]{\sphinxcrossref{\DUrole{std,std-ref}{current}}}} {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}}.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-memory-size}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]\) exists.

\item {} 
Let \(a\) be the {\hyperref[\detokenize{exec/runtime:syntax-memaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{memory address}}}} \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-memory-size}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a]\) exists.

\item {} 
Let \(\mathit{mem}\) be the {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}} \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a]\).

\item {} 
Let \(\mathit{sz}\) be the length of \(\mathit{mem}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}\) divided by the {\hyperref[\detokenize{exec/runtime:page-size}]{\sphinxcrossref{\DUrole{std,std-ref}{page size}}}}.

\item {} 
Push the value \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\mathit{sz}\) to the stack.

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{l}
\begin{array}{lcl@{\qquad}l}
S; F; \hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.size}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S; F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\mathit{sz})
\end{array}
\\ \qquad
  (\mathrel{\mbox{if}} |S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}| = \mathit{sz}\cdot64\,\mathrm{Ki}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.grow}}\protect\)}
\label{\detokenize{exec/instructions:id16}}\label{\detokenize{exec/instructions:exec-memory-grow}}\begin{enumerate}
\item {} 
Let \(F\) be the {\hyperref[\detokenize{exec/conventions:exec-notation-textual}]{\sphinxcrossref{\DUrole{std,std-ref}{current}}}} {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}}.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-memory-grow}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]\) exists.

\item {} 
Let \(a\) be the {\hyperref[\detokenize{exec/runtime:syntax-memaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{memory address}}}} \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-memory-grow}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a]\) exists.

\item {} 
Let \(\mathit{mem}\) be the {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}} \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a]\).

\item {} 
Let \(\mathit{sz}\) be the length of \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a]\) divided by the {\hyperref[\detokenize{exec/runtime:page-size}]{\sphinxcrossref{\DUrole{std,std-ref}{page size}}}}.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-memory-grow}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\) is on the top of the stack.

\item {} 
Pop the value \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~n\) from the stack.

\item {} 
Either, try {\hyperref[\detokenize{exec/modules:grow-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{growing}}}} \(\mathit{mem}\) by \(n\) {\hyperref[\detokenize{exec/runtime:page-size}]{\sphinxcrossref{\DUrole{std,std-ref}{pages}}}}:
\begin{enumerate}
\item {} 
If it succeeds, push the value \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\mathit{sz}\) to the stack.

\item {} 
Else, push the value \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~(-1)\) to the stack.

\end{enumerate}

\item {} 
Or, push the value \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~(-1)\) to the stack.

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{l}
\begin{array}{lcl@{\qquad}l}
S; F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~n)~\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.grow}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S'; F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\mathit{sz})
\end{array}
\\ \qquad
  \begin{array}[t]{@{}r@{~}l@{}}
  (\mathrel{\mbox{if}} & F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[0] = a \\
  \wedge & \mathit{sz} = |S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}|/64\,\mathrm{Ki} \\
  \wedge & S' = S \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a] = \hyperref[exec/modules:grow-mem]{\mathrm{growmem}}(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a], n)) \\
  \end{array}
\\[1ex]
\begin{array}{lcl@{\qquad}l}
S; F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~n)~\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.grow}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S; F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~{-1})
\end{array}
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The \(\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.grow}}\) instruction is non-deterministic.
It may either succeed, returning the old memory size \(\mathit{sz}\),
or fail, returning \({-1}\).
Failure \sphinxstyleemphasis{must} occur if the referenced memory instance has a maximum size defined that would be exceeded.
However, failure \sphinxstyleemphasis{can} occur in other cases as well.
In practice, the choice depends on the {\hyperref[\detokenize{appendix/implementation:impl-exec}]{\sphinxcrossref{\DUrole{std,std-ref}{resources}}}} available to the {\hyperref[\detokenize{intro/overview:embedder}]{\sphinxcrossref{\DUrole{std,std-ref}{embedder}}}}.
\end{sphinxadmonition}

\index{control instructions}\index{structured control}\index{label}\index{block}\index{branch}\index{result type}\index{label index}\index{function index}\index{type index}\index{vector}\index{address}\index{table address}\index{table instance}\index{store}\index{frame}\index{execution!instruction}\index{instruction!execution}\index{abstract syntax!instruction}\ignorespaces \phantomsection\label{\detokenize{exec/instructions:exec-label}}

\subsection{Control Instructions}
\label{\detokenize{exec/instructions:control-instructions}}\label{\detokenize{exec/instructions:exec-label}}\label{\detokenize{exec/instructions:exec-instr-control}}\label{\detokenize{exec/instructions:index-5}}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{nop}}\protect\)}
\label{\detokenize{exec/instructions:id17}}\label{\detokenize{exec/instructions:exec-nop}}\begin{enumerate}
\item {} 
Do nothing.

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad}l}
\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{nop}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& \epsilon
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}}\protect\)}
\label{\detokenize{exec/instructions:id18}}\label{\detokenize{exec/instructions:exec-unreachable}}\begin{enumerate}
\item {} 
Trap.

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad}l}
\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}~\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\protect\)}
\label{\detokenize{exec/instructions:exec-block}}\label{\detokenize{exec/instructions:id19}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/types:valid-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(\hyperref[exec/runtime:syntax-frame]{\mathrm{expand}}_F(\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}})\) is defined.

\item {} 
Let \([t_1^m] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^n]\) be the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(\hyperref[exec/runtime:syntax-frame]{\mathrm{expand}}_F(\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}})\).

\item {} 
Let \(L\) be the label whose arity is \(n\) and whose continuation is the end of the block.

\item {} 
{\hyperref[\detokenize{exec/instructions:exec-instr-seq-enter}]{\sphinxcrossref{\DUrole{std,std-ref}{Enter}}}} the block \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\) with label \(L\).

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{lcl@{\qquad}l}
F; \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}~\mathit{bt}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}&
  F; \hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\epsilon\}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}
  & (\mathrel{\mbox{if}} \hyperref[exec/runtime:syntax-frame]{\mathrm{expand}}_F(\mathit{bt}) = [t_1^m] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^n])
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{loop}}~\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\protect\)}
\label{\detokenize{exec/instructions:exec-loop}}\label{\detokenize{exec/instructions:id20}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/types:valid-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(\hyperref[exec/runtime:syntax-frame]{\mathrm{expand}}_F(\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}})\) is defined.

\item {} 
Let \([t_1^m] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^n]\) be the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(\hyperref[exec/runtime:syntax-frame]{\mathrm{expand}}_F(\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}})\).

\item {} 
Let \(L\) be the label whose arity is \(m\) and whose continuation is the start of the loop.

\item {} 
{\hyperref[\detokenize{exec/instructions:exec-instr-seq-enter}]{\sphinxcrossref{\DUrole{std,std-ref}{Enter}}}} the block \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\) with label \(L\).

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{lcl@{\qquad}l}
F; \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{loop}}~\mathit{bt}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}&
  F; \hyperref[exec/runtime:syntax-label]{\mathsf{label}}_m\{\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{loop}}~\mathit{bt}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}
  & (\mathrel{\mbox{if}} \hyperref[exec/runtime:syntax-frame]{\mathrm{expand}}_F(\mathit{bt}) = [t_1^m] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^n])
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}~\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_1^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{else}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_2^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\protect\)}
\label{\detokenize{exec/instructions:id21}}\label{\detokenize{exec/instructions:exec-if}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/types:valid-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(\hyperref[exec/runtime:syntax-frame]{\mathrm{expand}}_F(\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}})\) is defined.

\item {} 
Let \([t_1^m] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^n]\) be the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(\hyperref[exec/runtime:syntax-frame]{\mathrm{expand}}_F(\hyperref[syntax/instructions:syntax-blocktype]{\mathit{blocktype}})\).

\item {} 
Let \(L\) be the label whose arity is \(n\) and whose continuation is the end of the \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}\) instruction.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-if}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\) is on the top of the stack.

\item {} 
Pop the value \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c\) from the stack.

\item {} 
If \(c\) is non-zero, then:
\begin{enumerate}
\item {} 
{\hyperref[\detokenize{exec/instructions:exec-instr-seq-enter}]{\sphinxcrossref{\DUrole{std,std-ref}{Enter}}}} the block \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_1^\ast\) with label \(L\).

\end{enumerate}

\item {} 
Else:
\begin{enumerate}
\item {} 
{\hyperref[\detokenize{exec/instructions:exec-instr-seq-enter}]{\sphinxcrossref{\DUrole{std,std-ref}{Enter}}}} the block \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_2^\ast\) with label \(L\).

\end{enumerate}

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{lcl@{\qquad}l}
F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}~\mathit{bt}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_1^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{else}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_2^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}&
  F; \hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\epsilon\}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_1^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}
  & (\mathrel{\mbox{if}} c \neq 0 \wedge \hyperref[exec/runtime:syntax-frame]{\mathrm{expand}}_F(\mathit{bt}) = [t_1^m] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^n]) \\
F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}~\mathit{bt}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_1^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{else}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_2^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}&
  F; \hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\epsilon\}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_2^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}
  & (\mathrel{\mbox{if}} c = 0 \wedge \hyperref[exec/runtime:syntax-frame]{\mathrm{expand}}_F(\mathit{bt}) = [t_1^m] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^n]) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}~l\protect\)}
\label{\detokenize{exec/instructions:id22}}\label{\detokenize{exec/instructions:exec-br}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-br}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, the stack contains at least \(l+1\) labels.

\item {} 
Let \(L\) be the \(l\)-th label appearing on the stack, starting from the top and counting from zero.

\item {} 
Let \(n\) be the arity of \(L\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-br}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, there are at least \(n\) values on the top of the stack.

\item {} 
Pop the values \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^n\) from the stack.

\item {} 
Repeat \(l+1\) times:
\begin{enumerate}
\item {} 
While the top of the stack is a value, do:
\begin{enumerate}
\item {} 
Pop the value from the stack.

\end{enumerate}

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-br}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, the top of the stack now is a label.

\item {} 
Pop the label from the stack.

\end{enumerate}

\item {} 
Push the values \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^n\) to the stack.

\item {} 
Jump to the continuation of \(L\).

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{lcl@{\qquad}l}
\hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\}~\hyperref[exec/runtime:syntax-ctxt-block]{B}^l[\hyperref[exec/runtime:syntax-val]{\mathit{val}}^n~(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}~l)]~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& \hyperref[exec/runtime:syntax-val]{\mathit{val}}^n~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_if}}~l\protect\)}
\label{\detokenize{exec/instructions:exec-br-if}}\label{\detokenize{exec/instructions:id23}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-br-if}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\) is on the top of the stack.

\item {} 
Pop the value \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c\) from the stack.

\item {} 
If \(c\) is non-zero, then:
\begin{enumerate}
\item {} 
{\hyperref[\detokenize{exec/instructions:exec-br}]{\sphinxcrossref{\DUrole{std,std-ref}{Execute}}}} the instruction \((\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}~l)\).

\end{enumerate}

\item {} 
Else:
\begin{enumerate}
\item {} 
Do nothing.

\end{enumerate}

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{lcl@{\qquad}l}
(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)~(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_if}}~l) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& (\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}~l)
  & (\mathrel{\mbox{if}} c \neq 0) \\
(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)~(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_if}}~l) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& \epsilon
  & (\mathrel{\mbox{if}} c = 0) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_table}}~l^\ast~l_N\protect\)}
\label{\detokenize{exec/instructions:id24}}\label{\detokenize{exec/instructions:exec-br-table}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-if}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\) is on the top of the stack.

\item {} 
Pop the value \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~i\) from the stack.

\item {} 
If \(i\) is smaller than the length of \(l^\ast\), then:
\begin{enumerate}
\item {} 
Let \(l_i\) be the label \(l^\ast[i]\).

\item {} 
{\hyperref[\detokenize{exec/instructions:exec-br}]{\sphinxcrossref{\DUrole{std,std-ref}{Execute}}}} the instruction \((\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}~l_i)\).

\end{enumerate}

\item {} 
Else:
\begin{enumerate}
\item {} 
{\hyperref[\detokenize{exec/instructions:exec-br}]{\sphinxcrossref{\DUrole{std,std-ref}{Execute}}}} the instruction \((\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}~l_N)\).

\end{enumerate}

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{lcl@{\qquad}l}
(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~i)~(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_table}}~l^\ast~l_N) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& (\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}~l_i)
  & (\mathrel{\mbox{if}} l^\ast[i] = l_i) \\
(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~i)~(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_table}}~l^\ast~l_N) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& (\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}~l_N)
  & (\mathrel{\mbox{if}} |l^\ast| \leq i) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{return}}\protect\)}
\label{\detokenize{exec/instructions:exec-return}}\label{\detokenize{exec/instructions:id25}}\begin{enumerate}
\item {} 
Let \(F\) be the {\hyperref[\detokenize{exec/conventions:exec-notation-textual}]{\sphinxcrossref{\DUrole{std,std-ref}{current}}}} {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}}.

\item {} 
Let \(n\) be the arity of \(F\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-return}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, there are at least \(n\) values on the top of the stack.

\item {} 
Pop the results \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^n\) from the stack.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-return}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, the stack contains at least one {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}}.

\item {} 
While the top of the stack is not a frame, do:
\begin{enumerate}
\item {} 
Pop the top element from the stack.

\end{enumerate}

\item {} 
Assert: the top of the stack is the frame \(F\).

\item {} 
Pop the frame from the stack.

\item {} 
Push \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^n\) to the stack.

\item {} 
Jump to the instruction after the original call that pushed the frame.

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{lcl@{\qquad}l}
\hyperref[exec/runtime:syntax-frame]{\mathsf{frame}}_n\{F\}~\hyperref[exec/runtime:syntax-ctxt-block]{B}^k[\hyperref[exec/runtime:syntax-val]{\mathit{val}}^n~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{return}}]~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& \hyperref[exec/runtime:syntax-val]{\mathit{val}}^n
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call}}~x\protect\)}
\label{\detokenize{exec/instructions:id26}}\label{\detokenize{exec/instructions:exec-call}}\begin{enumerate}
\item {} 
Let \(F\) be the {\hyperref[\detokenize{exec/conventions:exec-notation-textual}]{\sphinxcrossref{\DUrole{std,std-ref}{current}}}} {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}}.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-call}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}}[x]\) exists.

\item {} 
Let \(a\) be the {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{function address}}}} \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}}[x]\).

\item {} 
{\hyperref[\detokenize{exec/instructions:exec-invoke}]{\sphinxcrossref{\DUrole{std,std-ref}{Invoke}}}} the function instance at address \(a\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad}l}
F; (\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call}}~x) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& F; (\hyperref[exec/runtime:syntax-invoke]{\mathsf{invoke}}~a)
  & (\mathrel{\mbox{if}} F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}}[x] = a)
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call\_indirect}}~x\protect\)}
\label{\detokenize{exec/instructions:id27}}\label{\detokenize{exec/instructions:exec-call-indirect}}\begin{enumerate}
\item {} 
Let \(F\) be the {\hyperref[\detokenize{exec/conventions:exec-notation-textual}]{\sphinxcrossref{\DUrole{std,std-ref}{current}}}} {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}}.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-call-indirect}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{tableaddrs}}[0]\) exists.

\item {} 
Let \(\mathit{ta}\) be the {\hyperref[\detokenize{exec/runtime:syntax-tableaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{table address}}}} \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{tableaddrs}}[0]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-call-indirect}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[\mathit{ta}]\) exists.

\item {} 
Let \(\mathit{tab}\) be the {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instance}}}} \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[\mathit{ta}]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-call-indirect}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{types}}[x]\) exists.

\item {} 
Let \(\mathit{ft}_{\mathrm{expect}}\) be the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{types}}[x]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-call-indirect}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, a value with {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\) is on the top of the stack.

\item {} 
Pop the value \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~i\) from the stack.

\item {} 
If \(i\) is not smaller than the length of \(\mathit{tab}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}\), then:
\begin{enumerate}
\item {} 
Trap.

\end{enumerate}

\item {} 
If \(\mathit{tab}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}[i]\) is uninitialized, then:
\begin{enumerate}
\item {} 
Trap.

\end{enumerate}

\item {} 
Let \(a\) be the {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{function address}}}} \(\mathit{tab}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}[i]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-call-indirect}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[a]\) exists.

\item {} 
Let \(\mathit{f}\) be the {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{function instance}}}} \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[a]\).

\item {} 
Let \(\mathit{ft}_{\mathrm{actual}}\) be the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(\mathit{f}.\hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}\).

\item {} 
If \(\mathit{ft}_{\mathrm{actual}}\) and \(\mathit{ft}_{\mathrm{expect}}\) differ, then:
\begin{enumerate}
\item {} 
Trap.

\end{enumerate}

\item {} 
{\hyperref[\detokenize{exec/instructions:exec-invoke}]{\sphinxcrossref{\DUrole{std,std-ref}{Invoke}}}} the function instance at address \(a\).

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{l}
\begin{array}{lcl@{\qquad}l}
S; F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~i)~(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call\_indirect}}~x) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S; F; (\hyperref[exec/runtime:syntax-invoke]{\mathsf{invoke}}~a)
\end{array}
\\ \qquad
  \begin{array}[t]{@{}r@{~}l@{}}
  (\mathrel{\mbox{if}} & S.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{tableaddrs}}[0]].\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}[i] = a \\
  \wedge & S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[a] = f \\
  \wedge & F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{types}}[x] = f.\hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}})
  \end{array}
\\[1ex]
\begin{array}{lcl@{\qquad}l}
S; F; (\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~i)~(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call\_indirect}}~x) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S; F; \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}
\end{array}
\\ \qquad
  (\mathrel{\mbox{otherwise}})
\end{array}\end{split}
\end{equation*}
\index{instruction}\index{instruction sequence}\index{block}\ignorespaces 

\subsection{Blocks}
\label{\detokenize{exec/instructions:blocks}}\label{\detokenize{exec/instructions:index-6}}\label{\detokenize{exec/instructions:exec-instr-seq}}
The following auxiliary rules define the semantics of executing an {\hyperref[\detokenize{syntax/instructions:syntax-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{instruction sequence}}}}
that forms a {\hyperref[\detokenize{exec/instructions:exec-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{block}}}}.


\subsubsection{Entering \protect\(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\protect\) with label \protect\(L\protect\)}
\label{\detokenize{exec/instructions:entering-with-label}}\label{\detokenize{exec/instructions:exec-instr-seq-enter}}\begin{enumerate}
\item {} 
Push \(L\) to the stack.

\item {} 
Jump to the start of the instruction sequence \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\).

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
No formal reduction rule is needed for entering an instruction sequence,
because the label \(L\) is embedded in the {\hyperref[\detokenize{exec/runtime:syntax-instr-admin}]{\sphinxcrossref{\DUrole{std,std-ref}{administrative instruction}}}} that structured control instructions reduce to directly.
\end{sphinxadmonition}


\subsubsection{Exiting \protect\(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\protect\) with label \protect\(L\protect\)}
\label{\detokenize{exec/instructions:exec-instr-seq-exit}}\label{\detokenize{exec/instructions:exiting-with-label}}
When the end of a block is reached without a jump or trap aborting it, then the following steps are performed.
\begin{enumerate}
\item {} 
Let \(m\) be the number of values on the top of the stack.

\item {} 
Pop the values \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^m\) from the stack.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, the label \(L\) is now on the top of the stack.

\item {} 
Pop the label from the stack.

\item {} 
Push \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^m\) back to the stack.

\item {} 
Jump to the position after the \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\) of the {\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{structured control instruction}}}} associated with the label \(L\).

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{lcl@{\qquad}l}
\hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\}~\hyperref[exec/runtime:syntax-val]{\mathit{val}}^m~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& \hyperref[exec/runtime:syntax-val]{\mathit{val}}^m
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
This semantics also applies to the instruction sequence contained in a \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{loop}}\) instruction.
Therefore, execution of a loop falls off the end, unless a backwards branch is performed explicitly.
\end{sphinxadmonition}

\index{call|textbf}\index{function}\index{function instance}\index{label}\index{frame}\ignorespaces 

\subsection{Function Calls}
\label{\detokenize{exec/instructions:function-calls}}\label{\detokenize{exec/instructions:index-7}}
The following auxiliary rules define the semantics of invoking a {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{function instance}}}}
through one of the {\hyperref[\detokenize{exec/instructions:exec-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{call instructions}}}}
and returning from it.


\subsubsection{Invocation of function address \protect\(a\protect\)}
\label{\detokenize{exec/instructions:exec-invoke}}\label{\detokenize{exec/instructions:invocation-of-function-address}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-call}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[a]\) exists.

\item {} 
Let \(f\) be the {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{function instance}}}}, \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[a]\).

\item {} 
Let \([t_1^n] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^m]\) be the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(f.\hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}\).

\item {} 
Let \(t^\ast\) be the list of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} \(f.\hyperref[exec/runtime:syntax-funcinst]{\mathsf{code}}.\hyperref[syntax/modules:syntax-func]{\mathsf{locals}}\).

\item {} 
Let \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\) be the {\hyperref[\detokenize{syntax/instructions:syntax-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{expression}}}} \(f.\hyperref[exec/runtime:syntax-funcinst]{\mathsf{code}}.\hyperref[syntax/modules:syntax-func]{\mathsf{body}}\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-call}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(n\) values are on the top of the stack.

\item {} 
Pop the values \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^n\) from the stack.

\item {} 
Let \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}_0^\ast\) be the list of zero values of types \(t^\ast\).

\item {} 
Let \(F\) be the {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}} \(\{ \hyperref[exec/runtime:syntax-frame]{\mathsf{module}}~f.\hyperref[exec/runtime:syntax-funcinst]{\mathsf{module}}, \hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}~\hyperref[exec/runtime:syntax-val]{\mathit{val}}^n~\hyperref[exec/runtime:syntax-val]{\mathit{val}}_0^\ast \}\).

\item {} 
Push the activation of \(F\) with arity \(m\) to the stack.

\item {} 
Let \(L\) be the {\hyperref[\detokenize{exec/runtime:syntax-label}]{\sphinxcrossref{\DUrole{std,std-ref}{label}}}} whose arity is \(m\) and whose continuation is the end of the function.

\item {} 
{\hyperref[\detokenize{exec/instructions:exec-instr-seq-enter}]{\sphinxcrossref{\DUrole{std,std-ref}{Enter}}}} the instruction sequence \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\) with label \(L\).

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{l}
\begin{array}{lcl@{\qquad}l}
S; \hyperref[exec/runtime:syntax-val]{\mathit{val}}^n~(\hyperref[exec/runtime:syntax-invoke]{\mathsf{invoke}}~a) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S; \hyperref[exec/runtime:syntax-frame]{\mathsf{frame}}_m\{F\}~\hyperref[exec/runtime:syntax-label]{\mathsf{label}}_m\{\}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}
\end{array}
\\ \qquad
  \begin{array}[t]{@{}r@{~}l@{}}
  (\mathrel{\mbox{if}} & S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[a] = f \\
  \wedge & f.\hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}} = [t_1^n] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^m] \\
  \wedge & f.\hyperref[exec/runtime:syntax-funcinst]{\mathsf{code}} = \{ \hyperref[syntax/modules:syntax-func]{\mathsf{type}}~x, \hyperref[syntax/modules:syntax-func]{\mathsf{locals}}~t^k, \hyperref[syntax/modules:syntax-func]{\mathsf{body}}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \} \\
  \wedge & F = \{ \hyperref[exec/runtime:syntax-frame]{\mathsf{module}}~f.\hyperref[exec/runtime:syntax-funcinst]{\mathsf{module}}, ~\hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}~\hyperref[exec/runtime:syntax-val]{\mathit{val}}^n~(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~0)^k \})
  \end{array} \\
\end{array}\end{split}
\end{equation*}

\subsubsection{Returning from a function}
\label{\detokenize{exec/instructions:exec-invoke-exit}}\label{\detokenize{exec/instructions:returning-from-a-function}}
When the end of a function is reached without a jump (i.e., \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{return}}\)) or trap aborting it, then the following steps are performed.
\begin{enumerate}
\item {} 
Let \(F\) be the {\hyperref[\detokenize{exec/conventions:exec-notation-textual}]{\sphinxcrossref{\DUrole{std,std-ref}{current}}}} {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}}.

\item {} 
Let \(n\) be the arity of the activation of \(F\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, there are \(n\) values on the top of the stack.

\item {} 
Pop the results \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^n\) from the stack.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/modules:valid-func}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, the frame \(F\) is now on the top of the stack.

\item {} 
Pop the frame from the stack.

\item {} 
Push \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^n\) back to the stack.

\item {} 
Jump to the instruction after the original call.

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{lcl@{\qquad}l}
\hyperref[exec/runtime:syntax-frame]{\mathsf{frame}}_n\{F\}~\hyperref[exec/runtime:syntax-val]{\mathit{val}}^n~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& \hyperref[exec/runtime:syntax-val]{\mathit{val}}^n
\end{array}\end{split}
\end{equation*}
\index{host function}\index{store}\ignorespaces 

\subsubsection{Host Functions}
\label{\detokenize{exec/instructions:index-8}}\label{\detokenize{exec/instructions:host-functions}}\label{\detokenize{exec/instructions:exec-invoke-host}}
Invoking a {\hyperref[\detokenize{exec/runtime:syntax-hostfunc}]{\sphinxcrossref{\DUrole{std,std-ref}{host function}}}} has non-deterministic behavior.
It may either terminate with a {\hyperref[\detokenize{intro/overview:trap}]{\sphinxcrossref{\DUrole{std,std-ref}{trap}}}} or return regularly.
However, in the latter case, it must consume and produce the right number and types of WebAssembly {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} on the stack,
according to its {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}}.

A host function may also modify the {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}}.
However, all store modifications must result in an {\hyperref[\detokenize{appendix/properties:extend-store}]{\sphinxcrossref{\DUrole{std,std-ref}{extension}}}} of the original store, i.e., they must only modify mutable contents and must not have instances removed.
Furthermore, the resulting store must be {\hyperref[\detokenize{appendix/properties:valid-store}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}, i.e., all data and code in it is well-typed.
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{l}
\begin{array}{lcl@{\qquad}l}
S; \hyperref[exec/runtime:syntax-val]{\mathit{val}}^n~(\hyperref[exec/runtime:syntax-invoke]{\mathsf{invoke}}~a) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S'; \hyperref[exec/runtime:syntax-result]{\mathit{result}}
\end{array}
\\ \qquad
  \begin{array}[t]{@{}r@{~}l@{}}
  (\mathrel{\mbox{if}} & S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[a] = \{ \hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}~[t_1^n] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^m], \hyperref[exec/runtime:syntax-funcinst]{\mathsf{hostcode}}~\mathit{hf} \} \\
  \wedge & (S'; \hyperref[exec/runtime:syntax-result]{\mathit{result}}) \in \mathit{hf}(S; \hyperref[exec/runtime:syntax-val]{\mathit{val}}^n)) \\
  \end{array} \\
\begin{array}{lcl@{\qquad}l}
S; \hyperref[exec/runtime:syntax-val]{\mathit{val}}^n~(\hyperref[exec/runtime:syntax-invoke]{\mathsf{invoke}}~a) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}& S; \hyperref[exec/runtime:syntax-val]{\mathit{val}}^n~(\hyperref[exec/runtime:syntax-invoke]{\mathsf{invoke}}~a)
\end{array}
\\ \qquad
  \begin{array}[t]{@{}r@{~}l@{}}
  (\mathrel{\mbox{if}} & S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[a] = \{ \hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}~[t_1^n] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^m], \hyperref[exec/runtime:syntax-funcinst]{\mathsf{hostcode}}~\mathit{hf} \} \\
  \wedge & \bot \in \mathit{hf}(S; \hyperref[exec/runtime:syntax-val]{\mathit{val}}^n)) \\
  \end{array} \\
\end{array}\end{split}
\end{equation*}
Here, \(\mathit{hf}(S; \hyperref[exec/runtime:syntax-val]{\mathit{val}}^n)\) denotes the implementation-defined execution of host function \(\mathit{hf}\) in current store \(S\) with arguments \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^n\).
It yields a set of possible outcomes, where each element is either a pair of a modified store \(S'\) and a {\hyperref[\detokenize{exec/runtime:syntax-result}]{\sphinxcrossref{\DUrole{std,std-ref}{result}}}}
or the special value \(\bot\) indicating divergence.
A host function is non-deterministic if there is at least one argument for which the set of outcomes is not singular.

For a WebAssembly implementation to be {\hyperref[\detokenize{appendix/properties:soundness}]{\sphinxcrossref{\DUrole{std,std-ref}{sound}}}} in the presence of host functions,
every {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{host function instance}}}} must be {\hyperref[\detokenize{appendix/properties:valid-hostfuncinst}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}},
which means that it adheres to suitable pre- and post-conditions:
under a {\hyperref[\detokenize{appendix/properties:valid-store}]{\sphinxcrossref{\DUrole{std,std-ref}{valid store}}}} \(S\), and given arguments \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^n\) matching the ascribed parameter types \(t_1^n\),
executing the host function must yield a non-empty set of possible outcomes each of which is either divergence or consists of a valid store \(S'\) that is an {\hyperref[\detokenize{appendix/properties:extend-store}]{\sphinxcrossref{\DUrole{std,std-ref}{extension}}}} of \(S\) and a result matching the ascribed return types \(t_2^m\).
All these notions are made precise in the {\hyperref[\detokenize{appendix/properties:soundness}]{\sphinxcrossref{\DUrole{std,std-ref}{Appendix}}}}.

\begin{sphinxadmonition}{note}{Note:}
A host function can call back into WebAssembly by {\hyperref[\detokenize{exec/modules:exec-invocation}]{\sphinxcrossref{\DUrole{std,std-ref}{invoking}}}} a function {\hyperref[\detokenize{syntax/modules:syntax-export}]{\sphinxcrossref{\DUrole{std,std-ref}{exported}}}} from a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}.
However, the effects of any such call are subsumed by the non-deterministic behavior allowed for the host function.
\end{sphinxadmonition}

\index{expression}\index{execution!expression}\index{expression!execution}\index{abstract syntax!expression}\ignorespaces 

\subsection{Expressions}
\label{\detokenize{exec/instructions:expressions}}\label{\detokenize{exec/instructions:exec-expr}}\label{\detokenize{exec/instructions:index-9}}
An {\hyperref[\detokenize{syntax/instructions:syntax-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{expression}}}} is \sphinxstyleemphasis{evaluated} relative to a {\hyperref[\detokenize{exec/conventions:exec-notation-textual}]{\sphinxcrossref{\DUrole{std,std-ref}{current}}}} {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}} pointing to its containing {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instance}}}}.
\begin{enumerate}
\item {} 
Jump to the start of the instruction sequence \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\) of the expression.

\item {} 
Execute the instruction sequence.

\item {} 
Assert: due to {\hyperref[\detokenize{valid/instructions:valid-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, the top of the stack contains a {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{value}}}}.

\item {} 
Pop the {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{value}}}} \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\) from the stack.

\end{enumerate}

The value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\) is the result of the evaluation.
\begin{equation*}
\begin{split}\frac{
  S; F; \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast \hyperref[exec/conventions:formal-notation]{\hookrightarrow} S'; F'; \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}'^\ast
}{
  S; F; \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \hyperref[exec/conventions:formal-notation]{\hookrightarrow} S'; F'; \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}'^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}
}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
Evaluation iterates this reduction rule until reaching a value.
Expressions constituting {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}} bodies are executed during function {\hyperref[\detokenize{exec/instructions:exec-invoke}]{\sphinxcrossref{\DUrole{std,std-ref}{invocation}}}}.
\end{sphinxadmonition}


\section{Modules}
\label{\detokenize{exec/modules::doc}}\label{\detokenize{exec/modules:modules}}
For modules, the execution semantics primarily defines {\hyperref[\detokenize{exec/modules:exec-instantiation}]{\sphinxcrossref{\DUrole{std,std-ref}{instantiation}}}}, which {\hyperref[\detokenize{exec/modules:alloc}]{\sphinxcrossref{\DUrole{std,std-ref}{allocates}}}} instances for a module and its contained definitions, inititializes {\hyperref[\detokenize{syntax/modules:syntax-table}]{\sphinxcrossref{\DUrole{std,std-ref}{tables}}}} and {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memories}}}} from contained {\hyperref[\detokenize{syntax/modules:syntax-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{element}}}} and {\hyperref[\detokenize{syntax/modules:syntax-data}]{\sphinxcrossref{\DUrole{std,std-ref}{data}}}} segments, and invokes the {\hyperref[\detokenize{syntax/modules:syntax-start}]{\sphinxcrossref{\DUrole{std,std-ref}{start function}}}} if present. It also includes {\hyperref[\detokenize{exec/modules:exec-invocation}]{\sphinxcrossref{\DUrole{std,std-ref}{invocation}}}} of exported functions.

Instantiation depends on a number of auxiliary notions for {\hyperref[\detokenize{exec/modules:exec-import}]{\sphinxcrossref{\DUrole{std,std-ref}{type-checking imports}}}} and {\hyperref[\detokenize{exec/modules:alloc}]{\sphinxcrossref{\DUrole{std,std-ref}{allocating}}}} instances.

\index{external value}\index{external type}\index{validation}\index{import}\index{store}\ignorespaces 

\subsection{External Typing}
\label{\detokenize{exec/modules:index-0}}\label{\detokenize{exec/modules:external-typing}}\label{\detokenize{exec/modules:valid-externval}}
For the purpose of checking {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external values}}}} against {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}},
such values are classified by {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external types}}}}.
The following auxiliary typing rules specify this typing relation relative to a {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} \(S\) in which the referenced instances live.

\index{function type}\index{function address}\ignorespaces 

\subsubsection{\protect\(\hyperref[exec/runtime:syntax-externval]{\mathsf{func}}~a\protect\)}
\label{\detokenize{exec/modules:index-1}}\label{\detokenize{exec/modules:id1}}\label{\detokenize{exec/modules:valid-externval-func}}\begin{itemize}
\item {} 
The store entry \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[a]\) must be a {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{function instance}}}} \(\{\hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}, \dots\}\).

\item {} 
Then \(\hyperref[exec/runtime:syntax-externval]{\mathsf{func}}~a\) is valid with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[a] = \{\hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}, \dots\}
}{
  S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{func}}~a : \hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}
}\end{split}
\end{equation*}
\index{table type}\index{table address}\index{limits}\ignorespaces 

\subsubsection{\protect\(\hyperref[exec/runtime:syntax-externval]{\mathsf{table}}~a\protect\)}
\label{\detokenize{exec/modules:index-2}}\label{\detokenize{exec/modules:id2}}\label{\detokenize{exec/modules:valid-externval-table}}\begin{itemize}
\item {} 
The store entry \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[a]\) must be a {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instance}}}} \(\{\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}~(\mathit{fa}^?)^n, \hyperref[exec/runtime:syntax-tableinst]{\mathsf{max}}~m^?\}\).

\item {} 
Then \(\hyperref[exec/runtime:syntax-externval]{\mathsf{table}}~a\) is valid with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~(\{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\}~\hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}})\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  S.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[a] = \{ \hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}~(\mathit{fa}^?)^n, \hyperref[exec/runtime:syntax-tableinst]{\mathsf{max}}~m^? \}
}{
  S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{table}}~a : \hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~(\{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\}~\hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}})
}\end{split}
\end{equation*}
\index{memory type}\index{memory address}\index{limits}\ignorespaces 

\subsubsection{\protect\(\hyperref[exec/runtime:syntax-externval]{\mathsf{mem}}~a\protect\)}
\label{\detokenize{exec/modules:id3}}\label{\detokenize{exec/modules:valid-externval-mem}}\label{\detokenize{exec/modules:index-3}}\begin{itemize}
\item {} 
The store entry \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a]\) must be a {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}} \(\{\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}~b^{n\cdot64\,\mathrm{Ki}}, \hyperref[exec/runtime:syntax-meminst]{\mathsf{max}}~m^?\}\), for some \(n\).

\item {} 
Then \(\hyperref[exec/runtime:syntax-externval]{\mathsf{mem}}~a\) is valid with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~(\{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\})\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a] = \{ \hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}~b^{n\cdot64\,\mathrm{Ki}}, \hyperref[exec/runtime:syntax-meminst]{\mathsf{max}}~m^? \}
}{
  S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{mem}}~a : \hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\}
}\end{split}
\end{equation*}
\index{global type}\index{global address}\index{value type}\index{mutability}\ignorespaces 

\subsubsection{\protect\(\hyperref[exec/runtime:syntax-externval]{\mathsf{global}}~a\protect\)}
\label{\detokenize{exec/modules:valid-externval-global}}\label{\detokenize{exec/modules:id4}}\label{\detokenize{exec/modules:index-4}}\begin{itemize}
\item {} 
The store entry \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[a]\) must be a {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{global instance}}}} \(\{\hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}~(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c), \hyperref[exec/runtime:syntax-globalinst]{\mathsf{mut}}~\hyperref[syntax/types:syntax-mut]{\mathit{mut}}\}\).

\item {} 
Then \(\hyperref[exec/runtime:syntax-externval]{\mathsf{global}}~a\) is valid with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~(\hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t)\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  S.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[a] = \{ \hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}~(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c), \hyperref[exec/runtime:syntax-globalinst]{\mathsf{mut}}~\hyperref[syntax/types:syntax-mut]{\mathit{mut}} \}
}{
  S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{global}}~a : \hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~(\hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t)
}\end{split}
\end{equation*}
\index{matching|textbf}\index{external type}\ignorespaces \phantomsection\label{\detokenize{exec/modules:exec-import}}

\subsection{Import Matching}
\label{\detokenize{exec/modules:import-matching}}\label{\detokenize{exec/modules:match}}\label{\detokenize{exec/modules:exec-import}}\label{\detokenize{exec/modules:index-5}}
When {\hyperref[\detokenize{exec/modules:exec-module}]{\sphinxcrossref{\DUrole{std,std-ref}{instantiating}}}} a module,
{\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external values}}}} must be provided whose {\hyperref[\detokenize{exec/modules:valid-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{types}}}} are \sphinxstyleemphasis{matched} against the respective {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external types}}}} classifying each import.
In some cases, this allows for a simple form of subtyping, as defined below.

\index{limits}\ignorespaces 

\subsubsection{Limits}
\label{\detokenize{exec/modules:match-limits}}\label{\detokenize{exec/modules:index-6}}\label{\detokenize{exec/modules:limits}}
{\hyperref[\detokenize{syntax/types:syntax-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{Limits}}}} \(\{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n_1, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m_1^? \}\) match limits \(\{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n_2, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m_2^? \}\) if and only if:
\begin{itemize}
\item {} 
\(n_1\) is larger than or equal to \(n_2\).

\item {} 
Either:
\begin{itemize}
\item {} 
\(m_2^?\) is empty.

\end{itemize}

\item {} 
Or:
\begin{itemize}
\item {} 
Both \(m_1^?\) and \(m_2^?\) are non-empty.

\item {} 
\(m_1\) is smaller than or equal to \(m_2\).

\end{itemize}

\end{itemize}
\begin{equation*}
\begin{split}~\\[-1ex]
\frac{
  n_1 \geq n_2
}{
  \hyperref[exec/modules:match-limits]{\vdash} \{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n_1, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m_1^? \} \hyperref[exec/modules:match]{\leq} \{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n_2, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~\epsilon \}
}
\quad
\frac{
  n_1 \geq n_2
  \qquad
  m_1 \leq m_2
}{
  \hyperref[exec/modules:match-limits]{\vdash} \{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n_1, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m_1 \} \hyperref[exec/modules:match]{\leq} \{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n_2, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m_2 \}
}\end{split}
\end{equation*}\phantomsection\label{\detokenize{exec/modules:match-externtype}}
\index{function type}\ignorespaces 

\subsubsection{Functions}
\label{\detokenize{exec/modules:functions}}\label{\detokenize{exec/modules:match-functype}}\label{\detokenize{exec/modules:index-7}}
An {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}_1\) matches \(\hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}_2\) if and only if:
\begin{itemize}
\item {} 
Both \(\hyperref[syntax/types:syntax-functype]{\mathit{functype}}_1\) and \(\hyperref[syntax/types:syntax-functype]{\mathit{functype}}_2\) are the same.

\end{itemize}
\begin{equation*}
\begin{split}~\\[-1ex]
\frac{
}{
  \hyperref[exec/modules:match-externtype]{\vdash} \hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}} \hyperref[exec/modules:match]{\leq} \hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}
}\end{split}
\end{equation*}
\index{table type}\index{limits}\index{element type}\ignorespaces 

\subsubsection{Tables}
\label{\detokenize{exec/modules:index-8}}\label{\detokenize{exec/modules:tables}}\label{\detokenize{exec/modules:match-tabletype}}
An {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}_1~\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}}_1)\) matches \(\hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}_2~\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}}_2)\) if and only if:
\begin{itemize}
\item {} 
Limits \(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}_1\) {\hyperref[\detokenize{exec/modules:match-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{match}}}} \(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}_2\).

\item {} 
Both \(\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}}_1\) and \(\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}}_2\) are the same.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \hyperref[exec/modules:match-limits]{\vdash} \hyperref[syntax/types:syntax-limits]{\mathit{limits}}_1 \hyperref[exec/modules:match]{\leq} \hyperref[syntax/types:syntax-limits]{\mathit{limits}}_2
}{
  \hyperref[exec/modules:match-externtype]{\vdash} \hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}_1~\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}}) \hyperref[exec/modules:match]{\leq} \hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}_2~\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}})
}\end{split}
\end{equation*}
\index{memory type}\index{limits}\ignorespaces 

\subsubsection{Memories}
\label{\detokenize{exec/modules:match-memtype}}\label{\detokenize{exec/modules:memories}}\label{\detokenize{exec/modules:index-9}}
An {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\hyperref[syntax/types:syntax-limits]{\mathit{limits}}_1\) matches \(\hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\hyperref[syntax/types:syntax-limits]{\mathit{limits}}_2\) if and only if:
\begin{itemize}
\item {} 
Limits \(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}_1\) {\hyperref[\detokenize{exec/modules:match-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{match}}}} \(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}_2\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \hyperref[exec/modules:match-limits]{\vdash} \hyperref[syntax/types:syntax-limits]{\mathit{limits}}_1 \hyperref[exec/modules:match]{\leq} \hyperref[syntax/types:syntax-limits]{\mathit{limits}}_2
}{
  \hyperref[exec/modules:match-externtype]{\vdash} \hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\hyperref[syntax/types:syntax-limits]{\mathit{limits}}_1 \hyperref[exec/modules:match]{\leq} \hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\hyperref[syntax/types:syntax-limits]{\mathit{limits}}_2
}\end{split}
\end{equation*}
\index{global type}\index{value type}\index{mutability}\ignorespaces 

\subsubsection{Globals}
\label{\detokenize{exec/modules:match-globaltype}}\label{\detokenize{exec/modules:index-10}}\label{\detokenize{exec/modules:globals}}
An {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}_1\) matches \(\hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}_2\) if and only if:
\begin{itemize}
\item {} 
Both \(\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}_1\) and \(\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}_2\) are the same.

\end{itemize}
\begin{equation*}
\begin{split}~\\[-1ex]
\frac{
}{
  \hyperref[exec/modules:match-externtype]{\vdash} \hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}} \hyperref[exec/modules:match]{\leq} \hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}
}\end{split}
\end{equation*}
\index{allocation|textbf}\index{store}\index{address}\ignorespaces 

\subsection{Allocation}
\label{\detokenize{exec/modules:index-11}}\label{\detokenize{exec/modules:alloc}}\label{\detokenize{exec/modules:allocation}}
New instances of {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{functions}}}}, {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{tables}}}}, {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memories}}}}, and {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{globals}}}} are \sphinxstyleemphasis{allocated} in a {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} \(S\), as defined by the following auxiliary functions.

\index{function}\index{function instance}\index{function address}\index{module instance}\index{function type}\ignorespaces 

\subsubsection{Functions}
\label{\detokenize{exec/modules:index-12}}\label{\detokenize{exec/modules:alloc-func}}\label{\detokenize{exec/modules:id5}}\begin{enumerate}
\item {} 
Let \(\hyperref[syntax/modules:syntax-func]{\mathit{func}}\) be the {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}} to allocate and \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\) its {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instance}}}}.

\item {} 
Let \(a\) be the first free {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{function address}}}} in \(S\).

\item {} 
Let \(\hyperref[syntax/types:syntax-functype]{\mathit{functype}}\) be the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{types}}[\hyperref[syntax/modules:syntax-func]{\mathit{func}}.\hyperref[syntax/modules:syntax-func]{\mathsf{type}}]\).

\item {} 
Let \(\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}\) be the {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{function instance}}}} \(\{ \hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}, \hyperref[exec/runtime:syntax-funcinst]{\mathsf{module}}~\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}, \hyperref[exec/runtime:syntax-funcinst]{\mathsf{code}}~\hyperref[syntax/modules:syntax-func]{\mathit{func}} \}\).

\item {} 
Append \(\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}\) to the \(\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}\) of \(S\).

\item {} 
Return \(a\).

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{rlll}
\hyperref[exec/modules:alloc-func]{\mathrm{allocfunc}}(S, \hyperref[syntax/modules:syntax-func]{\mathit{func}}, \hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}) &=& S', \hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}} \\[1ex]
\mbox{where:} \hfill \\
\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}} &=& |S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}| \\
\hyperref[syntax/types:syntax-functype]{\mathit{functype}} &=& \hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{types}}[\hyperref[syntax/modules:syntax-func]{\mathit{func}}.\hyperref[syntax/modules:syntax-func]{\mathsf{type}}] \\
\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}} &=& \{ \hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}, \hyperref[exec/runtime:syntax-funcinst]{\mathsf{module}}~\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}, \hyperref[exec/runtime:syntax-funcinst]{\mathsf{code}}~\hyperref[syntax/modules:syntax-func]{\mathit{func}} \} \\
S' &=& S \hyperref[syntax/conventions:notation-compose]{\oplus} \{\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}~\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}\} \\
\end{array}\end{split}
\end{equation*}
\index{host function}\index{function instance}\index{function address}\index{function type}\ignorespaces 

\subsubsection{Host Functions}
\label{\detokenize{exec/modules:host-functions}}\label{\detokenize{exec/modules:index-13}}\label{\detokenize{exec/modules:alloc-hostfunc}}\begin{enumerate}
\item {} 
Let \(\hyperref[exec/runtime:syntax-hostfunc]{\mathit{hostfunc}}\) be the {\hyperref[\detokenize{exec/runtime:syntax-hostfunc}]{\sphinxcrossref{\DUrole{std,std-ref}{host function}}}} to allocate and \(\hyperref[syntax/types:syntax-functype]{\mathit{functype}}\) its {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}}.

\item {} 
Let \(a\) be the first free {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{function address}}}} in \(S\).

\item {} 
Let \(\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}\) be the {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{function instance}}}} \(\{ \hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}, \hyperref[exec/runtime:syntax-funcinst]{\mathsf{hostcode}}~\hyperref[exec/runtime:syntax-hostfunc]{\mathit{hostfunc}} \}\).

\item {} 
Append \(\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}\) to the \(\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}\) of \(S\).

\item {} 
Return \(a\).

\end{enumerate}
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{rlll}
\hyperref[exec/modules:alloc-hostfunc]{\mathrm{allochostfunc}}(S, \hyperref[syntax/types:syntax-functype]{\mathit{functype}}, \hyperref[exec/runtime:syntax-hostfunc]{\mathit{hostfunc}}) &=& S', \hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}} \\[1ex]
\mbox{where:} \hfill \\
\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}} &=& |S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}| \\
\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}} &=& \{ \hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}, \hyperref[exec/runtime:syntax-funcinst]{\mathsf{hostcode}}~\hyperref[exec/runtime:syntax-hostfunc]{\mathit{hostfunc}} \} \\
S' &=& S \hyperref[syntax/conventions:notation-compose]{\oplus} \{\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}~\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}\} \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
Host functions are never allocated by the WebAssembly semantics itself,
but may be allocated by the {\hyperref[\detokenize{intro/overview:embedder}]{\sphinxcrossref{\DUrole{std,std-ref}{embedder}}}}.
\end{sphinxadmonition}

\index{table}\index{table instance}\index{table address}\index{table type}\index{limits}\ignorespaces 

\subsubsection{Tables}
\label{\detokenize{exec/modules:index-14}}\label{\detokenize{exec/modules:alloc-table}}\label{\detokenize{exec/modules:id6}}\begin{enumerate}
\item {} 
Let \(\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}\) be the {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table type}}}} to allocate.

\item {} 
Let \((\{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\}~\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}})\) be the structure of {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table type}}}} \(\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}\).

\item {} 
Let \(a\) be the first free {\hyperref[\detokenize{exec/runtime:syntax-tableaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{table address}}}} in \(S\).

\item {} 
Let \(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}\) be the {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instance}}}} \(\{ \hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}~(\epsilon)^n, \hyperref[exec/runtime:syntax-tableinst]{\mathsf{max}}~m^? \}\) with \(n\) empty elements.

\item {} 
Append \(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}\) to the \(\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}\) of \(S\).

\item {} 
Return \(a\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{rlll}
\hyperref[exec/modules:alloc-table]{\mathrm{alloctable}}(S, \hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}) &=& S', \hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}} \\[1ex]
\mbox{where:} \hfill \\
\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}} &=& \{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\}~\hyperref[syntax/types:syntax-elemtype]{\mathit{elemtype}} \\
\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}} &=& |S.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}| \\
\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}} &=& \{ \hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}~(\epsilon)^n, \hyperref[exec/runtime:syntax-tableinst]{\mathsf{max}}~m^? \} \\
S' &=& S \hyperref[syntax/conventions:notation-compose]{\oplus} \{\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}~\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}\} \\
\end{array}\end{split}
\end{equation*}
\index{memory}\index{memory instance}\index{memory address}\index{memory type}\index{limits}\index{byte}\ignorespaces 

\subsubsection{Memories}
\label{\detokenize{exec/modules:alloc-mem}}\label{\detokenize{exec/modules:id7}}\label{\detokenize{exec/modules:index-15}}\begin{enumerate}
\item {} 
Let \(\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}\) be the {\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory type}}}} to allocate.

\item {} 
Let \(\{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\}\) be the structure of {\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory type}}}} \(\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}\).

\item {} 
Let \(a\) be the first free {\hyperref[\detokenize{exec/runtime:syntax-memaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{memory address}}}} in \(S\).

\item {} 
Let \(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}\) be the {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}} \(\{ \hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}~(\def\mathdef1595#1{\mathtt{0x#1}}\mathdef1595{00})^{n \cdot 64\,\mathrm{Ki}}, \hyperref[exec/runtime:syntax-meminst]{\mathsf{max}}~m^? \}\) that contains \(n\) pages of zeroed {\hyperref[\detokenize{syntax/values:syntax-byte}]{\sphinxcrossref{\DUrole{std,std-ref}{bytes}}}}.

\item {} 
Append \(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}\) to the \(\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}\) of \(S\).

\item {} 
Return \(a\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{rlll}
\hyperref[exec/modules:alloc-mem]{\mathrm{allocmem}}(S, \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}) &=& S', \hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}} \\[1ex]
\mbox{where:} \hfill \\
\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}} &=& \{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\} \\
\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}} &=& |S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}| \\
\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}} &=& \{ \hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}~(\def\mathdef1596#1{\mathtt{0x#1}}\mathdef1596{00})^{n \cdot 64\,\mathrm{Ki}}, \hyperref[exec/runtime:syntax-meminst]{\mathsf{max}}~m^? \} \\
S' &=& S \hyperref[syntax/conventions:notation-compose]{\oplus} \{\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}~\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}\} \\
\end{array}\end{split}
\end{equation*}
\index{global}\index{global instance}\index{global address}\index{global type}\index{value type}\index{mutability}\index{value}\ignorespaces 

\subsubsection{Globals}
\label{\detokenize{exec/modules:alloc-global}}\label{\detokenize{exec/modules:index-16}}\label{\detokenize{exec/modules:id8}}\begin{enumerate}
\item {} 
Let \(\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}\) be the {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global type}}}} to allocate and \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\) the {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{value}}}} to initialize the global with.

\item {} 
Let \(\hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t\) be the structure of {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global type}}}} \(\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}\).

\item {} 
Let \(a\) be the first free {\hyperref[\detokenize{exec/runtime:syntax-globaladdr}]{\sphinxcrossref{\DUrole{std,std-ref}{global address}}}} in \(S\).

\item {} 
Let \(\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}\) be the {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{global instance}}}} \(\{ \hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}~\hyperref[exec/runtime:syntax-val]{\mathit{val}}, \hyperref[exec/runtime:syntax-globalinst]{\mathsf{mut}}~\hyperref[syntax/types:syntax-mut]{\mathit{mut}} \}\).

\item {} 
Append \(\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}\) to the \(\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}\) of \(S\).

\item {} 
Return \(a\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{rlll}
\hyperref[exec/modules:alloc-global]{\mathrm{allocglobal}}(S, \hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}, \hyperref[exec/runtime:syntax-val]{\mathit{val}}) &=& S', \hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}} \\[1ex]
\mbox{where:} \hfill \\
\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}} &=& \hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t \\
\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}} &=& |S.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}| \\
\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}} &=& \{ \hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}~\hyperref[exec/runtime:syntax-val]{\mathit{val}}, \hyperref[exec/runtime:syntax-globalinst]{\mathsf{mut}}~\hyperref[syntax/types:syntax-mut]{\mathit{mut}} \} \\
S' &=& S \hyperref[syntax/conventions:notation-compose]{\oplus} \{\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}~\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}\} \\
\end{array}\end{split}
\end{equation*}
\index{table}\index{table instance}\index{table address}\index{grow}\index{limits}\ignorespaces 

\subsubsection{Growing tables}
\label{\detokenize{exec/modules:grow-table}}\label{\detokenize{exec/modules:growing-tables}}\label{\detokenize{exec/modules:index-17}}\begin{enumerate}
\item {} 
Let \(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}\) be the {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instance}}}} to grow and \(n\) the number of elements by which to grow it.

\item {} 
Let \(\mathit{len}\) be \(n\) added to the length of \(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}\).

\item {} 
If \(\mathit{len}\) is larger than \(2^{32}\), then fail.

\item {} 
If \(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{max}}\) is not empty and smaller than \(\mathit{len}\), then fail.

\item {} 
Append \(n\) empty elements to \(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{rllll}
\hyperref[exec/modules:grow-table]{\mathrm{growtable}}(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}, n) &=& \hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}} \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}} = \hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}~(\epsilon)^n \\
  && (
    \begin{array}[t]{@{}r@{~}l@{}}
    \mathrel{\mbox{if}} & \mathit{len} = n + |\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}| \\
    \wedge & \mathit{len} \leq 2^{32} \\
    \wedge & (\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{max}} = \epsilon \vee \mathit{len} \leq \hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{max}})) \\
    \end{array} \\
\end{array}\end{split}
\end{equation*}
\index{memory}\index{memory instance}\index{memory address}\index{grow}\index{limits}\ignorespaces 

\subsubsection{Growing memories}
\label{\detokenize{exec/modules:index-18}}\label{\detokenize{exec/modules:grow-mem}}\label{\detokenize{exec/modules:growing-memories}}\begin{enumerate}
\item {} 
Let \(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}\) be the {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}} to grow and \(n\) the number of {\hyperref[\detokenize{exec/runtime:page-size}]{\sphinxcrossref{\DUrole{std,std-ref}{pages}}}} by which to grow it.

\item {} 
Assert: The length of \(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}\) is divisible by the {\hyperref[\detokenize{exec/runtime:page-size}]{\sphinxcrossref{\DUrole{std,std-ref}{page size}}}} \(64\,\mathrm{Ki}\).

\item {} 
Let \(\mathit{len}\) be \(n\) added to the length of \(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}\) divided by the {\hyperref[\detokenize{exec/runtime:page-size}]{\sphinxcrossref{\DUrole{std,std-ref}{page size}}}} \(64\,\mathrm{Ki}\).

\item {} 
If \(\mathit{len}\) is larger than \(2^{16}\), then fail.

\item {} 
If \(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{max}}\) is not empty and its value is smaller than \(\mathit{len}\), then fail.

\item {} 
Append \(n\) times \(64\,\mathrm{Ki}\) {\hyperref[\detokenize{syntax/values:syntax-byte}]{\sphinxcrossref{\DUrole{std,std-ref}{bytes}}}} with value \(\def\mathdef1597#1{\mathtt{0x#1}}\mathdef1597{00}\) to \(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{rllll}
\hyperref[exec/modules:grow-mem]{\mathrm{growmem}}(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}, n) &=& \hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}} \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \hyperref[exec/runtime:syntax-meminst]{\mathsf{data}} = \hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}~(\def\mathdef1598#1{\mathtt{0x#1}}\mathdef1598{00})^{n \cdot 64\,\mathrm{Ki}} \\
  && (
    \begin{array}[t]{@{}r@{~}l@{}}
    \mathrel{\mbox{if}} & \mathit{len} = n + |\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}| / 64\,\mathrm{Ki} \\
    \wedge & \mathit{len} \leq 2^{16} \\
    \wedge & (\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{max}} = \epsilon \vee \mathit{len} \leq \hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{max}})) \\
    \end{array} \\
\end{array}\end{split}
\end{equation*}
\index{module}\index{module instance}\index{function instance}\index{table instance}\index{memory instance}\index{global instance}\index{export instance}\index{function address}\index{table address}\index{memory address}\index{global address}\index{function index}\index{table index}\index{memory index}\index{global index}\index{type}\index{function}\index{table}\index{memory}\index{global}\index{import}\index{export}\index{external value}\index{external type}\index{matching}\ignorespaces 

\subsubsection{Modules}
\label{\detokenize{exec/modules:alloc-module}}\label{\detokenize{exec/modules:index-19}}\label{\detokenize{exec/modules:id9}}
The allocation function for {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{modules}}}} requires a suitable list of {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external values}}}} that are assumed to {\hyperref[\detokenize{exec/modules:match-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{match}}}} the {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{import}}}} vector of the module,
and a list of initialization {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} for the module’s {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{globals}}}}.

1. Let \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}\) be the {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}} to allocate and \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{im}}^\ast\) the vector of {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external values}}}} providing the module’s imports,
and \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast\) the initialization {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} of the module’s {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{globals}}}}.
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
For each {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}} \(\hyperref[syntax/modules:syntax-func]{\mathit{func}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{funcs}}\), do:
\begin{enumerate}
\item {} 
Let \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}_i\) be the {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{function address}}}} resulting from {\hyperref[\detokenize{exec/modules:alloc-func}]{\sphinxcrossref{\DUrole{std,std-ref}{allocating}}}} \(\hyperref[syntax/modules:syntax-func]{\mathit{func}}_i\) for the {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instance}}}} \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\) defined below.

\end{enumerate}

\item {} 
For each {\hyperref[\detokenize{syntax/modules:syntax-table}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}} \(\hyperref[syntax/modules:syntax-table]{\mathit{table}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{tables}}\), do:
\begin{enumerate}
\item {} 
Let \(\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}_i\) be the {\hyperref[\detokenize{exec/runtime:syntax-tableaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{table address}}}} resulting from {\hyperref[\detokenize{exec/modules:alloc-table}]{\sphinxcrossref{\DUrole{std,std-ref}{allocating}}}} \(\hyperref[syntax/modules:syntax-table]{\mathit{table}}_i.\hyperref[syntax/modules:syntax-table]{\mathsf{type}}\).

\end{enumerate}

\item {} 
For each {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memory}}}} \(\hyperref[syntax/modules:syntax-mem]{\mathit{mem}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{mems}}\), do:
\begin{enumerate}
\item {} 
Let \(\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}_i\) be the {\hyperref[\detokenize{exec/runtime:syntax-memaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{memory address}}}} resulting from {\hyperref[\detokenize{exec/modules:alloc-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{allocating}}}} \(\hyperref[syntax/modules:syntax-mem]{\mathit{mem}}_i.\hyperref[syntax/modules:syntax-mem]{\mathsf{type}}\).

\end{enumerate}

\item {} 
For each {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}} \(\hyperref[syntax/modules:syntax-global]{\mathit{global}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{globals}}\), do:
\begin{enumerate}
\item {} 
Let \(\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}_i\) be the {\hyperref[\detokenize{exec/runtime:syntax-globaladdr}]{\sphinxcrossref{\DUrole{std,std-ref}{global address}}}} resulting from {\hyperref[\detokenize{exec/modules:alloc-global}]{\sphinxcrossref{\DUrole{std,std-ref}{allocating}}}} \(\hyperref[syntax/modules:syntax-global]{\mathit{global}}_i.\hyperref[syntax/modules:syntax-global]{\mathsf{type}}\) with initializer value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast[i]\).

\end{enumerate}

\item {} 
Let \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}^\ast\) be the the concatenation of the {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{function addresses}}}} \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}_i\) in index order.

\item {} 
Let \(\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}^\ast\) be the the concatenation of the {\hyperref[\detokenize{exec/runtime:syntax-tableaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{table addresses}}}} \(\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}_i\) in index order.

\item {} 
Let \(\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}^\ast\) be the the concatenation of the {\hyperref[\detokenize{exec/runtime:syntax-memaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{memory addresses}}}} \(\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}_i\) in index order.

\item {} 
Let \(\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}^\ast\) be the the concatenation of the {\hyperref[\detokenize{exec/runtime:syntax-globaladdr}]{\sphinxcrossref{\DUrole{std,std-ref}{global addresses}}}} \(\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}_i\) in index order.

\item {} 
Let \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}_{\mathrm{mod}}^\ast\) be the list of {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{function addresses}}}} extracted from \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{im}}^\ast\), concatenated with \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}^\ast\).

\item {} 
Let \(\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}_{\mathrm{mod}}^\ast\) be the list of {\hyperref[\detokenize{exec/runtime:syntax-tableaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{table addresses}}}} extracted from \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{im}}^\ast\), concatenated with \(\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}^\ast\).

\item {} 
Let \(\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}_{\mathrm{mod}}^\ast\) be the list of {\hyperref[\detokenize{exec/runtime:syntax-memaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{memory addresses}}}} extracted from \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{im}}^\ast\), concatenated with \(\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}^\ast\).

\item {} 
Let \(\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}_{\mathrm{mod}}^\ast\) be the list of {\hyperref[\detokenize{exec/runtime:syntax-globaladdr}]{\sphinxcrossref{\DUrole{std,std-ref}{global addresses}}}} extracted from \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{im}}^\ast\), concatenated with \(\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}^\ast\).

\item {} 
For each {\hyperref[\detokenize{syntax/modules:syntax-export}]{\sphinxcrossref{\DUrole{std,std-ref}{export}}}} \(\hyperref[syntax/modules:syntax-export]{\mathit{export}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{exports}}\), do:
\begin{enumerate}
\item {} 
If \(\hyperref[syntax/modules:syntax-export]{\mathit{export}}_i\) is a function export for {\hyperref[\detokenize{syntax/modules:syntax-funcidx}]{\sphinxcrossref{\DUrole{std,std-ref}{function index}}}} \(x\), then let \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_i\) be the {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{func}}~(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}_{\mathrm{mod}}^\ast[x])\).

\item {} 
Else, if \(\hyperref[syntax/modules:syntax-export]{\mathit{export}}_i\) is a table export for {\hyperref[\detokenize{syntax/modules:syntax-tableidx}]{\sphinxcrossref{\DUrole{std,std-ref}{table index}}}} \(x\), then let \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_i\) be the {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{table}}~(\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}_{\mathrm{mod}}^\ast[x])\).

\item {} 
Else, if \(\hyperref[syntax/modules:syntax-export]{\mathit{export}}_i\) is a memory export for {\hyperref[\detokenize{syntax/modules:syntax-memidx}]{\sphinxcrossref{\DUrole{std,std-ref}{memory index}}}} \(x\), then let \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_i\) be the {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{mem}}~(\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}_{\mathrm{mod}}^\ast[x])\).

\item {} 
Else, if \(\hyperref[syntax/modules:syntax-export]{\mathit{export}}_i\) is a global export for {\hyperref[\detokenize{syntax/modules:syntax-globalidx}]{\sphinxcrossref{\DUrole{std,std-ref}{global index}}}} \(x\), then let \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_i\) be the {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{global}}~(\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}_{\mathrm{mod}}^\ast[x])\).

\item {} 
Let \(\hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}_i\) be the {\hyperref[\detokenize{exec/runtime:syntax-exportinst}]{\sphinxcrossref{\DUrole{std,std-ref}{export instance}}}} \(\{\hyperref[exec/runtime:syntax-exportinst]{\mathsf{name}}~(\hyperref[syntax/modules:syntax-export]{\mathit{export}}_i.\hyperref[syntax/modules:syntax-export]{\mathsf{name}}), \hyperref[exec/runtime:syntax-exportinst]{\mathsf{value}}~\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_i\}\).

\end{enumerate}

\item {} 
Let \(\hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}^\ast\) be the the concatenation of the {\hyperref[\detokenize{exec/runtime:syntax-exportinst}]{\sphinxcrossref{\DUrole{std,std-ref}{export instances}}}} \(\hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}_i\) in index order.

\item {} 
Let \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\) be the {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instance}}}} \(\{\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{types}}~(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{types}}),\) \(\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}}~\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}_{\mathrm{mod}}^\ast,\) \(\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{tableaddrs}}~\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}_{\mathrm{mod}}^\ast,\) \(\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}~\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}_{\mathrm{mod}}^\ast,\) \(\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{globaladdrs}}~\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}_{\mathrm{mod}}^\ast,\) \(\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{exports}}~\hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}^\ast\}\).

\item {} 
Return \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\).

\end{enumerate}
\begin{equation*}
\begin{split}~\\
\begin{array}{rlll}
\hyperref[exec/modules:alloc-module]{\mathrm{allocmodule}}(S, \hyperref[syntax/modules:syntax-module]{\mathit{module}}, \hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{im}}^\ast, \hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast) &=& S', \hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}    \end{array}\end{split}
\end{equation*}
where:
\begin{equation*}
\begin{split}\begin{array}{rlll}
\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}} &=& \{~
  \begin{array}[t]{@{}l@{}}
  \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{types}}~\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{types}}, \\
  \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}}~\hyperref[exec/runtime:syntax-externval]{\mathrm{funcs}}(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{im}}^\ast)~\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}^\ast, \\
  \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{tableaddrs}}~\hyperref[exec/runtime:syntax-externval]{\mathrm{tables}}(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{im}}^\ast)~\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}^\ast, \\
  \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}~\hyperref[exec/runtime:syntax-externval]{\mathrm{mems}}(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{im}}^\ast)~\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}^\ast, \\
  \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{globaladdrs}}~\hyperref[exec/runtime:syntax-externval]{\mathrm{globals}}(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{im}}^\ast)~\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}^\ast, \\
  \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{exports}}~\hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}^\ast ~\}
  \end{array} \\[1ex]
S_1, \hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}^\ast &=& \hyperref[exec/modules:alloc-func]{\mathrm{allocfunc}}^\ast(S, \hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{funcs}}, \hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}) \\
S_2, \hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}^\ast &=& \hyperref[exec/modules:alloc-table]{\mathrm{alloctable}}^\ast(S_1, (\hyperref[syntax/modules:syntax-table]{\mathit{table}}.\hyperref[syntax/modules:syntax-table]{\mathsf{type}})^\ast)
  \qquad\qquad\qquad~ (\mathrel{\mbox{where}} \hyperref[syntax/modules:syntax-table]{\mathit{table}}^\ast = \hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{tables}}) \\
S_3, \hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}^\ast &=& \hyperref[exec/modules:alloc-mem]{\mathrm{allocmem}}^\ast(S_2, (\hyperref[syntax/modules:syntax-mem]{\mathit{mem}}.\hyperref[syntax/modules:syntax-mem]{\mathsf{type}})^\ast)
  \qquad\qquad\qquad~ (\mathrel{\mbox{where}} \hyperref[syntax/modules:syntax-mem]{\mathit{mem}}^\ast = \hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{mems}}) \\
S', \hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}^\ast &=& \hyperref[exec/modules:alloc-global]{\mathrm{allocglobal}}^\ast(S_3, (\hyperref[syntax/modules:syntax-global]{\mathit{global}}.\hyperref[syntax/modules:syntax-global]{\mathsf{type}})^\ast, \hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast)
  \qquad\quad~ (\mathrel{\mbox{where}} \hyperref[syntax/modules:syntax-global]{\mathit{global}}^\ast = \hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{globals}}) \\
\hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}^\ast &=& \{ \hyperref[exec/runtime:syntax-exportinst]{\mathsf{name}}~(\hyperref[syntax/modules:syntax-export]{\mathit{export}}.\hyperref[syntax/modules:syntax-export]{\mathsf{name}}), \hyperref[exec/runtime:syntax-exportinst]{\mathsf{value}}~\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{ex}} \}^\ast
  \quad (\mathrel{\mbox{where}} \hyperref[syntax/modules:syntax-export]{\mathit{export}}^\ast = \hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{exports}}) \\[1ex]
\hyperref[exec/runtime:syntax-externval]{\mathrm{funcs}}(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{ex}}^\ast) &=& (\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}}[x])^\ast
  \qquad~ (\mathrel{\mbox{where}} x^\ast = \hyperref[syntax/modules:syntax-exportdesc]{\mathrm{funcs}}(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{exports}})) \\
\hyperref[exec/runtime:syntax-externval]{\mathrm{tables}}(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{ex}}^\ast) &=& (\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{tableaddrs}}[x])^\ast
  \qquad (\mathrel{\mbox{where}} x^\ast = \hyperref[syntax/modules:syntax-exportdesc]{\mathrm{tables}}(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{exports}})) \\
\hyperref[exec/runtime:syntax-externval]{\mathrm{mems}}(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{ex}}^\ast) &=& (\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[x])^\ast
  \qquad (\mathrel{\mbox{where}} x^\ast = \hyperref[syntax/modules:syntax-exportdesc]{\mathrm{mems}}(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{exports}})) \\
\hyperref[exec/runtime:syntax-externval]{\mathrm{globals}}(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_{\mathrm{ex}}^\ast) &=& (\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{globaladdrs}}[x])^\ast
  \qquad\!\!\! (\mathrel{\mbox{where}} x^\ast = \hyperref[syntax/modules:syntax-exportdesc]{\mathrm{globals}}(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{exports}})) \\
\end{array}\end{split}
\end{equation*}
Here, the notation \(\mathrm{allocx}^\ast\) is shorthand for multiple {\hyperref[\detokenize{exec/modules:alloc}]{\sphinxcrossref{\DUrole{std,std-ref}{allocations}}}} of object kind \(X\), defined as follows:
\begin{equation*}
\begin{split}\begin{array}{rlll}
\mathrm{allocx}^\ast(S_0, X^n, \dots) &=& S_n, a^n \\[1ex]
\mbox{where for all $i < n$:} \hfill \\
S_{i+1}, a^n[i] &=& \mathrm{allocx}(S_i, X^n[i], \dots)
\end{array}\end{split}
\end{equation*}
Moreover, if the dots \(\dots\) are a sequence \(A^n\) (as for globals), then the elements of this sequence are passed to the allocation function pointwise.

\begin{sphinxadmonition}{note}{Note:}
The definition of module allocation is mutually recursive with the allocation of its associated functions, because the resulting module instance \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\) is passed to the function allocator as an argument, in order to form the necessary closures.
In an implementation, this recursion is easily unraveled by mutating one or the other in a secondary step.
\end{sphinxadmonition}

\index{instantiation|textbf}\index{module}\index{instance}\index{store}\index{trap}\ignorespaces \phantomsection\label{\detokenize{exec/modules:exec-module}}

\subsection{Instantiation}
\label{\detokenize{exec/modules:exec-module}}\label{\detokenize{exec/modules:index-20}}\label{\detokenize{exec/modules:instantiation}}\label{\detokenize{exec/modules:exec-instantiation}}
Given a {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} \(S\), a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}} \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}\) is instantiated with a list of {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external values}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^n\) supplying the required imports as follows.

Instantiation checks that the module is {\hyperref[\detokenize{valid/index:valid}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} and the provided imports {\hyperref[\detokenize{exec/modules:match-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{match}}}} the declared types,
and may \sphinxstyleemphasis{fail} with an error otherwise.
Instantiation can also result in a {\hyperref[\detokenize{intro/overview:trap}]{\sphinxcrossref{\DUrole{std,std-ref}{trap}}}} from executing the start function.
It is up to the {\hyperref[\detokenize{intro/overview:embedder}]{\sphinxcrossref{\DUrole{std,std-ref}{embedder}}}} to define how such conditions are reported.
\begin{enumerate}
\item {} 
If \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}\) is not {\hyperref[\detokenize{valid/modules:valid-module}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}, then:
\begin{enumerate}
\item {} 
Fail.

\end{enumerate}

\item {} 
Assert: \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}\) is {\hyperref[\detokenize{valid/modules:valid-module}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external types}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}_{\mathrm{im}}^m\) classifying its {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}}.

\item {} 
If the number \(m\) of {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}} is not equal to the number \(n\) of provided {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external values}}}}, then:
\begin{enumerate}
\item {} 
Fail.

\end{enumerate}

\item {} 
For each {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_i\) in \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^n\) and {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}'_i\) in \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}_{\mathrm{im}}^n\), do:
\begin{enumerate}
\item {} 
If \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}_i\) is not {\hyperref[\detokenize{exec/modules:valid-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with an {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}_i\) in store \(S\), then:
\begin{enumerate}
\item {} 
Fail.

\end{enumerate}

\item {} 
If \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}_i\) does not {\hyperref[\detokenize{exec/modules:match-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{match}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}'_i\), then:
\begin{enumerate}
\item {} 
Fail.

\end{enumerate}

\end{enumerate}

\end{enumerate}
\phantomsection\label{\detokenize{exec/modules:exec-initvals}}\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Let \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast\) be the vector of {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}} initialization {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} determined by \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}\) and \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^n\). These may be calculated as follows.
\begin{enumerate}
\item {} 
Let \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}_{\mathrm{im}}\) be the auxiliary module {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{instance}}}} \(\{\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{globaladdrs}}~\hyperref[exec/runtime:syntax-externval]{\mathrm{globals}}(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^n)\}\) that only consists of the imported globals.

\item {} 
Let \(F_{\mathrm{im}}\) be the auxiliary {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}} \(\{ \hyperref[exec/runtime:syntax-frame]{\mathsf{module}}~\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}_{\mathrm{im}}, \hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}~\epsilon \}\).

\item {} 
Push the frame \(F_{\mathrm{im}}\) to the stack.

\item {} 
For each {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}} \(\hyperref[syntax/modules:syntax-global]{\mathit{global}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{globals}}\), do:
\begin{enumerate}
\item {} 
Let \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}_i\) be the result of {\hyperref[\detokenize{exec/instructions:exec-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{evaluating}}}} the initializer expression \(\hyperref[syntax/modules:syntax-global]{\mathit{global}}_i.\hyperref[syntax/modules:syntax-global]{\mathsf{init}}\).

\end{enumerate}

\item {} 
Assert: due to {\hyperref[\detokenize{valid/modules:valid-module}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, the frame \(F_{\mathrm{im}}\) is now on the top of the stack.

\item {} 
Pop the frame \(F_{\mathrm{im}}\) from the stack.

\end{enumerate}

\item {} 
Let \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\) be a new module instance {\hyperref[\detokenize{exec/modules:alloc-module}]{\sphinxcrossref{\DUrole{std,std-ref}{allocated}}}} from \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}\) in store \(S\) with imports \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^n\) and global initializer values \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast\), and let \(S'\) be the extended store produced by module allocation.

\item {} 
Let \(F\) be the {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}} \(\{ \hyperref[exec/runtime:syntax-frame]{\mathsf{module}}~\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}, \hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}~\epsilon \}\).

\item {} 
Push the frame \(F\) to the stack.

\item {} 
For each {\hyperref[\detokenize{syntax/modules:syntax-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{element segment}}}} \(\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{elem}}\), do:
\begin{enumerate}
\item {} 
Let \(\mathit{eoval}_i\) be the result of {\hyperref[\detokenize{exec/instructions:exec-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{evaluating}}}} the expression \(\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}_i.\hyperref[syntax/modules:syntax-elem]{\mathsf{offset}}\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/modules:valid-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(\mathit{eoval}_i\) is of the form \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\mathit{eo}_i\).

\item {} 
Let \(\hyperref[syntax/modules:syntax-tableidx]{\mathit{tableidx}}_i\) be the {\hyperref[\detokenize{syntax/modules:syntax-tableidx}]{\sphinxcrossref{\DUrole{std,std-ref}{table index}}}} \(\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}_i.\hyperref[syntax/modules:syntax-elem]{\mathsf{table}}\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/modules:valid-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{tableaddrs}}[\hyperref[syntax/modules:syntax-tableidx]{\mathit{tableidx}}_i]\) exists.

\item {} 
Let \(\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}_i\) be the {\hyperref[\detokenize{exec/runtime:syntax-tableaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{table address}}}} \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{tableaddrs}}[\hyperref[syntax/modules:syntax-tableidx]{\mathit{tableidx}}_i]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/modules:valid-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(S'.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}_i]\) exists.

\item {} 
Let \(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}_i\) be the {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instance}}}} \(S'.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}_i]\).

\item {} 
Let \(\mathit{eend}_i\) be \(\mathit{eo}_i\) plus the length of \(\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}_i.\hyperref[syntax/modules:syntax-elem]{\mathsf{init}}\).

\item {} 
If \(\mathit{eend}_i\) is larger than the length of \(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}_i.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}\), then:
\begin{enumerate}
\item {} 
Fail.

\end{enumerate}

\end{enumerate}

\item {} 
For each {\hyperref[\detokenize{syntax/modules:syntax-data}]{\sphinxcrossref{\DUrole{std,std-ref}{data segment}}}} \(\hyperref[syntax/modules:syntax-data]{\mathit{data}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{data}}\), do:
\begin{enumerate}
\item {} 
Let \(\mathit{doval}_i\) be the result of {\hyperref[\detokenize{exec/instructions:exec-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{evaluating}}}} the expression \(\hyperref[syntax/modules:syntax-data]{\mathit{data}}_i.\hyperref[syntax/modules:syntax-data]{\mathsf{offset}}\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/modules:valid-data}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(\mathit{doval}_i\) is of the form \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\mathit{do}_i\).

\item {} 
Let \(\hyperref[syntax/modules:syntax-memidx]{\mathit{memidx}}_i\) be the {\hyperref[\detokenize{syntax/modules:syntax-memidx}]{\sphinxcrossref{\DUrole{std,std-ref}{memory index}}}} \(\hyperref[syntax/modules:syntax-data]{\mathit{data}}_i.\hyperref[syntax/modules:syntax-data]{\mathsf{data}}\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/modules:valid-data}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[\hyperref[syntax/modules:syntax-memidx]{\mathit{memidx}}_i]\) exists.

\item {} 
Let \(\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}_i\) be the {\hyperref[\detokenize{exec/runtime:syntax-memaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{memory address}}}} \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[\hyperref[syntax/modules:syntax-memidx]{\mathit{memidx}}_i]\).

\item {} 
Assert: due to {\hyperref[\detokenize{valid/modules:valid-data}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(S'.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}_i]\) exists.

\item {} 
Let \(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}_i\) be the {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}} \(S'.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}_i]\).

\item {} 
Let \(\mathit{dend}_i\) be \(\mathit{do}_i\) plus the length of \(\hyperref[syntax/modules:syntax-data]{\mathit{data}}_i.\hyperref[syntax/modules:syntax-data]{\mathsf{init}}\).

\item {} 
If \(\mathit{dend}_i\) is larger than the length of \(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}_i.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}\), then:
\begin{enumerate}
\item {} 
Fail.

\end{enumerate}

\end{enumerate}

\item {} 
Assert: due to {\hyperref[\detokenize{valid/modules:valid-module}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, the frame \(F\) is now on the top of the stack.

\item {} 
Pop the frame from the stack.

\item {} 
For each {\hyperref[\detokenize{syntax/modules:syntax-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{element segment}}}} \(\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{elem}}\), do:
\begin{enumerate}
\item {} 
For each {\hyperref[\detokenize{syntax/modules:syntax-funcidx}]{\sphinxcrossref{\DUrole{std,std-ref}{function index}}}} \(\hyperref[syntax/modules:syntax-funcidx]{\mathit{funcidx}}_{ij}\) in \(\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}_i.\hyperref[syntax/modules:syntax-elem]{\mathsf{init}}\) (starting with \(j = 0\)), do:
\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/modules:valid-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}}[\hyperref[syntax/modules:syntax-funcidx]{\mathit{funcidx}}_{ij}]\) exists.

\item {} 
Let \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}_{ij}\) be the {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{function address}}}} \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}}[\hyperref[syntax/modules:syntax-funcidx]{\mathit{funcidx}}_{ij}]\).

\item {} 
Replace \(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}_i.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}[\mathit{eo}_i + j]\) with \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}_{ij}\).

\end{enumerate}

\end{enumerate}

\item {} 
For each {\hyperref[\detokenize{syntax/modules:syntax-data}]{\sphinxcrossref{\DUrole{std,std-ref}{data segment}}}} \(\hyperref[syntax/modules:syntax-data]{\mathit{data}}_i\) in \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{data}}\), do:
\begin{enumerate}
\item {} 
For each {\hyperref[\detokenize{syntax/values:syntax-byte}]{\sphinxcrossref{\DUrole{std,std-ref}{byte}}}} \(b_{ij}\) in \(\hyperref[syntax/modules:syntax-data]{\mathit{data}}_i.\hyperref[syntax/modules:syntax-data]{\mathsf{init}}\) (starting with \(j = 0\)), do:
\begin{enumerate}
\item {} 
Replace \(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}_i.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}[\mathit{do}_i + j]\) with \(b_{ij}\).

\end{enumerate}

\end{enumerate}

\item {} 
If the {\hyperref[\detokenize{syntax/modules:syntax-start}]{\sphinxcrossref{\DUrole{std,std-ref}{start function}}}} \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{start}}\) is not empty, then:
\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/modules:valid-start}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}}[\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{start}}.\hyperref[syntax/modules:syntax-start]{\mathsf{func}}]\) exists.

\item {} 
Let \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}\) be the {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{function address}}}} \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}}[\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{start}}.\hyperref[syntax/modules:syntax-start]{\mathsf{func}}]\).

\item {} 
{\hyperref[\detokenize{exec/instructions:exec-invoke}]{\sphinxcrossref{\DUrole{std,std-ref}{Invoke}}}} the function instance at \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}\).

\end{enumerate}

\end{enumerate}
\begin{equation*}
\begin{split}~\\
\begin{array}{@{}rcll}
\hyperref[exec/modules:exec-instantiation]{\mathrm{instantiate}}(S, \hyperref[syntax/modules:syntax-module]{\mathit{module}}, \hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^n) &=& S'; F;
  \begin{array}[t]{@{}l@{}}
  (\hyperref[exec/runtime:syntax-init-elem]{\mathsf{init\_elem}}~\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}~\mathit{eo}~\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}.\hyperref[syntax/modules:syntax-elem]{\mathsf{init}})^\ast \\
  (\hyperref[exec/runtime:syntax-init-data]{\mathsf{init\_data}}~\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}~\mathit{do}~\hyperref[syntax/modules:syntax-data]{\mathit{data}}.\hyperref[syntax/modules:syntax-data]{\mathsf{init}})^\ast \\
  (\hyperref[exec/runtime:syntax-invoke]{\mathsf{invoke}}~\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}})^? \\
  \end{array} \\
&(\mathrel{\mbox{if}}
  & \hyperref[valid/modules:valid-module]{\vdash} \hyperref[syntax/modules:syntax-module]{\mathit{module}} : \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}_{\mathrm{im}}^n \hyperref[syntax/types:syntax-functype]{\rightarrow} \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}_{\mathrm{ex}}^\ast \\
  &\wedge& (S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathit{externval}} : \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}})^n \\
  &\wedge& (\hyperref[exec/modules:match-externtype]{\vdash} \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}} \hyperref[exec/modules:match]{\leq} \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}_{\mathrm{im}})^n \\[1ex]
  &\wedge& \hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{globals}} = \hyperref[syntax/modules:syntax-global]{\mathit{global}}^\ast \\
  &\wedge& \hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{elem}} = \hyperref[syntax/modules:syntax-elem]{\mathit{elem}}^\ast \\
  &\wedge& \hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{data}} = \hyperref[syntax/modules:syntax-data]{\mathit{data}}^\ast \\
  &\wedge& \hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{start}} = \hyperref[syntax/modules:syntax-start]{\mathit{start}}^? \\[1ex]
  &\wedge& S', \hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}} = \hyperref[exec/modules:alloc-module]{\mathrm{allocmodule}}(S, \hyperref[syntax/modules:syntax-module]{\mathit{module}}, \hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^n, \hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast) \\
  &\wedge& F = \{ \hyperref[exec/runtime:syntax-frame]{\mathsf{module}}~\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}, \hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}~\epsilon \} \\[1ex]
  &\wedge& (S'; F; \hyperref[syntax/modules:syntax-global]{\mathit{global}}.\hyperref[syntax/modules:syntax-global]{\mathsf{init}} \hyperref[exec/conventions:formal-notation]{\hookrightarrow}^\ast S'; F; \hyperref[exec/runtime:syntax-val]{\mathit{val}}~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}})^\ast \\
  &\wedge& (S'; F; \hyperref[syntax/modules:syntax-elem]{\mathit{elem}}.\hyperref[syntax/modules:syntax-elem]{\mathsf{offset}} \hyperref[exec/conventions:formal-notation]{\hookrightarrow}^\ast S'; F; \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\mathit{eo}~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}})^\ast \\
  &\wedge& (S'; F; \hyperref[syntax/modules:syntax-data]{\mathit{data}}.\hyperref[syntax/modules:syntax-data]{\mathsf{offset}} \hyperref[exec/conventions:formal-notation]{\hookrightarrow}^\ast S'; F; \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~\mathit{do}~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}})^\ast \\[1ex]
  &\wedge& (\mathit{eo} + |\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}.\hyperref[syntax/modules:syntax-elem]{\mathsf{init}}| \leq |S'.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}].\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}|)^\ast \\
  &\wedge& (\mathit{do} + |\hyperref[syntax/modules:syntax-data]{\mathit{data}}.\hyperref[syntax/modules:syntax-data]{\mathsf{init}}| \leq |S'.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}|)^\ast
\\[1ex]
  &\wedge& (\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}} = \hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{tableaddrs}}[\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}.\hyperref[syntax/modules:syntax-elem]{\mathsf{table}}])^\ast \\
  &\wedge& (\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}} = \hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}[\hyperref[syntax/modules:syntax-data]{\mathit{data}}.\hyperref[syntax/modules:syntax-data]{\mathsf{data}}])^\ast \\
  &\wedge& (\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}} = \hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}}[\hyperref[syntax/modules:syntax-start]{\mathit{start}}.\hyperref[syntax/modules:syntax-start]{\mathsf{func}}])^?)
\\[2ex]
S; F; \hyperref[exec/runtime:syntax-init-elem]{\mathsf{init\_elem}}~a~i~\epsilon &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}&
  S; F; \epsilon \\
S; F; \hyperref[exec/runtime:syntax-init-elem]{\mathsf{init\_elem}}~a~i~(x_0~x^\ast) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}&
  S'; F; \hyperref[exec/runtime:syntax-init-elem]{\mathsf{init\_elem}}~a~(i+1)~x^\ast \\ &&
  (\mathrel{\mbox{if}} S' = S \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[a].\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}[i] = F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}}[x_0])
\\[1ex]
S; F; \hyperref[exec/runtime:syntax-init-data]{\mathsf{init\_data}}~a~i~\epsilon &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}&
  S; F; \epsilon \\
S; F; \hyperref[exec/runtime:syntax-init-data]{\mathsf{init\_data}}~a~i~(b_0~b^\ast) &\hyperref[exec/conventions:formal-notation]{\hookrightarrow}&
  S'; F; \hyperref[exec/runtime:syntax-init-data]{\mathsf{init\_data}}~a~(i+1)~b^\ast \\ &&
  (\mathrel{\mbox{if}} S' = S \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}[i] = b_0)
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
Module {\hyperref[\detokenize{exec/modules:alloc-module}]{\sphinxcrossref{\DUrole{std,std-ref}{allocation}}}} and the {\hyperref[\detokenize{exec/instructions:exec-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{evaluation}}}} of {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}} initializers are mutually recursive because the global initialization {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast\) are passed to the module allocator but depend on the store \(S'\) and module instance \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\) returned by allocation.
However, this recursion is just a specification device.
Due to {\hyperref[\detokenize{valid/modules:valid-module}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, the initialization values can easily {\hyperref[\detokenize{exec/modules:exec-initvals}]{\sphinxcrossref{\DUrole{std,std-ref}{be determined}}}} from a simple pre-pass that evaluates global initializers in the initial store.

All failure conditions are checked before any observable mutation of the store takes place.
Store mutation is not atomic;
it happens in individual steps that may be interleaved with other threads.

{\hyperref[\detokenize{exec/instructions:exec-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{Evaluation}}}} of {\hyperref[\detokenize{valid/instructions:valid-constant}]{\sphinxcrossref{\DUrole{std,std-ref}{constant expressions}}}} does not affect the store.
\end{sphinxadmonition}

\index{invocation|textbf}\index{module}\index{module instance}\index{function}\index{export}\index{function address}\index{function instance}\index{function type}\index{value}\index{stack}\index{trap}\index{store}\ignorespaces 

\subsection{Invocation}
\label{\detokenize{exec/modules:invocation}}\label{\detokenize{exec/modules:index-21}}\label{\detokenize{exec/modules:exec-invocation}}
Once a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}} has been {\hyperref[\detokenize{exec/modules:exec-instantiation}]{\sphinxcrossref{\DUrole{std,std-ref}{instantiated}}}}, any exported function can be \sphinxstyleemphasis{invoked} externally via its {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{function address}}}} \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}\) in the {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} \(S\) and an appropriate list \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast\) of argument {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}}.

Invocation may \sphinxstyleemphasis{fail} with an error if the arguments do not fit the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}}.
Invocation can also result in a {\hyperref[\detokenize{intro/overview:trap}]{\sphinxcrossref{\DUrole{std,std-ref}{trap}}}}.
It is up to the {\hyperref[\detokenize{intro/overview:embedder}]{\sphinxcrossref{\DUrole{std,std-ref}{embedder}}}} to define how such conditions are reported.

\begin{sphinxadmonition}{note}{Note:}
If the {\hyperref[\detokenize{intro/overview:embedder}]{\sphinxcrossref{\DUrole{std,std-ref}{embedder}}}} API performs type checks itself, either statically or dynamically, before performing an invocation, then no failure other than traps can occur.
\end{sphinxadmonition}

The following steps are performed:
\begin{enumerate}
\item {} 
Assert: \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}]\) exists.

\item {} 
Let \(\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}\) be the {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{function instance}}}} \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}]\).

\item {} 
Let \([t_1^n] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^m]\) be the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}.\hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}\).

\item {} 
If the length \(|\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast|\) of the provided argument values is different from the number \(n\) of expected arguments, then:
\begin{enumerate}
\item {} 
Fail.

\end{enumerate}

\item {} 
For each {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t_i\) in \(t_1^n\) and corresponding {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{value}}}} \(val_i\) in \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast\), do:
\begin{enumerate}
\item {} 
If \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}_i\) is not \(t_i.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_i\) for some \(c_i\), then:
\begin{enumerate}
\item {} 
Fail.

\end{enumerate}

\end{enumerate}

\item {} 
Push the values \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast\) to the stack.

\item {} 
{\hyperref[\detokenize{exec/instructions:exec-invoke}]{\sphinxcrossref{\DUrole{std,std-ref}{Invoke}}}} the function instance at address \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}\).

\end{enumerate}

Once the function has returned, the following steps are executed:
\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{valid/modules:valid-func}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, \(m\) {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} are on the top of the stack.

\item {} 
Pop \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}_{\mathrm{res}}^m\) from the stack.

\end{enumerate}

The values \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}_{\mathrm{res}}^m\) are returned as the results of the invocation.
\begin{equation*}
\begin{split}~\\[-1ex]
\begin{array}{@{}lcl}
\hyperref[exec/modules:exec-invocation]{\mathrm{invoke}}(S, \hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}, \hyperref[exec/runtime:syntax-val]{\mathit{val}}^n) &=& S; F; \hyperref[exec/runtime:syntax-val]{\mathit{val}}^n~(\hyperref[exec/runtime:syntax-invoke]{\mathsf{invoke}}~\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}) \\
  &(\mathrel{\mbox{if}} & S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}].\hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}} = [t_1^n] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^m] \\
  &\wedge& \hyperref[exec/runtime:syntax-val]{\mathit{val}}^n = (t_1.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c)^n \\
  &\wedge& F = \{ \hyperref[exec/runtime:syntax-frame]{\mathsf{module}}~\{\}, \hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}~\epsilon \}) \\
\end{array}\end{split}
\end{equation*}

\chapter{Binary Format}
\label{\detokenize{binary/index:binary}}\label{\detokenize{binary/index:binary-format}}\label{\detokenize{binary/index::doc}}
\index{binary format|textbf}\index{module}\index{byte}\index{file extension}\index{abstract syntax}\ignorespaces 

\section{Conventions}
\label{\detokenize{binary/conventions:conventions}}\label{\detokenize{binary/conventions::doc}}\label{\detokenize{binary/conventions:index-0}}
The binary format for WebAssembly {\hyperref[\detokenize{intro/overview:module}]{\sphinxcrossref{\DUrole{std,std-ref}{modules}}}} is a dense linear \sphinxstyleemphasis{encoding} of their {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{abstract syntax}}}}.
%
\begin{footnote}[27]\sphinxAtStartFootnote
Additional encoding layers \textendash{} for example, introducing compression \textendash{} may be defined on top of the basic representation defined here.
However, such layers are outside the scope of the current specification.
%
\end{footnote}

The format is defined by an \sphinxstyleemphasis{attribute grammar} whose only terminal symbols are {\hyperref[\detokenize{syntax/values:syntax-byte}]{\sphinxcrossref{\DUrole{std,std-ref}{bytes}}}}.
A byte sequence is a well-formed encoding of a module if and only if it is generated by the grammar.

Each production of this grammar has exactly one synthesized attribute: the abstract syntax that the respective byte sequence encodes.
Thus, the attribute grammar implicitly defines a \sphinxstyleemphasis{decoding} function
(i.e., a parsing function for the binary format).

Except for a few exceptions, the binary grammar closely mirrors the grammar of the abstract syntax.

\begin{sphinxadmonition}{note}{Note:}
Some phrases of abstract syntax have multiple possible encodings in the binary format.
For example, numbers may be encoded as if they had optional leading zeros.
Implementations of decoders must support all possible alternatives;
implementations of encoders can pick any allowed encoding.
\end{sphinxadmonition}

The recommended extension for files containing WebAssembly modules in binary format is “\(\mathtt{.wasm}\)”
and the recommended \sphinxhref{https://www.iana.org/assignments/media-types/media-types.xhtml}{Media Type}%
\begin{footnote}[26]\sphinxAtStartFootnote
\sphinxnolinkurl{https://www.iana.org/assignments/media-types/media-types.xhtml}
%
\end{footnote} is “\(\mathtt{application/wasm}\)”.

\index{grammar notation}\index{notation}\index{byte}\index{binary format!grammar}\index{binary format!notation}\index{notation!binary format}\ignorespaces 

\subsection{Grammar}
\label{\detokenize{binary/conventions:grammar}}\label{\detokenize{binary/conventions:index-1}}\label{\detokenize{binary/conventions:binary-grammar}}
The following conventions are adopted in defining grammar rules for the binary format.
They mirror the conventions used for {\hyperref[\detokenize{syntax/conventions:grammar}]{\sphinxcrossref{\DUrole{std,std-ref}{abstract syntax}}}}.
In order to distinguish symbols of the binary syntax from symbols of the abstract syntax, \(\mathtt{typewriter}\) font is adopted for the former.
\begin{itemize}
\item {} 
Terminal symbols are {\hyperref[\detokenize{syntax/values:syntax-byte}]{\sphinxcrossref{\DUrole{std,std-ref}{bytes}}}} expressed in hexadecimal notation: \(\def\mathdef798#1{\mathtt{0x#1}}\mathdef798{0F}\).

\item {} 
Nonterminal symbols are written in typewriter font: \(\mathtt{valtype}, \mathtt{instr}\).

\item {} 
\(B^n\) is a sequence of \(n\geq 0\) iterations  of \(B\).

\item {} 
\(B^\ast\) is a possibly empty sequence of iterations of \(B\).
(This is a shorthand for \(B^n\) used where \(n\) is not relevant.)

\item {} 
\(B^?\) is an optional occurrence of \(B\).
(This is a shorthand for \(B^n\) where \(n \leq 1\).)

\item {} 
\(x{:}B\) denotes the same language as the nonterminal \(B\), but also binds the variable \(x\) to the attribute synthesized for \(B\).

\item {} 
Productions are written \(\mathtt{sym} ::= B_1 \Rightarrow A_1 ~|~ \dots ~|~ B_n \Rightarrow A_n\), where each \(A_i\) is the attribute that is synthesized for \(\mathtt{sym}\) in the given case, usually from attribute variables bound in \(B_i\).

\item {} 
Some productions are augmented by side conditions in parentheses, which restrict the applicability of the production. They provide a shorthand for a combinatorial expansion of the production into many separate cases.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
For example, the {\hyperref[\detokenize{binary/types:binary-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{binary grammar}}}} for {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} is given as follows:
\begin{equation*}
\begin{split}\begin{array}{llcll@{\qquad\qquad}l}
\def\mathdef739#1{{}}\mathdef739{value types} & \hyperref[binary/types:binary-valtype]{\mathtt{valtype}} &::=&
  \def\mathdef799#1{\mathtt{0x#1}}\mathdef799{7F} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}} \\ &&|&
  \def\mathdef800#1{\mathtt{0x#1}}\mathdef800{7E} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}} \\ &&|&
  \def\mathdef801#1{\mathtt{0x#1}}\mathdef801{7D} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}} \\ &&|&
  \def\mathdef802#1{\mathtt{0x#1}}\mathdef802{7C} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}} \\
\end{array}\end{split}
\end{equation*}
Consequently, the byte \(\def\mathdef803#1{\mathtt{0x#1}}\mathdef803{7F}\) encodes the type \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\),
\(\def\mathdef804#1{\mathtt{0x#1}}\mathdef804{7E}\) encodes the type \(\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}\), and so forth.
No other byte value is allowed as the encoding of a value type.

The {\hyperref[\detokenize{binary/types:binary-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{binary grammar}}}} for {\hyperref[\detokenize{syntax/types:syntax-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{limits}}}} is defined as follows:
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef739#1{{}}\mathdef739{limits} & \hyperref[binary/types:binary-limits]{\mathtt{limits}} &::=&
  \def\mathdef805#1{\mathtt{0x#1}}\mathdef805{00}~~n{:}\hyperref[binary/values:binary-int]{\def\mathdef766#1{{\mathtt{u}#1}}\mathdef766{\mathtt{32}}} &\Rightarrow& \{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~\epsilon \} \\ &&|&
  \def\mathdef806#1{\mathtt{0x#1}}\mathdef806{01}~~n{:}\hyperref[binary/values:binary-int]{\def\mathdef766#1{{\mathtt{u}#1}}\mathdef766{\mathtt{32}}}~~m{:}\hyperref[binary/values:binary-int]{\def\mathdef766#1{{\mathtt{u}#1}}\mathdef766{\mathtt{32}}} &\Rightarrow& \{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m \} \\
\end{array}\end{split}
\end{equation*}
That is, a limits pair is encoded as either the byte \(\def\mathdef807#1{\mathtt{0x#1}}\mathdef807{00}\) followed by the encoding of a \(\hyperref[syntax/values:syntax-int]{\def\mathdef745#1{{\mathit{u}#1}}\mathdef745{\mathit{32}}}\) value,
or the byte \(\def\mathdef808#1{\mathtt{0x#1}}\mathdef808{01}\) followed by two such encodings.
The variables \(n\) and \(m\) name the attributes of the respective \(\hyperref[binary/values:binary-int]{\def\mathdef766#1{{\mathtt{u}#1}}\mathdef766{\mathtt{32}}}\) nonterminals, which in this case are the actual {\hyperref[\detokenize{syntax/values:syntax-uint}]{\sphinxcrossref{\DUrole{std,std-ref}{unsigned integers}}}} those decode into.
The attribute of the complete production then is the abstract syntax for the limit, expressed in terms of the former values.
\end{sphinxadmonition}


\subsection{Auxiliary Notation}
\label{\detokenize{binary/conventions:auxiliary-notation}}\label{\detokenize{binary/conventions:binary-notation}}
When dealing with binary encodings the following notation is also used:
\begin{itemize}
\item {} 
\(\epsilon\) denotes the empty byte sequence.

\item {} 
\(||B||\) is the length of the byte sequence generated from the production \(B\) in a derivation.

\end{itemize}

\index{vector}\index{binary format!vector}\index{vector!binary format}\ignorespaces 

\subsection{Vectors}
\label{\detokenize{binary/conventions:index-2}}\label{\detokenize{binary/conventions:binary-vec}}\label{\detokenize{binary/conventions:vectors}}
{\hyperref[\detokenize{syntax/conventions:syntax-vec}]{\sphinxcrossref{\DUrole{std,std-ref}{Vectors}}}} are encoded with their \(\hyperref[binary/values:binary-int]{\def\mathdef766#1{{\mathtt{u}#1}}\mathdef766{\mathtt{32}}}\) length followed by the encoding of their element sequence.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef739#1{{}}\mathdef739{vector} & \hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\mathtt{B}) &::=&
  n{:}\hyperref[binary/values:binary-int]{\def\mathdef766#1{{\mathtt{u}#1}}\mathdef766{\mathtt{32}}}~~(x{:}\mathtt{B})^n &\Rightarrow& x^n \\
\end{array}\end{split}
\end{equation*}
\index{value}\index{binary format!value}\index{value!binary format}\ignorespaces 

\section{Values}
\label{\detokenize{binary/values:values}}\label{\detokenize{binary/values::doc}}\label{\detokenize{binary/values:index-0}}\label{\detokenize{binary/values:binary-value}}
\index{byte}\index{binary format!byte}\index{byte!binary format}\ignorespaces 

\subsection{Bytes}
\label{\detokenize{binary/values:binary-byte}}\label{\detokenize{binary/values:index-1}}\label{\detokenize{binary/values:bytes}}
{\hyperref[\detokenize{syntax/values:syntax-byte}]{\sphinxcrossref{\DUrole{std,std-ref}{Bytes}}}} encode themselves.
\begin{equation*}
\begin{split}\begin{array}{llcll@{\qquad}l}
\def\mathdef1258#1{{}}\mathdef1258{byte} & \hyperref[binary/values:binary-byte]{\mathtt{byte}} &::=&
  \def\mathdef1317#1{\mathtt{0x#1}}\mathdef1317{00} &\Rightarrow& \def\mathdef1318#1{\mathtt{0x#1}}\mathdef1318{00} \\ &&|&&
  \dots \\ &&|&
  \def\mathdef1319#1{\mathtt{0x#1}}\mathdef1319{FF} &\Rightarrow& \def\mathdef1320#1{\mathtt{0x#1}}\mathdef1320{FF} \\
\end{array}\end{split}
\end{equation*}
\index{integer}\index{unsigned integer}\index{signed integer}\index{uninterpreted integer}\index{LEB128}\index{two's complement}\index{binary format!integer}\index{integer!binary format}\index{binary format!unsigned integer}\index{unsigned integer!binary format}\index{binary format!signed integer}\index{signed integer!binary format}\index{binary format!uninterpreted integer}\index{uninterpreted integer!binary format}\ignorespaces \phantomsection\label{\detokenize{binary/values:binary-sint}}\phantomsection\label{\detokenize{binary/values:binary-uint}}

\subsection{Integers}
\label{\detokenize{binary/values:binary-int}}\label{\detokenize{binary/values:binary-uint}}\label{\detokenize{binary/values:integers}}\label{\detokenize{binary/values:index-2}}\label{\detokenize{binary/values:binary-sint}}
All {\hyperref[\detokenize{syntax/values:syntax-int}]{\sphinxcrossref{\DUrole{std,std-ref}{integers}}}} are encoded using the \sphinxhref{https://en.wikipedia.org/wiki/LEB128}{LEB128}%
\begin{footnote}[28]\sphinxAtStartFootnote
\sphinxnolinkurl{https://en.wikipedia.org/wiki/LEB128}
%
\end{footnote} variable-length integer encoding, in either unsigned or signed variant.

{\hyperref[\detokenize{syntax/values:syntax-uint}]{\sphinxcrossref{\DUrole{std,std-ref}{Unsigned integers}}}} are encoded in \sphinxhref{https://en.wikipedia.org/wiki/LEB128\#Unsigned\_LEB128}{unsigned LEB128}%
\begin{footnote}[29]\sphinxAtStartFootnote
\sphinxnolinkurl{https://en.wikipedia.org/wiki/LEB128\#Unsigned\_LEB128}
%
\end{footnote} format.
As an additional constraint, the total number of bytes encoding a value of type \(\hyperref[syntax/values:syntax-int]{\def\mathdef1259#1{{\mathit{u}#1}}\mathdef1259{N}}\) must not exceed \(\mathrm{ceil}(N/7)\) bytes.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad}l}
\def\mathdef1258#1{{}}\mathdef1258{unsigned integer} & \hyperref[binary/values:binary-int]{\def\mathdef1281#1{{\mathtt{u}#1}}\mathdef1281{N}} &::=&
  n{:}\hyperref[binary/values:binary-byte]{\mathtt{byte}} &\Rightarrow& n & (\mathrel{\mbox{if}} n < 2^7 \wedge n < 2^N) \\ &&|&
  n{:}\hyperref[binary/values:binary-byte]{\mathtt{byte}}~~m{:}\def\mathdef1321#1{{\mathtt{u}#1}}\mathdef1321{(N\mathtt{-7})} &\Rightarrow&
    2^7\cdot m + (n-2^7) & (\mathrel{\mbox{if}} n \geq 2^7 \wedge N > 7) \\
\end{array}\end{split}
\end{equation*}
{\hyperref[\detokenize{syntax/values:syntax-sint}]{\sphinxcrossref{\DUrole{std,std-ref}{Signed integers}}}} are encoded in \sphinxhref{https://en.wikipedia.org/wiki/LEB128\#Signed\_LEB128}{signed LEB128}%
\begin{footnote}[30]\sphinxAtStartFootnote
\sphinxnolinkurl{https://en.wikipedia.org/wiki/LEB128\#Signed\_LEB128}
%
\end{footnote} format, which uses a two’s complement representation.
As an additional constraint, the total number of bytes encoding a value of type \(\hyperref[syntax/values:syntax-int]{\def\mathdef1266#1{{\mathit{s}#1}}\mathdef1266{N}}\) must not exceed \(\mathrm{ceil}(N/7)\) bytes.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad}l}
\def\mathdef1258#1{{}}\mathdef1258{signed integer} & \hyperref[binary/values:binary-int]{\def\mathdef1287#1{{\mathtt{s}#1}}\mathdef1287{N}} &::=&
  n{:}\hyperref[binary/values:binary-byte]{\mathtt{byte}} &\Rightarrow& n & (\mathrel{\mbox{if}} n < 2^6 \wedge n < 2^{N-1}) \\ &&|&
  n{:}\hyperref[binary/values:binary-byte]{\mathtt{byte}} &\Rightarrow& n-2^7 & (\mathrel{\mbox{if}} 2^6 \leq n < 2^7 \wedge n \geq 2^7-2^{N-1}) \\ &&|&
  n{:}\hyperref[binary/values:binary-byte]{\mathtt{byte}}~~m{:}\def\mathdef1322#1{{\mathtt{s}#1}}\mathdef1322{(N\mathtt{-7})} &\Rightarrow&
    2^7\cdot m + (n-2^7) & (\mathrel{\mbox{if}} n \geq 2^7 \wedge N > 7) \\
\end{array}\end{split}
\end{equation*}
{\hyperref[\detokenize{syntax/values:syntax-int}]{\sphinxcrossref{\DUrole{std,std-ref}{Uninterpreted integers}}}} are encoded as signed integers.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef1258#1{{}}\mathdef1258{uninterpreted integer} & \hyperref[binary/values:binary-int]{\def\mathdef1292#1{{\mathtt{i}#1}}\mathdef1292{N}} &::=&
  n{:}\hyperref[binary/values:binary-int]{\def\mathdef1287#1{{\mathtt{s}#1}}\mathdef1287{N}} &\Rightarrow& i & (\mathrel{\mbox{if}} n = \hyperref[exec/numerics:aux-signed]{\mathrm{signed}}_{\hyperref[syntax/values:syntax-int]{\def\mathdef1272#1{{\mathit{i}#1}}\mathdef1272{N}}}(i))
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The side conditions \(N > 7\) in the productions for non-terminal bytes of the \(\def\mathdef1323#1{{\mathit{u}#1}}\mathdef1323{}\) and \(\def\mathdef1324#1{{\mathit{s}#1}}\mathdef1324{}\) encodings restrict the encoding’s length.
However, “trailing zeros” are still allowed within these bounds.
For example, \(\def\mathdef1325#1{\mathtt{0x#1}}\mathdef1325{03}\) and \(\def\mathdef1326#1{\mathtt{0x#1}}\mathdef1326{83}~\def\mathdef1327#1{\mathtt{0x#1}}\mathdef1327{00}\) are both well-formed encodings for the value \(3\) as a \(\hyperref[syntax/values:syntax-int]{\def\mathdef1262#1{{\mathit{u}#1}}\mathdef1262{\mathit{8}}}\).
Similarly, either of \(\def\mathdef1328#1{\mathtt{0x#1}}\mathdef1328{7e}\) and \(\def\mathdef1329#1{\mathtt{0x#1}}\mathdef1329{FE}~\def\mathdef1330#1{\mathtt{0x#1}}\mathdef1330{7F}\) and \(\def\mathdef1331#1{\mathtt{0x#1}}\mathdef1331{FE}~\def\mathdef1332#1{\mathtt{0x#1}}\mathdef1332{FF}~\def\mathdef1333#1{\mathtt{0x#1}}\mathdef1333{7F}\) are well-formed encodings of the value \(-2\) as a \(\hyperref[syntax/values:syntax-int]{\def\mathdef1268#1{{\mathit{s}#1}}\mathdef1268{\mathit{16}}}\).

The side conditions on the value \(n\) of terminal bytes further enforce that
any unused bits in these bytes must be \(0\) for positive values and \(1\) for negative ones.
For example, \(\def\mathdef1334#1{\mathtt{0x#1}}\mathdef1334{83}~\def\mathdef1335#1{\mathtt{0x#1}}\mathdef1335{10}\) is malformed as a \(\hyperref[syntax/values:syntax-int]{\def\mathdef1262#1{{\mathit{u}#1}}\mathdef1262{\mathit{8}}}\) encoding.
Similarly, both \(\def\mathdef1336#1{\mathtt{0x#1}}\mathdef1336{83}~\def\mathdef1337#1{\mathtt{0x#1}}\mathdef1337{3E}\) and \(\def\mathdef1338#1{\mathtt{0x#1}}\mathdef1338{FF}~\def\mathdef1339#1{\mathtt{0x#1}}\mathdef1339{7B}\) are malformed as \(\hyperref[syntax/values:syntax-int]{\def\mathdef1267#1{{\mathit{s}#1}}\mathdef1267{\mathit{8}}}\) encodings.
\end{sphinxadmonition}

\index{floating-point number}\index{little endian}\index{binary format!floating-point number}\index{floating-point number!binary format}\ignorespaces 

\subsection{Floating-Point}
\label{\detokenize{binary/values:floating-point}}\label{\detokenize{binary/values:binary-float}}\label{\detokenize{binary/values:index-3}}
{\hyperref[\detokenize{syntax/values:syntax-float}]{\sphinxcrossref{\DUrole{std,std-ref}{Floating-point}}}} values are encoded directly by their \sphinxhref{http://ieeexplore.ieee.org/document/4610935/}{IEEE 754-2008}%
\begin{footnote}[31]\sphinxAtStartFootnote
\sphinxnolinkurl{http://ieeexplore.ieee.org/document/4610935/}
%
\end{footnote} (Section 3.4) bit pattern in \sphinxhref{https://en.wikipedia.org/wiki/Endianness\#Little-endian}{little endian}%
\begin{footnote}[32]\sphinxAtStartFootnote
\sphinxnolinkurl{https://en.wikipedia.org/wiki/Endianness\#Little-endian}
%
\end{footnote} byte order:
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef1258#1{{}}\mathdef1258{floating-point value} & \hyperref[binary/values:binary-float]{\def\mathdef1295#1{{\mathtt{f}#1}}\mathdef1295{N}} &::=&
  b^\ast{:\,}\hyperref[binary/values:binary-byte]{\mathtt{byte}}^{N/8} &\Rightarrow& \hyperref[exec/numerics:aux-bytes]{\mathrm{bytes}}_{\hyperref[syntax/values:syntax-float]{\def\mathdef1277#1{{\mathit{f}#1}}\mathdef1277{N}}}^{-1}(b^\ast) \\
\end{array}\end{split}
\end{equation*}
\index{name}\index{byte}\index{Unicode}\index{UTF-8|textbf}\index{binary format!name}\index{name!binary format}\ignorespaces \phantomsection\label{\detokenize{binary/values:binary-utf8}}

\subsection{Names}
\label{\detokenize{binary/values:binary-name}}\label{\detokenize{binary/values:index-4}}\label{\detokenize{binary/values:names}}\label{\detokenize{binary/values:binary-utf8}}
{\hyperref[\detokenize{syntax/values:syntax-name}]{\sphinxcrossref{\DUrole{std,std-ref}{Names}}}} are encoded as a {\hyperref[\detokenize{binary/conventions:binary-vec}]{\sphinxcrossref{\DUrole{std,std-ref}{vector}}}} of bytes containing the \sphinxhref{http://www.unicode.org/versions/latest/}{Unicode}%
\begin{footnote}[33]\sphinxAtStartFootnote
\sphinxnolinkurl{http://www.unicode.org/versions/latest/}
%
\end{footnote} (Section 3.9) UTF-8 encoding of the name’s code point sequence.
\begin{equation*}
\begin{split}\begin{array}{llclllll}
\def\mathdef1258#1{{}}\mathdef1258{name} & \hyperref[binary/values:binary-name]{\mathtt{name}} &::=&
  b^\ast{:}\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/values:binary-byte]{\mathtt{byte}}) &\Rightarrow& \hyperref[syntax/values:syntax-name]{\mathit{name}}
    && (\mathrel{\mbox{if}} \hyperref[binary/values:binary-utf8]{\mathrm{utf8}}(\hyperref[syntax/values:syntax-name]{\mathit{name}}) = b^\ast) \\
\end{array}\end{split}
\end{equation*}
The auxiliary \(\hyperref[binary/values:binary-utf8]{\mathrm{utf8}}\) function expressing this encoding is defined as follows:
\begin{equation*}
\begin{split}\begin{array}{@{}l@{}}
\begin{array}{@{}lcl@{\qquad}l@{}}
\hyperref[binary/values:binary-utf8]{\mathrm{utf8}}(c^\ast) &=& (\hyperref[binary/values:binary-utf8]{\mathrm{utf8}}(c))^\ast \\[1ex]
\hyperref[binary/values:binary-utf8]{\mathrm{utf8}}(c) &=& b &
  (\begin{array}[t]{@{}c@{~}l@{}}
   \mathrel{\mbox{if}} & c < \def\mathdef1340#1{\mathrm{U{+}#1}}\mathdef1340{80} \\
   \wedge & c = b) \\
   \end{array} \\
\hyperref[binary/values:binary-utf8]{\mathrm{utf8}}(c) &=& b_1~b_2 &
  (\begin{array}[t]{@{}c@{~}l@{}}
   \mathrel{\mbox{if}} & \def\mathdef1341#1{\mathrm{U{+}#1}}\mathdef1341{80} \leq c < \def\mathdef1342#1{\mathrm{U{+}#1}}\mathdef1342{800} \\
   \wedge & c = 2^6(b_1-\def\mathdef1343#1{\mathtt{0x#1}}\mathdef1343{C0})+(b_2-\def\mathdef1344#1{\mathtt{0x#1}}\mathdef1344{80})) \\
   \end{array} \\
\hyperref[binary/values:binary-utf8]{\mathrm{utf8}}(c) &=& b_1~b_2~b_3 &
  (\begin{array}[t]{@{}c@{~}l@{}}
   \mathrel{\mbox{if}} & \def\mathdef1345#1{\mathrm{U{+}#1}}\mathdef1345{800} \leq c < \def\mathdef1346#1{\mathrm{U{+}#1}}\mathdef1346{D800} \vee \def\mathdef1347#1{\mathrm{U{+}#1}}\mathdef1347{E000} \leq c < \def\mathdef1348#1{\mathrm{U{+}#1}}\mathdef1348{10000} \\
   \wedge & c = 2^{12}(b_1-\def\mathdef1349#1{\mathtt{0x#1}}\mathdef1349{E0})+2^6(b_2-\def\mathdef1350#1{\mathtt{0x#1}}\mathdef1350{80})+(b_3-\def\mathdef1351#1{\mathtt{0x#1}}\mathdef1351{80})) \\
   \end{array} \\
\hyperref[binary/values:binary-utf8]{\mathrm{utf8}}(c) &=& b_1~b_2~b_3~b_4 &
  (\begin{array}[t]{@{}c@{~}l@{}}
   \mathrel{\mbox{if}} & \def\mathdef1352#1{\mathrm{U{+}#1}}\mathdef1352{10000} \leq c < \def\mathdef1353#1{\mathrm{U{+}#1}}\mathdef1353{110000} \\
   \wedge & c = 2^{18}(b_1-\def\mathdef1354#1{\mathtt{0x#1}}\mathdef1354{F0})+2^{12}(b_2-\def\mathdef1355#1{\mathtt{0x#1}}\mathdef1355{80})+2^6(b_3-\def\mathdef1356#1{\mathtt{0x#1}}\mathdef1356{80})+(b_4-\def\mathdef1357#1{\mathtt{0x#1}}\mathdef1357{80})) \\
   \end{array} \\
\end{array} \\
\mathrel{\mbox{where}} b_2, b_3, b_4 < \def\mathdef1358#1{\mathtt{0x#1}}\mathdef1358{C0} \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
Unlike in some other formats, name strings are not 0-terminated.
\end{sphinxadmonition}

\index{type}\index{binary format!type}\index{type!binary format}\ignorespaces 

\section{Types}
\label{\detokenize{binary/types:types}}\label{\detokenize{binary/types::doc}}\label{\detokenize{binary/types:index-0}}\label{\detokenize{binary/types:binary-type}}
\index{value type}\index{binary format!value type}\index{value type!binary format}\ignorespaces 

\subsection{Value Types}
\label{\detokenize{binary/types:binary-valtype}}\label{\detokenize{binary/types:value-types}}\label{\detokenize{binary/types:index-1}}
{\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{Value types}}}} are encoded by a single byte.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef1188#1{{}}\mathdef1188{value type} & \hyperref[binary/types:binary-valtype]{\mathtt{valtype}} &::=&
  \def\mathdef1247#1{\mathtt{0x#1}}\mathdef1247{7F} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}} \\ &&|&
  \def\mathdef1248#1{\mathtt{0x#1}}\mathdef1248{7E} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}} \\ &&|&
  \def\mathdef1249#1{\mathtt{0x#1}}\mathdef1249{7D} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}} \\ &&|&
  \def\mathdef1250#1{\mathtt{0x#1}}\mathdef1250{7C} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}} \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
Value types can occur in contexts where {\hyperref[\detokenize{syntax/modules:syntax-typeidx}]{\sphinxcrossref{\DUrole{std,std-ref}{type indices}}}} are also allowed, such as in the case of {\hyperref[\detokenize{binary/instructions:binary-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{block types}}}}.
Thus, the binary format for types corresponds to the \sphinxhref{https://en.wikipedia.org/wiki/LEB128\#Signed\_LEB128}{signed LEB128}%
\begin{footnote}[34]\sphinxAtStartFootnote
\sphinxnolinkurl{https://en.wikipedia.org/wiki/LEB128\#Signed\_LEB128}
%
\end{footnote} {\hyperref[\detokenize{binary/values:binary-sint}]{\sphinxcrossref{\DUrole{std,std-ref}{encoding}}}} of small negative \(\hyperref[syntax/values:syntax-int]{\def\mathdef1196#1{{\mathit{s}#1}}\mathdef1196{N}}\) values, so that they can coexist with (positive) type indices in the future.
\end{sphinxadmonition}

\index{result type}\index{value type}\index{binary format!result type}\index{result type!binary format}\ignorespaces 

\subsection{Result Types}
\label{\detokenize{binary/types:result-types}}\label{\detokenize{binary/types:binary-resulttype}}\label{\detokenize{binary/types:index-2}}
{\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{Result types}}}} are encoded by the respective {\hyperref[\detokenize{binary/conventions:binary-vec}]{\sphinxcrossref{\DUrole{std,std-ref}{vectors}}}} of {\hyperref[\detokenize{binary/types:binary-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types {}`}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef1188#1{{}}\mathdef1188{result type} & \hyperref[binary/types:binary-resulttype]{\mathtt{resulttype}} &::=&
  t^\ast{:\,}\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/types:binary-valtype]{\mathtt{valtype}}) &\Rightarrow& [t^\ast] \\
\end{array}\end{split}
\end{equation*}
\index{function type}\index{value type}\index{result type}\index{binary format!function type}\index{function type!binary format}\ignorespaces 

\subsection{Function Types}
\label{\detokenize{binary/types:function-types}}\label{\detokenize{binary/types:index-3}}\label{\detokenize{binary/types:binary-functype}}
{\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{Function types}}}} are encoded by the byte \(\def\mathdef1251#1{\mathtt{0x#1}}\mathdef1251{60}\) followed by the respective {\hyperref[\detokenize{binary/conventions:binary-vec}]{\sphinxcrossref{\DUrole{std,std-ref}{vectors}}}} of parameter and result types.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef1188#1{{}}\mathdef1188{function type} & \hyperref[binary/types:binary-functype]{\mathtt{functype}} &::=&
  \def\mathdef1252#1{\mathtt{0x#1}}\mathdef1252{60}~~\mathit{rt}_1{:\,}\hyperref[binary/types:binary-resulttype]{\mathtt{resulttype}}~~\mathit{rt}_2{:\,}\hyperref[binary/types:binary-resulttype]{\mathtt{resulttype}}
    &\Rightarrow& \mathit{rt}_1 \hyperref[syntax/types:syntax-functype]{\rightarrow} \mathit{rt}_2 \\
\end{array}\end{split}
\end{equation*}
\index{limits}\index{binary format!limits}\index{limits!binary format}\ignorespaces 

\subsection{Limits}
\label{\detokenize{binary/types:index-4}}\label{\detokenize{binary/types:limits}}\label{\detokenize{binary/types:binary-limits}}
{\hyperref[\detokenize{syntax/types:syntax-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{Limits}}}} are encoded with a preceding flag indicating whether a maximum is present.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1188#1{{}}\mathdef1188{limits} & \hyperref[binary/types:binary-limits]{\mathtt{limits}} &::=&
  \def\mathdef1253#1{\mathtt{0x#1}}\mathdef1253{00}~~n{:}\hyperref[binary/values:binary-int]{\def\mathdef1215#1{{\mathtt{u}#1}}\mathdef1215{\mathtt{32}}} &\Rightarrow& \{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~\epsilon \} \\ &&|&
  \def\mathdef1254#1{\mathtt{0x#1}}\mathdef1254{01}~~n{:}\hyperref[binary/values:binary-int]{\def\mathdef1215#1{{\mathtt{u}#1}}\mathdef1215{\mathtt{32}}}~~m{:}\hyperref[binary/values:binary-int]{\def\mathdef1215#1{{\mathtt{u}#1}}\mathdef1215{\mathtt{32}}} &\Rightarrow& \{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m \} \\
\end{array}\end{split}
\end{equation*}
\index{memory type}\index{limits}\index{page size}\index{binary format!memory type}\index{memory type!binary format}\ignorespaces 

\subsection{Memory Types}
\label{\detokenize{binary/types:binary-memtype}}\label{\detokenize{binary/types:memory-types}}\label{\detokenize{binary/types:index-5}}
{\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{Memory types}}}} are encoded with their {\hyperref[\detokenize{binary/types:binary-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{limits}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef1188#1{{}}\mathdef1188{memory type} & \hyperref[binary/types:binary-memtype]{\mathtt{memtype}} &::=&
  \mathit{lim}{:}\hyperref[binary/types:binary-limits]{\mathtt{limits}} &\Rightarrow& \mathit{lim} \\
\end{array}\end{split}
\end{equation*}
\index{table type}\index{element type}\index{limits}\index{binary format!table type}\index{table type!binary format}\index{binary format!element type}\index{element type!binary format}\ignorespaces \phantomsection\label{\detokenize{binary/types:binary-elemtype}}

\subsection{Table Types}
\label{\detokenize{binary/types:binary-tabletype}}\label{\detokenize{binary/types:index-6}}\label{\detokenize{binary/types:binary-elemtype}}\label{\detokenize{binary/types:table-types}}
{\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{Table types}}}} are encoded with their {\hyperref[\detokenize{binary/types:binary-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{limits}}}} and a constant byte indicating their {\hyperref[\detokenize{syntax/types:syntax-elemtype}]{\sphinxcrossref{\DUrole{std,std-ref}{element type}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1188#1{{}}\mathdef1188{table type} & \hyperref[binary/types:binary-tabletype]{\mathtt{tabletype}} &::=&
  \mathit{et}{:}\hyperref[binary/types:binary-elemtype]{\mathtt{elemtype}}~~\mathit{lim}{:}\hyperref[binary/types:binary-limits]{\mathtt{limits}} &\Rightarrow& \mathit{lim}~\mathit{et} \\
\def\mathdef1188#1{{}}\mathdef1188{element type} & \hyperref[binary/types:binary-elemtype]{\mathtt{elemtype}} &::=&
  \def\mathdef1255#1{\mathtt{0x#1}}\mathdef1255{70} &\Rightarrow& \hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}} \\
\end{array}\end{split}
\end{equation*}
\index{global type}\index{mutability}\index{value type}\index{binary format!global type}\index{global type!binary format}\index{binary format!mutability}\index{mutability!binary format}\ignorespaces \phantomsection\label{\detokenize{binary/types:binary-mut}}

\subsection{Global Types}
\label{\detokenize{binary/types:binary-globaltype}}\label{\detokenize{binary/types:global-types}}\label{\detokenize{binary/types:index-7}}\label{\detokenize{binary/types:binary-mut}}
{\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{Global types}}}} are encoded by their {\hyperref[\detokenize{binary/types:binary-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} and a flag for their {\hyperref[\detokenize{syntax/types:syntax-mut}]{\sphinxcrossref{\DUrole{std,std-ref}{mutability}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1188#1{{}}\mathdef1188{global type} & \hyperref[binary/types:binary-globaltype]{\mathtt{globaltype}} &::=&
  t{:}\hyperref[binary/types:binary-valtype]{\mathtt{valtype}}~~m{:}\hyperref[binary/types:binary-mut]{\mathtt{mut}} &\Rightarrow& m~t \\
\def\mathdef1188#1{{}}\mathdef1188{mutability} & \hyperref[binary/types:binary-mut]{\mathtt{mut}} &::=&
  \def\mathdef1256#1{\mathtt{0x#1}}\mathdef1256{00} &\Rightarrow& \hyperref[syntax/types:syntax-mut]{\mathsf{const}} \\ &&|&
  \def\mathdef1257#1{\mathtt{0x#1}}\mathdef1257{01} &\Rightarrow& \hyperref[syntax/types:syntax-mut]{\mathsf{var}} \\
\end{array}\end{split}
\end{equation*}
\index{instruction}\index{opcode|textbf}\ignorespaces 

\section{Instructions}
\label{\detokenize{binary/instructions:instructions}}\label{\detokenize{binary/instructions::doc}}\label{\detokenize{binary/instructions:binary-instr}}\label{\detokenize{binary/instructions:index-0}}
{\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{Instructions}}}} are encoded by \sphinxstyleemphasis{opcodes}.
Each opcode is represented by a single byte,
and is followed by the instruction’s immediate arguments, where present.
The only exception are {\hyperref[\detokenize{binary/instructions:binary-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{structured control instructions}}}}, which consist of several opcodes bracketing their nested instruction sequences.

\begin{sphinxadmonition}{note}{Note:}
Gaps in the byte code ranges for encoding instructions are reserved for future extensions.
\end{sphinxadmonition}

\index{control instructions}\index{structured control}\index{label}\index{block}\index{branch}\index{result type}\index{value type}\index{block type}\index{label index}\index{function index}\index{type index}\index{vector}\index{polymorphism}\index{LEB128}\index{binary format!instruction}\index{instruction!binary format}\index{binary format!block type}\index{block type!binary format}\ignorespaces 

\subsection{Control Instructions}
\label{\detokenize{binary/instructions:binary-instr-control}}\label{\detokenize{binary/instructions:index-1}}\label{\detokenize{binary/instructions:control-instructions}}
{\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{Control instructions}}}} have varying encodings. For structured instructions, the instruction sequences forming nested blocks are terminated with explicit opcodes for \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\) and \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{else}}\).

{\hyperref[\detokenize{syntax/instructions:syntax-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{Block types}}}} are encoded in special compressed form, by either the byte \(\def\mathdef927#1{\mathtt{0x#1}}\mathdef927{40}\) indicating the empty type, as a single {\hyperref[\detokenize{binary/types:binary-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}}, or as a {\hyperref[\detokenize{binary/modules:binary-typeidx}]{\sphinxcrossref{\DUrole{std,std-ref}{type index}}}} encoded as a positive {\hyperref[\detokenize{binary/values:binary-sint}]{\sphinxcrossref{\DUrole{std,std-ref}{signed integer}}}}.

\phantomsection\label{\detokenize{binary/instructions:binary-blocktype}}\phantomsection\label{\detokenize{binary/instructions:binary-nop}}\phantomsection\label{\detokenize{binary/instructions:binary-unreachable}}\phantomsection\label{\detokenize{binary/instructions:binary-block}}\phantomsection\label{\detokenize{binary/instructions:binary-loop}}\phantomsection\label{\detokenize{binary/instructions:binary-if}}\phantomsection\label{\detokenize{binary/instructions:binary-br}}\phantomsection\label{\detokenize{binary/instructions:binary-br-if}}\phantomsection\label{\detokenize{binary/instructions:binary-br-table}}\phantomsection\label{\detokenize{binary/instructions:binary-return}}\phantomsection\label{\detokenize{binary/instructions:binary-call}}\phantomsection\label{\detokenize{binary/instructions:binary-call-indirect}}\begin{equation*}
\begin{split}\begin{array}{llclllll}
\def\mathdef868#1{{}}\mathdef868{block type} & \hyperref[binary/instructions:binary-blocktype]{\mathtt{blocktype}} &::=&
  \def\mathdef928#1{\mathtt{0x#1}}\mathdef928{40} &\Rightarrow& \epsilon \\ &&|&
  t{:}\hyperref[binary/types:binary-valtype]{\mathtt{valtype}} &\Rightarrow& t \\ &&|&
  x{:}\hyperref[binary/values:binary-int]{\def\mathdef900#1{{\mathtt{s}#1}}\mathdef900{\mathtt{33}}} &\Rightarrow& x & (\mathrel{\mbox{if}} x \geq 0) \\
\def\mathdef868#1{{}}\mathdef868{instruction} & \hyperref[binary/instructions:binary-instr]{\mathtt{instr}} &::=&
  \def\mathdef929#1{\mathtt{0x#1}}\mathdef929{00} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}} \\ &&|&
  \def\mathdef930#1{\mathtt{0x#1}}\mathdef930{01} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{nop}} \\ &&|&
  \def\mathdef931#1{\mathtt{0x#1}}\mathdef931{02}~~\mathit{bt}{:}\hyperref[binary/instructions:binary-blocktype]{\mathtt{blocktype}}~~(\mathit{in}{:}\hyperref[binary/instructions:binary-instr]{\mathtt{instr}})^\ast~~\def\mathdef932#1{\mathtt{0x#1}}\mathdef932{0B}
    &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}~\mathit{bt}~\mathit{in}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \\ &&|&
  \def\mathdef933#1{\mathtt{0x#1}}\mathdef933{03}~~\mathit{bt}{:}\hyperref[binary/instructions:binary-blocktype]{\mathtt{blocktype}}~~(\mathit{in}{:}\hyperref[binary/instructions:binary-instr]{\mathtt{instr}})^\ast~~\def\mathdef934#1{\mathtt{0x#1}}\mathdef934{0B}
    &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{loop}}~\mathit{bt}~\mathit{in}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \\ &&|&
  \def\mathdef935#1{\mathtt{0x#1}}\mathdef935{04}~~\mathit{bt}{:}\hyperref[binary/instructions:binary-blocktype]{\mathtt{blocktype}}~~(\mathit{in}{:}\hyperref[binary/instructions:binary-instr]{\mathtt{instr}})^\ast~~\def\mathdef936#1{\mathtt{0x#1}}\mathdef936{0B}
    &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}~\mathit{bt}~\mathit{in}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{else}}~\epsilon~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \\ &&|&
  \def\mathdef937#1{\mathtt{0x#1}}\mathdef937{04}~~\mathit{bt}{:}\hyperref[binary/instructions:binary-blocktype]{\mathtt{blocktype}}~~(\mathit{in}_1{:}\hyperref[binary/instructions:binary-instr]{\mathtt{instr}})^\ast~~
    \def\mathdef938#1{\mathtt{0x#1}}\mathdef938{05}~~(\mathit{in}_2{:}\hyperref[binary/instructions:binary-instr]{\mathtt{instr}})^\ast~~\def\mathdef939#1{\mathtt{0x#1}}\mathdef939{0B}
    &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}~\mathit{bt}~\mathit{in}_1^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{else}}~\mathit{in}_2^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \\ &&|&
  \def\mathdef940#1{\mathtt{0x#1}}\mathdef940{0C}~~l{:}\hyperref[binary/modules:binary-labelidx]{\mathtt{labelidx}} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}~l \\ &&|&
  \def\mathdef941#1{\mathtt{0x#1}}\mathdef941{0D}~~l{:}\hyperref[binary/modules:binary-labelidx]{\mathtt{labelidx}} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_if}}~l \\ &&|&
  \def\mathdef942#1{\mathtt{0x#1}}\mathdef942{0E}~~l^\ast{:}\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/modules:binary-labelidx]{\mathtt{labelidx}})~~l_N{:}\hyperref[binary/modules:binary-labelidx]{\mathtt{labelidx}}
    &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_table}}~l^\ast~l_N \\ &&|&
  \def\mathdef943#1{\mathtt{0x#1}}\mathdef943{0F} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{return}} \\ &&|&
  \def\mathdef944#1{\mathtt{0x#1}}\mathdef944{10}~~x{:}\hyperref[binary/modules:binary-funcidx]{\mathtt{funcidx}} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call}}~x \\ &&|&
  \def\mathdef945#1{\mathtt{0x#1}}\mathdef945{11}~~x{:}\hyperref[binary/modules:binary-typeidx]{\mathtt{typeidx}}~~\def\mathdef946#1{\mathtt{0x#1}}\mathdef946{00} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call\_indirect}}~x \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{else}}\) opcode \(\def\mathdef947#1{\mathtt{0x#1}}\mathdef947{05}\) in the encoding of an \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}\) instruction can be omitted if the following instruction sequence is empty.

Unlike any {\hyperref[\detokenize{binary/modules:binary-typeidx}]{\sphinxcrossref{\DUrole{std,std-ref}{other occurrence}}}}, the {\hyperref[\detokenize{syntax/modules:syntax-typeidx}]{\sphinxcrossref{\DUrole{std,std-ref}{type index}}}} in a {\hyperref[\detokenize{syntax/instructions:syntax-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{block type}}}} is encoded as a positive {\hyperref[\detokenize{syntax/values:syntax-sint}]{\sphinxcrossref{\DUrole{std,std-ref}{signed integer}}}}, so that its signed LEB128 bit pattern cannot collide with the encoding of {\hyperref[\detokenize{binary/types:binary-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} or the special code \(\def\mathdef948#1{\mathtt{0x#1}}\mathdef948{40}\), which correspond to the LEB128 encoding of negative integers.
To avoid any loss in the range of allowed indices, it is treated as a 33 bit signed integer.

In future versions of WebAssembly, the zero byte occurring in the encoding
of the \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call\_indirect}}\) instruction may be used to index additional tables.
\end{sphinxadmonition}

\index{value type}\index{polymorphism}\index{binary format!instruction}\index{instruction!binary format}\ignorespaces 

\subsection{Parametric Instructions}
\label{\detokenize{binary/instructions:parametric-instructions}}\label{\detokenize{binary/instructions:index-2}}\label{\detokenize{binary/instructions:binary-instr-parametric}}
{\hyperref[\detokenize{syntax/instructions:syntax-instr-parametric}]{\sphinxcrossref{\DUrole{std,std-ref}{Parametric instructions}}}} are represented by single byte codes.

\phantomsection\label{\detokenize{binary/instructions:binary-drop}}\phantomsection\label{\detokenize{binary/instructions:binary-select}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef868#1{{}}\mathdef868{instruction} & \hyperref[binary/instructions:binary-instr]{\mathtt{instr}} &::=& \dots \\ &&|&
  \def\mathdef949#1{\mathtt{0x#1}}\mathdef949{1A} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{drop}} \\ &&|&
  \def\mathdef950#1{\mathtt{0x#1}}\mathdef950{1B} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}} \\
\end{array}\end{split}
\end{equation*}
\index{variable instructions}\index{local index}\index{global index}\index{binary format!instruction}\index{instruction!binary format}\ignorespaces 

\subsection{Variable Instructions}
\label{\detokenize{binary/instructions:binary-instr-variable}}\label{\detokenize{binary/instructions:index-3}}\label{\detokenize{binary/instructions:variable-instructions}}
{\hyperref[\detokenize{syntax/instructions:syntax-instr-variable}]{\sphinxcrossref{\DUrole{std,std-ref}{Variable instructions}}}} are represented by byte codes followed by the encoding of the respective {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{index}}}}.

\phantomsection\label{\detokenize{binary/instructions:binary-local-get}}\phantomsection\label{\detokenize{binary/instructions:binary-local-set}}\phantomsection\label{\detokenize{binary/instructions:binary-local-tee}}\phantomsection\label{\detokenize{binary/instructions:binary-global-get}}\phantomsection\label{\detokenize{binary/instructions:binary-global-set}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef868#1{{}}\mathdef868{instruction} & \hyperref[binary/instructions:binary-instr]{\mathtt{instr}} &::=& \dots \\ &&|&
  \def\mathdef951#1{\mathtt{0x#1}}\mathdef951{20}~~x{:}\hyperref[binary/modules:binary-localidx]{\mathtt{localidx}} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.get}}~x \\ &&|&
  \def\mathdef952#1{\mathtt{0x#1}}\mathdef952{21}~~x{:}\hyperref[binary/modules:binary-localidx]{\mathtt{localidx}} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.set}}~x \\ &&|&
  \def\mathdef953#1{\mathtt{0x#1}}\mathdef953{22}~~x{:}\hyperref[binary/modules:binary-localidx]{\mathtt{localidx}} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.tee}}~x \\ &&|&
  \def\mathdef954#1{\mathtt{0x#1}}\mathdef954{23}~~x{:}\hyperref[binary/modules:binary-globalidx]{\mathtt{globalidx}} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.get}}~x \\ &&|&
  \def\mathdef955#1{\mathtt{0x#1}}\mathdef955{24}~~x{:}\hyperref[binary/modules:binary-globalidx]{\mathtt{globalidx}} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.set}}~x \\
\end{array}\end{split}
\end{equation*}
\index{memory instruction}\index{memory index}\index{binary format!instruction}\index{instruction!binary format}\ignorespaces 

\subsection{Memory Instructions}
\label{\detokenize{binary/instructions:memory-instructions}}\label{\detokenize{binary/instructions:index-4}}\label{\detokenize{binary/instructions:binary-instr-memory}}
Each variant of {\hyperref[\detokenize{syntax/instructions:syntax-instr-memory}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instruction}}}} is encoded with a different byte code. Loads and stores are followed by the encoding of their \(\hyperref[syntax/instructions:syntax-memarg]{\mathit{memarg}}\) immediate.

\phantomsection\label{\detokenize{binary/instructions:binary-memarg}}\phantomsection\label{\detokenize{binary/instructions:binary-load}}\phantomsection\label{\detokenize{binary/instructions:binary-loadn}}\phantomsection\label{\detokenize{binary/instructions:binary-store}}\phantomsection\label{\detokenize{binary/instructions:binary-storen}}\phantomsection\label{\detokenize{binary/instructions:binary-memory-size}}\phantomsection\label{\detokenize{binary/instructions:binary-memory-grow}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef868#1{{}}\mathdef868{memory argument} & \hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &::=&
  a{:}\hyperref[binary/values:binary-int]{\def\mathdef895#1{{\mathtt{u}#1}}\mathdef895{\mathtt{32}}}~~o{:}\hyperref[binary/values:binary-int]{\def\mathdef895#1{{\mathtt{u}#1}}\mathdef895{\mathtt{32}}} &\Rightarrow& \{ \hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{align}}~a,~\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{offset}}~o \} \\
\def\mathdef868#1{{}}\mathdef868{instruction} & \hyperref[binary/instructions:binary-instr]{\mathtt{instr}} &::=& \dots \\ &&|&
  \def\mathdef956#1{\mathtt{0x#1}}\mathdef956{28}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}~m \\ &&|&
  \def\mathdef957#1{\mathtt{0x#1}}\mathdef957{29}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}~m \\ &&|&
  \def\mathdef958#1{\mathtt{0x#1}}\mathdef958{2A}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}~m \\ &&|&
  \def\mathdef959#1{\mathtt{0x#1}}\mathdef959{2B}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}~m \\ &&|&
  \def\mathdef960#1{\mathtt{0x#1}}\mathdef960{2C}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{8\_s}~m \\ &&|&
  \def\mathdef961#1{\mathtt{0x#1}}\mathdef961{2D}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{8\_u}~m \\ &&|&
  \def\mathdef962#1{\mathtt{0x#1}}\mathdef962{2E}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{16\_s}~m \\ &&|&
  \def\mathdef963#1{\mathtt{0x#1}}\mathdef963{2F}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{16\_u}~m \\ &&|&
  \def\mathdef964#1{\mathtt{0x#1}}\mathdef964{30}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{8\_s}~m \\ &&|&
  \def\mathdef965#1{\mathtt{0x#1}}\mathdef965{31}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{8\_u}~m \\ &&|&
  \def\mathdef966#1{\mathtt{0x#1}}\mathdef966{32}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{16\_s}~m \\ &&|&
  \def\mathdef967#1{\mathtt{0x#1}}\mathdef967{33}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{16\_u}~m \\ &&|&
  \def\mathdef968#1{\mathtt{0x#1}}\mathdef968{34}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{32\_s}~m \\ &&|&
  \def\mathdef969#1{\mathtt{0x#1}}\mathdef969{35}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{32\_u}~m \\ &&|&
  \def\mathdef970#1{\mathtt{0x#1}}\mathdef970{36}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}~m \\ &&|&
  \def\mathdef971#1{\mathtt{0x#1}}\mathdef971{37}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}~m \\ &&|&
  \def\mathdef972#1{\mathtt{0x#1}}\mathdef972{38}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}~m \\ &&|&
  \def\mathdef973#1{\mathtt{0x#1}}\mathdef973{39}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}~m \\ &&|&
  \def\mathdef974#1{\mathtt{0x#1}}\mathdef974{3A}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}\mathsf{8}~m \\ &&|&
  \def\mathdef975#1{\mathtt{0x#1}}\mathdef975{3B}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}\mathsf{16}~m \\ &&|&
  \def\mathdef976#1{\mathtt{0x#1}}\mathdef976{3C}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}\mathsf{8}~m \\ &&|&
  \def\mathdef977#1{\mathtt{0x#1}}\mathdef977{3D}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}\mathsf{16}~m \\ &&|&
  \def\mathdef978#1{\mathtt{0x#1}}\mathdef978{3E}~~m{:}\hyperref[binary/instructions:binary-memarg]{\mathtt{memarg}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}\mathsf{32}~m \\ &&|&
  \def\mathdef979#1{\mathtt{0x#1}}\mathdef979{3F}~~\def\mathdef980#1{\mathtt{0x#1}}\mathdef980{00} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.size}} \\ &&|&
  \def\mathdef981#1{\mathtt{0x#1}}\mathdef981{40}~~\def\mathdef982#1{\mathtt{0x#1}}\mathdef982{00} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.grow}} \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
In future versions of WebAssembly, the additional zero bytes occurring in the encoding of the \(\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.size}}\) and \(\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.grow}}\) instructions may be used to index additional memories.
\end{sphinxadmonition}

\index{numeric instruction}\index{binary format!instruction}\index{instruction!binary format}\ignorespaces 

\subsection{Numeric Instructions}
\label{\detokenize{binary/instructions:binary-instr-numeric}}\label{\detokenize{binary/instructions:numeric-instructions}}\label{\detokenize{binary/instructions:index-5}}
All variants of {\hyperref[\detokenize{syntax/instructions:syntax-instr-numeric}]{\sphinxcrossref{\DUrole{std,std-ref}{numeric instructions}}}} are represented by separate byte codes.

The \(\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}\) instructions are followed by the respective literal.

\phantomsection\label{\detokenize{binary/instructions:binary-const}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef868#1{{}}\mathdef868{instruction} & \hyperref[binary/instructions:binary-instr]{\mathtt{instr}} &::=& \dots \\&&|&
  \def\mathdef983#1{\mathtt{0x#1}}\mathdef983{41}~~n{:}\hyperref[binary/values:binary-int]{\def\mathdef903#1{{\mathtt{i}#1}}\mathdef903{\mathtt{32}}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~n \\ &&|&
  \def\mathdef984#1{\mathtt{0x#1}}\mathdef984{42}~~n{:}\hyperref[binary/values:binary-int]{\def\mathdef904#1{{\mathtt{i}#1}}\mathdef904{\mathtt{64}}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~n \\ &&|&
  \def\mathdef985#1{\mathtt{0x#1}}\mathdef985{43}~~z{:}\hyperref[binary/values:binary-float]{\def\mathdef906#1{{\mathtt{f}#1}}\mathdef906{\mathtt{32}}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~z \\ &&|&
  \def\mathdef986#1{\mathtt{0x#1}}\mathdef986{44}~~z{:}\hyperref[binary/values:binary-float]{\def\mathdef907#1{{\mathtt{f}#1}}\mathdef907{\mathtt{64}}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~z \\
\end{array}\end{split}
\end{equation*}
All other numeric instructions are plain opcodes without any immediates.

\phantomsection\label{\detokenize{binary/instructions:binary-testop}}\phantomsection\label{\detokenize{binary/instructions:binary-relop}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef868#1{{}}\mathdef868{instruction} & \hyperref[binary/instructions:binary-instr]{\mathtt{instr}} &::=& \dots && \phantom{thisshouldbeenough} \\&&|&
  \def\mathdef987#1{\mathtt{0x#1}}\mathdef987{45} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{eqz}} \\ &&|&
  \def\mathdef988#1{\mathtt{0x#1}}\mathdef988{46} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{eq}} \\ &&|&
  \def\mathdef989#1{\mathtt{0x#1}}\mathdef989{47} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ne}} \\ &&|&
  \def\mathdef990#1{\mathtt{0x#1}}\mathdef990{48} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{lt}}\mathsf{\_s} \\ &&|&
  \def\mathdef991#1{\mathtt{0x#1}}\mathdef991{49} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{lt}}\mathsf{\_u} \\ &&|&
  \def\mathdef992#1{\mathtt{0x#1}}\mathdef992{4A} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{gt}}\mathsf{\_s} \\ &&|&
  \def\mathdef993#1{\mathtt{0x#1}}\mathdef993{4B} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{gt}}\mathsf{\_u} \\ &&|&
  \def\mathdef994#1{\mathtt{0x#1}}\mathdef994{4C} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{le}}\mathsf{\_s} \\ &&|&
  \def\mathdef995#1{\mathtt{0x#1}}\mathdef995{4D} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{le}}\mathsf{\_u} \\ &&|&
  \def\mathdef996#1{\mathtt{0x#1}}\mathdef996{4E} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ge}}\mathsf{\_s} \\ &&|&
  \def\mathdef997#1{\mathtt{0x#1}}\mathdef997{4F} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ge}}\mathsf{\_u} \\
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef868#1{{}}\mathdef868{instruction}} & \phantom{\hyperref[binary/instructions:binary-instr]{\mathtt{instr}}} &\phantom{::=}& \phantom{\dots} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef998#1{\mathtt{0x#1}}\mathdef998{50} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{eqz}} \\ &&|&
  \def\mathdef999#1{\mathtt{0x#1}}\mathdef999{51} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{eq}} \\ &&|&
  \def\mathdef1000#1{\mathtt{0x#1}}\mathdef1000{52} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ne}} \\ &&|&
  \def\mathdef1001#1{\mathtt{0x#1}}\mathdef1001{53} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{lt}}\mathsf{\_s} \\ &&|&
  \def\mathdef1002#1{\mathtt{0x#1}}\mathdef1002{54} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{lt}}\mathsf{\_u} \\ &&|&
  \def\mathdef1003#1{\mathtt{0x#1}}\mathdef1003{55} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{gt}}\mathsf{\_s} \\ &&|&
  \def\mathdef1004#1{\mathtt{0x#1}}\mathdef1004{56} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{gt}}\mathsf{\_u} \\ &&|&
  \def\mathdef1005#1{\mathtt{0x#1}}\mathdef1005{57} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{le}}\mathsf{\_s} \\ &&|&
  \def\mathdef1006#1{\mathtt{0x#1}}\mathdef1006{58} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{le}}\mathsf{\_u} \\ &&|&
  \def\mathdef1007#1{\mathtt{0x#1}}\mathdef1007{59} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ge}}\mathsf{\_s} \\ &&|&
  \def\mathdef1008#1{\mathtt{0x#1}}\mathdef1008{5A} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ge}}\mathsf{\_u} \\
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef868#1{{}}\mathdef868{instruction}} & \phantom{\hyperref[binary/instructions:binary-instr]{\mathtt{instr}}} &\phantom{::=}& \phantom{\dots} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef1009#1{\mathtt{0x#1}}\mathdef1009{5B} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{eq}} \\ &&|&
  \def\mathdef1010#1{\mathtt{0x#1}}\mathdef1010{5C} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ne}} \\ &&|&
  \def\mathdef1011#1{\mathtt{0x#1}}\mathdef1011{5D} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{lt}} \\ &&|&
  \def\mathdef1012#1{\mathtt{0x#1}}\mathdef1012{5E} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{gt}} \\ &&|&
  \def\mathdef1013#1{\mathtt{0x#1}}\mathdef1013{5F} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{le}} \\ &&|&
  \def\mathdef1014#1{\mathtt{0x#1}}\mathdef1014{60} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ge}} \\
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef868#1{{}}\mathdef868{instruction}} & \phantom{\hyperref[binary/instructions:binary-instr]{\mathtt{instr}}} &\phantom{::=}& \phantom{\dots} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef1015#1{\mathtt{0x#1}}\mathdef1015{61} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{eq}} \\ &&|&
  \def\mathdef1016#1{\mathtt{0x#1}}\mathdef1016{62} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ne}} \\ &&|&
  \def\mathdef1017#1{\mathtt{0x#1}}\mathdef1017{63} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{lt}} \\ &&|&
  \def\mathdef1018#1{\mathtt{0x#1}}\mathdef1018{64} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{gt}} \\ &&|&
  \def\mathdef1019#1{\mathtt{0x#1}}\mathdef1019{65} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{le}} \\ &&|&
  \def\mathdef1020#1{\mathtt{0x#1}}\mathdef1020{66} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ge}} \\
\end{array}\end{split}
\end{equation*}\phantomsection\label{\detokenize{binary/instructions:binary-unop}}\phantomsection\label{\detokenize{binary/instructions:binary-binop}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef868#1{{}}\mathdef868{instruction}} & \phantom{\hyperref[binary/instructions:binary-instr]{\mathtt{instr}}} &\phantom{::=}& \phantom{\dots} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef1021#1{\mathtt{0x#1}}\mathdef1021{67} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{clz}} \\ &&|&
  \def\mathdef1022#1{\mathtt{0x#1}}\mathdef1022{68} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ctz}} \\ &&|&
  \def\mathdef1023#1{\mathtt{0x#1}}\mathdef1023{69} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{popcnt}} \\ &&|&
  \def\mathdef1024#1{\mathtt{0x#1}}\mathdef1024{6A} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}} \\ &&|&
  \def\mathdef1025#1{\mathtt{0x#1}}\mathdef1025{6B} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{sub}} \\ &&|&
  \def\mathdef1026#1{\mathtt{0x#1}}\mathdef1026{6C} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{mul}} \\ &&|&
  \def\mathdef1027#1{\mathtt{0x#1}}\mathdef1027{6D} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{div}}\mathsf{\_s} \\ &&|&
  \def\mathdef1028#1{\mathtt{0x#1}}\mathdef1028{6E} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{div}}\mathsf{\_u} \\ &&|&
  \def\mathdef1029#1{\mathtt{0x#1}}\mathdef1029{6F} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rem}}\mathsf{\_s} \\ &&|&
  \def\mathdef1030#1{\mathtt{0x#1}}\mathdef1030{70} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rem}}\mathsf{\_u} \\ &&|&
  \def\mathdef1031#1{\mathtt{0x#1}}\mathdef1031{71} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{and}} \\ &&|&
  \def\mathdef1032#1{\mathtt{0x#1}}\mathdef1032{72} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{or}} \\ &&|&
  \def\mathdef1033#1{\mathtt{0x#1}}\mathdef1033{73} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{xor}} \\ &&|&
  \def\mathdef1034#1{\mathtt{0x#1}}\mathdef1034{74} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{shl}} \\ &&|&
  \def\mathdef1035#1{\mathtt{0x#1}}\mathdef1035{75} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{shr}}\mathsf{\_s} \\ &&|&
  \def\mathdef1036#1{\mathtt{0x#1}}\mathdef1036{76} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{shr}}\mathsf{\_u} \\ &&|&
  \def\mathdef1037#1{\mathtt{0x#1}}\mathdef1037{77} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rotl}} \\ &&|&
  \def\mathdef1038#1{\mathtt{0x#1}}\mathdef1038{78} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rotr}} \\
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef868#1{{}}\mathdef868{instruction}} & \phantom{\hyperref[binary/instructions:binary-instr]{\mathtt{instr}}} &\phantom{::=}& \phantom{\dots} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef1039#1{\mathtt{0x#1}}\mathdef1039{79} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{clz}} \\ &&|&
  \def\mathdef1040#1{\mathtt{0x#1}}\mathdef1040{7A} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ctz}} \\ &&|&
  \def\mathdef1041#1{\mathtt{0x#1}}\mathdef1041{7B} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{popcnt}} \\ &&|&
  \def\mathdef1042#1{\mathtt{0x#1}}\mathdef1042{7C} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}} \\ &&|&
  \def\mathdef1043#1{\mathtt{0x#1}}\mathdef1043{7D} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{sub}} \\ &&|&
  \def\mathdef1044#1{\mathtt{0x#1}}\mathdef1044{7E} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{mul}} \\ &&|&
  \def\mathdef1045#1{\mathtt{0x#1}}\mathdef1045{7F} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{div}}\mathsf{\_s} \\ &&|&
  \def\mathdef1046#1{\mathtt{0x#1}}\mathdef1046{80} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{div}}\mathsf{\_u} \\ &&|&
  \def\mathdef1047#1{\mathtt{0x#1}}\mathdef1047{81} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rem}}\mathsf{\_s} \\ &&|&
  \def\mathdef1048#1{\mathtt{0x#1}}\mathdef1048{82} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rem}}\mathsf{\_u} \\ &&|&
  \def\mathdef1049#1{\mathtt{0x#1}}\mathdef1049{83} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{and}} \\ &&|&
  \def\mathdef1050#1{\mathtt{0x#1}}\mathdef1050{84} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{or}} \\ &&|&
  \def\mathdef1051#1{\mathtt{0x#1}}\mathdef1051{85} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{xor}} \\ &&|&
  \def\mathdef1052#1{\mathtt{0x#1}}\mathdef1052{86} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{shl}} \\ &&|&
  \def\mathdef1053#1{\mathtt{0x#1}}\mathdef1053{87} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{shr}}\mathsf{\_s} \\ &&|&
  \def\mathdef1054#1{\mathtt{0x#1}}\mathdef1054{88} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{shr}}\mathsf{\_u} \\ &&|&
  \def\mathdef1055#1{\mathtt{0x#1}}\mathdef1055{89} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rotl}} \\ &&|&
  \def\mathdef1056#1{\mathtt{0x#1}}\mathdef1056{8A} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rotr}} \\
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef868#1{{}}\mathdef868{instruction}} & \phantom{\hyperref[binary/instructions:binary-instr]{\mathtt{instr}}} &\phantom{::=}& \phantom{\dots} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef1057#1{\mathtt{0x#1}}\mathdef1057{8B} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{abs}} \\ &&|&
  \def\mathdef1058#1{\mathtt{0x#1}}\mathdef1058{8C} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{neg}} \\ &&|&
  \def\mathdef1059#1{\mathtt{0x#1}}\mathdef1059{8D} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ceil}} \\ &&|&
  \def\mathdef1060#1{\mathtt{0x#1}}\mathdef1060{8E} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{floor}} \\ &&|&
  \def\mathdef1061#1{\mathtt{0x#1}}\mathdef1061{8F} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}} \\ &&|&
  \def\mathdef1062#1{\mathtt{0x#1}}\mathdef1062{90} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{nearest}} \\ &&|&
  \def\mathdef1063#1{\mathtt{0x#1}}\mathdef1063{91} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{sqrt}} \\ &&|&
  \def\mathdef1064#1{\mathtt{0x#1}}\mathdef1064{92} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}} \\ &&|&
  \def\mathdef1065#1{\mathtt{0x#1}}\mathdef1065{93} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{sub}} \\ &&|&
  \def\mathdef1066#1{\mathtt{0x#1}}\mathdef1066{94} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{mul}} \\ &&|&
  \def\mathdef1067#1{\mathtt{0x#1}}\mathdef1067{95} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{div}} \\ &&|&
  \def\mathdef1068#1{\mathtt{0x#1}}\mathdef1068{96} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{min}} \\ &&|&
  \def\mathdef1069#1{\mathtt{0x#1}}\mathdef1069{97} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{max}} \\ &&|&
  \def\mathdef1070#1{\mathtt{0x#1}}\mathdef1070{98} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{copysign}} \\
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef868#1{{}}\mathdef868{instruction}} & \phantom{\hyperref[binary/instructions:binary-instr]{\mathtt{instr}}} &\phantom{::=}& \phantom{\dots} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef1071#1{\mathtt{0x#1}}\mathdef1071{99} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{abs}} \\ &&|&
  \def\mathdef1072#1{\mathtt{0x#1}}\mathdef1072{9A} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{neg}} \\ &&|&
  \def\mathdef1073#1{\mathtt{0x#1}}\mathdef1073{9B} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ceil}} \\ &&|&
  \def\mathdef1074#1{\mathtt{0x#1}}\mathdef1074{9C} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{floor}} \\ &&|&
  \def\mathdef1075#1{\mathtt{0x#1}}\mathdef1075{9D} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}} \\ &&|&
  \def\mathdef1076#1{\mathtt{0x#1}}\mathdef1076{9E} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{nearest}} \\ &&|&
  \def\mathdef1077#1{\mathtt{0x#1}}\mathdef1077{9F} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{sqrt}} \\ &&|&
  \def\mathdef1078#1{\mathtt{0x#1}}\mathdef1078{A0} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}} \\ &&|&
  \def\mathdef1079#1{\mathtt{0x#1}}\mathdef1079{A1} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{sub}} \\ &&|&
  \def\mathdef1080#1{\mathtt{0x#1}}\mathdef1080{A2} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{mul}} \\ &&|&
  \def\mathdef1081#1{\mathtt{0x#1}}\mathdef1081{A3} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{div}} \\ &&|&
  \def\mathdef1082#1{\mathtt{0x#1}}\mathdef1082{A4} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{min}} \\ &&|&
  \def\mathdef1083#1{\mathtt{0x#1}}\mathdef1083{A5} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{max}} \\ &&|&
  \def\mathdef1084#1{\mathtt{0x#1}}\mathdef1084{A6} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{copysign}} \\
\end{array}\end{split}
\end{equation*}\phantomsection\label{\detokenize{binary/instructions:binary-cvtop}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef868#1{{}}\mathdef868{instruction}} & \phantom{\hyperref[binary/instructions:binary-instr]{\mathtt{instr}}} &\phantom{::=}& \phantom{\dots} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef1085#1{\mathtt{0x#1}}\mathdef1085{A7} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{wrap}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}} \\ &&|&
  \def\mathdef1086#1{\mathtt{0x#1}}\mathdef1086{A8} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}\mathsf{\_s} \\ &&|&
  \def\mathdef1087#1{\mathtt{0x#1}}\mathdef1087{A9} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}\mathsf{\_u} \\ &&|&
  \def\mathdef1088#1{\mathtt{0x#1}}\mathdef1088{AA} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}\mathsf{\_s} \\ &&|&
  \def\mathdef1089#1{\mathtt{0x#1}}\mathdef1089{AB} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}\mathsf{\_u} \\ &&|&
  \def\mathdef1090#1{\mathtt{0x#1}}\mathdef1090{AC} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{extend}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{\_s} \\ &&|&
  \def\mathdef1091#1{\mathtt{0x#1}}\mathdef1091{AD} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{extend}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{\_u} \\ &&|&
  \def\mathdef1092#1{\mathtt{0x#1}}\mathdef1092{AE} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}\mathsf{\_s} \\ &&|&
  \def\mathdef1093#1{\mathtt{0x#1}}\mathdef1093{AF} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}\mathsf{\_u} \\ &&|&
  \def\mathdef1094#1{\mathtt{0x#1}}\mathdef1094{B0} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}\mathsf{\_s} \\ &&|&
  \def\mathdef1095#1{\mathtt{0x#1}}\mathdef1095{B1} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}\mathsf{\_u} \\ &&|&
  \def\mathdef1096#1{\mathtt{0x#1}}\mathdef1096{B2} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{\_s} \\ &&|&
  \def\mathdef1097#1{\mathtt{0x#1}}\mathdef1097{B3} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{\_u} \\ &&|&
  \def\mathdef1098#1{\mathtt{0x#1}}\mathdef1098{B4} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}\mathsf{\_s} \\ &&|&
  \def\mathdef1099#1{\mathtt{0x#1}}\mathdef1099{B5} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}\mathsf{\_u} \\ &&|&
  \def\mathdef1100#1{\mathtt{0x#1}}\mathdef1100{B6} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{demote}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}} \\ &&|&
  \def\mathdef1101#1{\mathtt{0x#1}}\mathdef1101{B7} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{\_s} \\ &&|&
  \def\mathdef1102#1{\mathtt{0x#1}}\mathdef1102{B8} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{\_u} \\ &&|&
  \def\mathdef1103#1{\mathtt{0x#1}}\mathdef1103{B9} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}\mathsf{\_s} \\ &&|&
  \def\mathdef1104#1{\mathtt{0x#1}}\mathdef1104{BA} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}\mathsf{\_u} \\ &&|&
  \def\mathdef1105#1{\mathtt{0x#1}}\mathdef1105{BB} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{promote}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f32}} \\ &&|&
  \def\mathdef1106#1{\mathtt{0x#1}}\mathdef1106{BC} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{reinterpret}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f32}} \\ &&|&
  \def\mathdef1107#1{\mathtt{0x#1}}\mathdef1107{BD} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{reinterpret}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}} \\ &&|&
  \def\mathdef1108#1{\mathtt{0x#1}}\mathdef1108{BE} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{reinterpret}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}} \\ &&|&
  \def\mathdef1109#1{\mathtt{0x#1}}\mathdef1109{BF} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{reinterpret}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}} \\
\end{array}\end{split}
\end{equation*}
\index{expression}\index{binary format!expression}\index{expression!binary format}\index{expression!constant}\ignorespaces 

\subsection{Expressions}
\label{\detokenize{binary/instructions:expressions}}\label{\detokenize{binary/instructions:binary-expr}}\label{\detokenize{binary/instructions:index-6}}
{\hyperref[\detokenize{syntax/instructions:syntax-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{Expressions}}}} are encoded by their instruction sequence terminated with an explicit \(\def\mathdef1110#1{\mathtt{0x#1}}\mathdef1110{0B}\) opcode for \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\).
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef868#1{{}}\mathdef868{expression} & \hyperref[binary/instructions:binary-expr]{\mathtt{expr}} &::=&
  (\mathit{in}{:}\hyperref[binary/instructions:binary-instr]{\mathtt{instr}})^\ast~~\def\mathdef1111#1{\mathtt{0x#1}}\mathdef1111{0B} &\Rightarrow& \mathit{in}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \\
\end{array}\end{split}
\end{equation*}

\section{Modules}
\label{\detokenize{binary/modules::doc}}\label{\detokenize{binary/modules:modules}}
The binary encoding of modules is organized into \sphinxstyleemphasis{sections}.
Most sections correspond to one component of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}} record,
except that {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function definitions}}}} are split into two sections, separating their type declarations in the {\hyperref[\detokenize{binary/modules:binary-funcsec}]{\sphinxcrossref{\DUrole{std,std-ref}{function section}}}} from their bodies in the {\hyperref[\detokenize{binary/modules:binary-codesec}]{\sphinxcrossref{\DUrole{std,std-ref}{code section}}}}.

\begin{sphinxadmonition}{note}{Note:}
This separation enables \sphinxstyleemphasis{parallel} and \sphinxstyleemphasis{streaming} compilation of the functions in a module.
\end{sphinxadmonition}

\index{index}\index{type index}\index{function index}\index{table index}\index{memory index}\index{global index}\index{local index}\index{label index}\index{binary format!type index}\index{type index!binary format}\index{binary format!function index}\index{function index!binary format}\index{binary format!table index}\index{table index!binary format}\index{binary format!memory index}\index{memory index!binary format}\index{binary format!global index}\index{global index!binary format}\index{binary format!local index}\index{local index!binary format}\index{binary format!label index}\index{label index!binary format}\ignorespaces \phantomsection\label{\detokenize{binary/modules:binary-typeidx}}\phantomsection\label{\detokenize{binary/modules:binary-funcidx}}\phantomsection\label{\detokenize{binary/modules:binary-tableidx}}\phantomsection\label{\detokenize{binary/modules:binary-memidx}}\phantomsection\label{\detokenize{binary/modules:binary-globalidx}}\phantomsection\label{\detokenize{binary/modules:binary-localidx}}\phantomsection\label{\detokenize{binary/modules:binary-labelidx}}

\subsection{Indices}
\label{\detokenize{binary/modules:binary-tableidx}}\label{\detokenize{binary/modules:binary-localidx}}\label{\detokenize{binary/modules:binary-funcidx}}\label{\detokenize{binary/modules:binary-memidx}}\label{\detokenize{binary/modules:binary-index}}\label{\detokenize{binary/modules:binary-typeidx}}\label{\detokenize{binary/modules:binary-globalidx}}\label{\detokenize{binary/modules:indices}}\label{\detokenize{binary/modules:index-0}}\label{\detokenize{binary/modules:binary-labelidx}}
All {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{indices}}}} are encoded with their respective value.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1112#1{{}}\mathdef1112{type index} & \hyperref[binary/modules:binary-typeidx]{\mathtt{typeidx}} &::=& x{:}\hyperref[binary/values:binary-int]{\def\mathdef1139#1{{\mathtt{u}#1}}\mathdef1139{\mathtt{32}}} &\Rightarrow& x \\
\def\mathdef1112#1{{}}\mathdef1112{function index} & \hyperref[binary/modules:binary-funcidx]{\mathtt{funcidx}} &::=& x{:}\hyperref[binary/values:binary-int]{\def\mathdef1139#1{{\mathtt{u}#1}}\mathdef1139{\mathtt{32}}} &\Rightarrow& x \\
\def\mathdef1112#1{{}}\mathdef1112{table index} & \hyperref[binary/modules:binary-tableidx]{\mathtt{tableidx}} &::=& x{:}\hyperref[binary/values:binary-int]{\def\mathdef1139#1{{\mathtt{u}#1}}\mathdef1139{\mathtt{32}}} &\Rightarrow& x \\
\def\mathdef1112#1{{}}\mathdef1112{memory index} & \hyperref[binary/modules:binary-memidx]{\mathtt{memidx}} &::=& x{:}\hyperref[binary/values:binary-int]{\def\mathdef1139#1{{\mathtt{u}#1}}\mathdef1139{\mathtt{32}}} &\Rightarrow& x \\
\def\mathdef1112#1{{}}\mathdef1112{global index} & \hyperref[binary/modules:binary-globalidx]{\mathtt{globalidx}} &::=& x{:}\hyperref[binary/values:binary-int]{\def\mathdef1139#1{{\mathtt{u}#1}}\mathdef1139{\mathtt{32}}} &\Rightarrow& x \\
\def\mathdef1112#1{{}}\mathdef1112{local index} & \hyperref[binary/modules:binary-localidx]{\mathtt{localidx}} &::=& x{:}\hyperref[binary/values:binary-int]{\def\mathdef1139#1{{\mathtt{u}#1}}\mathdef1139{\mathtt{32}}} &\Rightarrow& x \\
\def\mathdef1112#1{{}}\mathdef1112{label index} & \hyperref[binary/modules:binary-labelidx]{\mathtt{labelidx}} &::=& l{:}\hyperref[binary/values:binary-int]{\def\mathdef1139#1{{\mathtt{u}#1}}\mathdef1139{\mathtt{32}}} &\Rightarrow& l \\
\end{array}\end{split}
\end{equation*}
\index{section|textbf}\index{binary format!section}\index{section!binary format}\ignorespaces 

\subsection{Sections}
\label{\detokenize{binary/modules:sections}}\label{\detokenize{binary/modules:index-1}}\label{\detokenize{binary/modules:binary-section}}
Each section consists of
\begin{itemize}
\item {} 
a one-byte section \sphinxstyleemphasis{id},

\item {} 
the \(\hyperref[syntax/values:syntax-int]{\def\mathdef1118#1{{\mathit{u}#1}}\mathdef1118{\mathit{32}}}\) \sphinxstyleemphasis{size} of the contents, in bytes,

\item {} 
the actual \sphinxstyleemphasis{contents}, whose structure is depended on the section id.

\end{itemize}

Every section is optional; an omitted section is equivalent to the section being present with empty contents.

The following parameterized grammar rule defines the generic structure of a section with id \(N\) and contents described by the grammar \(\mathtt{B}\).
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad}l}
\def\mathdef1112#1{{}}\mathdef1112{section} & \hyperref[binary/modules:binary-section]{\mathtt{section}}_N(\mathtt{B}) &::=&
  N{:}\hyperref[binary/values:binary-byte]{\mathtt{byte}}~~\mathit{size}{:}\hyperref[binary/values:binary-int]{\def\mathdef1139#1{{\mathtt{u}#1}}\mathdef1139{\mathtt{32}}}~~\mathit{cont}{:}\mathtt{B}
    &\Rightarrow& \mathit{cont} & (\mathrel{\mbox{if}} \mathit{size} = ||\mathtt{B}||) \\ &&|&
  \epsilon &\Rightarrow& \epsilon
\end{array}\end{split}
\end{equation*}
For most sections, the contents \(\mathtt{B}\) encodes a {\hyperref[\detokenize{binary/conventions:binary-vec}]{\sphinxcrossref{\DUrole{std,std-ref}{vector}}}}.
In these cases, the empty result \(\epsilon\) is interpreted as the empty vector.

\begin{sphinxadmonition}{note}{Note:}
Other than for unknown {\hyperref[\detokenize{binary/modules:binary-customsec}]{\sphinxcrossref{\DUrole{std,std-ref}{custom sections}}}},
the \(\mathit{size}\) is not required for decoding, but can be used to skip sections when navigating through a binary.
The module is malformed if the size does not match the length of the binary contents \(\mathtt{B}\).
\end{sphinxadmonition}

The following section ids are used:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Id
&\sphinxstyletheadfamily 
Section
\\
\hline
0
&
{\hyperref[\detokenize{binary/modules:binary-customsec}]{\sphinxcrossref{\DUrole{std,std-ref}{custom section}}}}
\\
\hline
1
&
{\hyperref[\detokenize{binary/modules:binary-typesec}]{\sphinxcrossref{\DUrole{std,std-ref}{type section}}}}
\\
\hline
2
&
{\hyperref[\detokenize{binary/modules:binary-importsec}]{\sphinxcrossref{\DUrole{std,std-ref}{import section}}}}
\\
\hline
3
&
{\hyperref[\detokenize{binary/modules:binary-funcsec}]{\sphinxcrossref{\DUrole{std,std-ref}{function section}}}}
\\
\hline
4
&
{\hyperref[\detokenize{binary/modules:binary-tablesec}]{\sphinxcrossref{\DUrole{std,std-ref}{table section}}}}
\\
\hline
5
&
{\hyperref[\detokenize{binary/modules:binary-memsec}]{\sphinxcrossref{\DUrole{std,std-ref}{memory section}}}}
\\
\hline
6
&
{\hyperref[\detokenize{binary/modules:binary-globalsec}]{\sphinxcrossref{\DUrole{std,std-ref}{global section}}}}
\\
\hline
7
&
{\hyperref[\detokenize{binary/modules:binary-exportsec}]{\sphinxcrossref{\DUrole{std,std-ref}{export section}}}}
\\
\hline
8
&
{\hyperref[\detokenize{binary/modules:binary-startsec}]{\sphinxcrossref{\DUrole{std,std-ref}{start section}}}}
\\
\hline
9
&
{\hyperref[\detokenize{binary/modules:binary-elemsec}]{\sphinxcrossref{\DUrole{std,std-ref}{element section}}}}
\\
\hline
10
&
{\hyperref[\detokenize{binary/modules:binary-codesec}]{\sphinxcrossref{\DUrole{std,std-ref}{code section}}}}
\\
\hline
11
&
{\hyperref[\detokenize{binary/modules:binary-datasec}]{\sphinxcrossref{\DUrole{std,std-ref}{data section}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\index{custom section|textbf}\index{binary format!custom section}\index{custom section!binary format}\index{section!custom}\ignorespaces 

\subsection{Custom Section}
\label{\detokenize{binary/modules:index-2}}\label{\detokenize{binary/modules:custom-section}}\label{\detokenize{binary/modules:binary-customsec}}
\sphinxstyleemphasis{Custom sections} have the id 0.
They are intended to be used for debugging information or third-party extensions, and are ignored by the WebAssembly semantics.
Their contents consist of a {\hyperref[\detokenize{syntax/values:syntax-name}]{\sphinxcrossref{\DUrole{std,std-ref}{name}}}} further identifying the custom section, followed by an uninterpreted sequence of bytes for custom use.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1112#1{{}}\mathdef1112{custom section} & \hyperref[binary/modules:binary-customsec]{\mathtt{customsec}} &::=&
  \hyperref[binary/modules:binary-section]{\mathtt{section}}_0(\hyperref[binary/modules:binary-customsec]{\mathtt{custom}}) \\
\def\mathdef1112#1{{}}\mathdef1112{custom data} & \hyperref[binary/modules:binary-customsec]{\mathtt{custom}} &::=&
  \hyperref[binary/values:binary-name]{\mathtt{name}}~~\hyperref[binary/values:binary-byte]{\mathtt{byte}}^\ast \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
If an implementation interprets the contents of a custom section, then errors in that contents, or the placement of the section, must not invalidate the module.
\end{sphinxadmonition}

\index{type section|textbf}\index{type definition}\index{binary format!type section}\index{type section!binary format}\index{section!type}\index{type!section}\ignorespaces \phantomsection\label{\detokenize{binary/modules:binary-typedef}}

\subsection{Type Section}
\label{\detokenize{binary/modules:binary-typesec}}\label{\detokenize{binary/modules:binary-typedef}}\label{\detokenize{binary/modules:index-3}}\label{\detokenize{binary/modules:type-section}}
The \sphinxstyleemphasis{type section} has the id 1.
It decodes into a vector of {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function types}}}} that represent the \(\hyperref[syntax/modules:syntax-module]{\mathsf{types}}\) component of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1112#1{{}}\mathdef1112{type section} & \hyperref[binary/modules:binary-typesec]{\mathtt{typesec}} &::=&
  \mathit{ft}^\ast{:\,}\hyperref[binary/modules:binary-section]{\mathtt{section}}_1(\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/types:binary-functype]{\mathtt{functype}})) &\Rightarrow& \mathit{ft}^\ast \\
\end{array}\end{split}
\end{equation*}
\index{import section|textbf}\index{import}\index{name}\index{function type}\index{table type}\index{memory type}\index{global type}\index{binary format!import}\index{import!binary format}\index{section!import}\index{import!section}\ignorespaces \phantomsection\label{\detokenize{binary/modules:binary-import}}\phantomsection\label{\detokenize{binary/modules:binary-importdesc}}

\subsection{Import Section}
\label{\detokenize{binary/modules:binary-import}}\label{\detokenize{binary/modules:index-4}}\label{\detokenize{binary/modules:binary-importdesc}}\label{\detokenize{binary/modules:import-section}}\label{\detokenize{binary/modules:binary-importsec}}
The \sphinxstyleemphasis{import section} has the id 2.
It decodes into a vector of {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}} that represent the \(\hyperref[syntax/modules:syntax-module]{\mathsf{imports}}\) component of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1112#1{{}}\mathdef1112{import section} & \hyperref[binary/modules:binary-importsec]{\mathtt{importsec}} &::=&
  \mathit{im}^\ast{:}\hyperref[binary/modules:binary-section]{\mathtt{section}}_2(\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/modules:binary-import]{\mathtt{import}})) &\Rightarrow& \mathit{im}^\ast \\
\def\mathdef1112#1{{}}\mathdef1112{import} & \hyperref[binary/modules:binary-import]{\mathtt{import}} &::=&
  \mathit{mod}{:}\hyperref[binary/values:binary-name]{\mathtt{name}}~~\mathit{nm}{:}\hyperref[binary/values:binary-name]{\mathtt{name}}~~d{:}\hyperref[binary/modules:binary-importdesc]{\mathtt{importdesc}}
    &\Rightarrow& \{ \hyperref[syntax/modules:syntax-import]{\mathsf{module}}~\mathit{mod}, \hyperref[syntax/modules:syntax-import]{\mathsf{name}}~\mathit{nm}, \hyperref[syntax/modules:syntax-import]{\mathsf{desc}}~d \} \\
\def\mathdef1112#1{{}}\mathdef1112{import description} & \hyperref[binary/modules:binary-importdesc]{\mathtt{importdesc}} &::=&
  \def\mathdef1171#1{\mathtt{0x#1}}\mathdef1171{00}~~x{:}\hyperref[binary/modules:binary-typeidx]{\mathtt{typeidx}} &\Rightarrow& \hyperref[syntax/modules:syntax-importdesc]{\mathsf{func}}~x \\ &&|&
  \def\mathdef1172#1{\mathtt{0x#1}}\mathdef1172{01}~~\mathit{tt}{:}\hyperref[binary/types:binary-tabletype]{\mathtt{tabletype}} &\Rightarrow& \hyperref[syntax/modules:syntax-importdesc]{\mathsf{table}}~\mathit{tt} \\ &&|&
  \def\mathdef1173#1{\mathtt{0x#1}}\mathdef1173{02}~~\mathit{mt}{:}\hyperref[binary/types:binary-memtype]{\mathtt{memtype}} &\Rightarrow& \hyperref[syntax/modules:syntax-importdesc]{\mathsf{mem}}~\mathit{mt} \\ &&|&
  \def\mathdef1174#1{\mathtt{0x#1}}\mathdef1174{03}~~\mathit{gt}{:}\hyperref[binary/types:binary-globaltype]{\mathtt{globaltype}} &\Rightarrow& \hyperref[syntax/modules:syntax-importdesc]{\mathsf{global}}~\mathit{gt} \\
\end{array}\end{split}
\end{equation*}
\index{function section|textbf}\index{function}\index{type index}\index{function type}\index{binary format!function}\index{function!binary format}\index{section!function}\index{function!section}\ignorespaces 

\subsection{Function Section}
\label{\detokenize{binary/modules:binary-funcsec}}\label{\detokenize{binary/modules:function-section}}\label{\detokenize{binary/modules:index-5}}
The \sphinxstyleemphasis{function section} has the id 3.
It decodes into a vector of {\hyperref[\detokenize{syntax/modules:syntax-typeidx}]{\sphinxcrossref{\DUrole{std,std-ref}{type indices}}}} that represent the \(\hyperref[syntax/modules:syntax-func]{\mathsf{type}}\) fields of the {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{functions}}}} in the \(\hyperref[syntax/modules:syntax-module]{\mathsf{funcs}}\) component of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}.
The \(\hyperref[syntax/modules:syntax-func]{\mathsf{locals}}\) and \(\hyperref[syntax/modules:syntax-func]{\mathsf{body}}\) fields of the respective functions are encoded separately in the {\hyperref[\detokenize{binary/modules:binary-codesec}]{\sphinxcrossref{\DUrole{std,std-ref}{code section}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1112#1{{}}\mathdef1112{function section} & \hyperref[binary/modules:binary-funcsec]{\mathtt{funcsec}} &::=&
  x^\ast{:}\hyperref[binary/modules:binary-section]{\mathtt{section}}_3(\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/modules:binary-typeidx]{\mathtt{typeidx}})) &\Rightarrow& x^\ast \\
\end{array}\end{split}
\end{equation*}
\index{table section|textbf}\index{table}\index{table type}\index{binary format!table}\index{table!binary format}\index{section!table}\index{table!section}\ignorespaces \phantomsection\label{\detokenize{binary/modules:binary-table}}

\subsection{Table Section}
\label{\detokenize{binary/modules:binary-tablesec}}\label{\detokenize{binary/modules:table-section}}\label{\detokenize{binary/modules:index-6}}\label{\detokenize{binary/modules:binary-table}}
The \sphinxstyleemphasis{table section} has the id 4.
It decodes into a vector of {\hyperref[\detokenize{syntax/modules:syntax-table}]{\sphinxcrossref{\DUrole{std,std-ref}{tables}}}} that represent the \(\hyperref[syntax/modules:syntax-module]{\mathsf{tables}}\) component of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1112#1{{}}\mathdef1112{table section} & \hyperref[binary/modules:binary-tablesec]{\mathtt{tablesec}} &::=&
  \mathit{tab}^\ast{:}\hyperref[binary/modules:binary-section]{\mathtt{section}}_4(\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/modules:binary-table]{\mathtt{table}})) &\Rightarrow& \mathit{tab}^\ast \\
\def\mathdef1112#1{{}}\mathdef1112{table} & \hyperref[binary/modules:binary-table]{\mathtt{table}} &::=&
  \mathit{tt}{:}\hyperref[binary/types:binary-tabletype]{\mathtt{tabletype}} &\Rightarrow& \{ \hyperref[syntax/modules:syntax-table]{\mathsf{type}}~\mathit{tt} \} \\
\end{array}\end{split}
\end{equation*}
\index{memory section|textbf}\index{memory}\index{memory type}\index{binary format!memory}\index{memory!binary format}\index{section!memory}\index{memory!section}\ignorespaces \phantomsection\label{\detokenize{binary/modules:binary-mem}}

\subsection{Memory Section}
\label{\detokenize{binary/modules:binary-mem}}\label{\detokenize{binary/modules:binary-memsec}}\label{\detokenize{binary/modules:memory-section}}\label{\detokenize{binary/modules:index-7}}
The \sphinxstyleemphasis{memory section} has the id 5.
It decodes into a vector of {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memories}}}} that represent the \(\hyperref[syntax/modules:syntax-module]{\mathsf{mems}}\) component of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1112#1{{}}\mathdef1112{memory section} & \hyperref[binary/modules:binary-memsec]{\mathtt{memsec}} &::=&
  \mathit{mem}^\ast{:}\hyperref[binary/modules:binary-section]{\mathtt{section}}_5(\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/modules:binary-mem]{\mathtt{mem}})) &\Rightarrow& \mathit{mem}^\ast \\
\def\mathdef1112#1{{}}\mathdef1112{memory} & \hyperref[binary/modules:binary-mem]{\mathtt{mem}} &::=&
  \mathit{mt}{:}\hyperref[binary/types:binary-memtype]{\mathtt{memtype}} &\Rightarrow& \{ \hyperref[syntax/modules:syntax-mem]{\mathsf{type}}~\mathit{mt} \} \\
\end{array}\end{split}
\end{equation*}
\index{global section|textbf}\index{global}\index{global type}\index{expression}\index{binary format!global}\index{global!binary format}\index{section!global}\index{global!section}\ignorespaces \phantomsection\label{\detokenize{binary/modules:binary-global}}

\subsection{Global Section}
\label{\detokenize{binary/modules:binary-global}}\label{\detokenize{binary/modules:global-section}}\label{\detokenize{binary/modules:index-8}}\label{\detokenize{binary/modules:binary-globalsec}}
The \sphinxstyleemphasis{global section} has the id 6.
It decodes into a vector of {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{globals}}}} that represent the \(\hyperref[syntax/modules:syntax-module]{\mathsf{globals}}\) component of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1112#1{{}}\mathdef1112{global section} & \hyperref[binary/modules:binary-globalsec]{\mathtt{globalsec}} &::=&
  \mathit{glob}^\ast{:}\hyperref[binary/modules:binary-section]{\mathtt{section}}_6(\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/modules:binary-global]{\mathtt{global}})) &\Rightarrow& \mathit{glob}^\ast \\
\def\mathdef1112#1{{}}\mathdef1112{global} & \hyperref[binary/modules:binary-global]{\mathtt{global}} &::=&
  \mathit{gt}{:}\hyperref[binary/types:binary-globaltype]{\mathtt{globaltype}}~~e{:}\hyperref[binary/instructions:binary-expr]{\mathtt{expr}}
    &\Rightarrow& \{ \hyperref[syntax/modules:syntax-global]{\mathsf{type}}~\mathit{gt}, \hyperref[syntax/modules:syntax-global]{\mathsf{init}}~e \} \\
\end{array}\end{split}
\end{equation*}
\index{export section|textbf}\index{export}\index{name}\index{index}\index{function index}\index{table index}\index{memory index}\index{global index}\index{binary format!export}\index{export!binary format}\index{section!export}\index{export!section}\ignorespaces \phantomsection\label{\detokenize{binary/modules:binary-export}}\phantomsection\label{\detokenize{binary/modules:binary-exportdesc}}

\subsection{Export Section}
\label{\detokenize{binary/modules:binary-export}}\label{\detokenize{binary/modules:index-9}}\label{\detokenize{binary/modules:binary-exportsec}}\label{\detokenize{binary/modules:export-section}}\label{\detokenize{binary/modules:binary-exportdesc}}
The \sphinxstyleemphasis{export section} has the id 7.
It decodes into a vector of {\hyperref[\detokenize{syntax/modules:syntax-export}]{\sphinxcrossref{\DUrole{std,std-ref}{exports}}}} that represent the \(\hyperref[syntax/modules:syntax-module]{\mathsf{exports}}\) component of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1112#1{{}}\mathdef1112{export section} & \hyperref[binary/modules:binary-exportsec]{\mathtt{exportsec}} &::=&
  \mathit{ex}^\ast{:}\hyperref[binary/modules:binary-section]{\mathtt{section}}_7(\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/modules:binary-export]{\mathtt{export}})) &\Rightarrow& \mathit{ex}^\ast \\
\def\mathdef1112#1{{}}\mathdef1112{export} & \hyperref[binary/modules:binary-export]{\mathtt{export}} &::=&
  \mathit{nm}{:}\hyperref[binary/values:binary-name]{\mathtt{name}}~~d{:}\hyperref[binary/modules:binary-exportdesc]{\mathtt{exportdesc}}
    &\Rightarrow& \{ \hyperref[syntax/modules:syntax-export]{\mathsf{name}}~\mathit{nm}, \hyperref[syntax/modules:syntax-export]{\mathsf{desc}}~d \} \\
\def\mathdef1112#1{{}}\mathdef1112{export description} & \hyperref[binary/modules:binary-exportdesc]{\mathtt{exportdesc}} &::=&
  \def\mathdef1175#1{\mathtt{0x#1}}\mathdef1175{00}~~x{:}\hyperref[binary/modules:binary-funcidx]{\mathtt{funcidx}} &\Rightarrow& \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{func}}~x \\ &&|&
  \def\mathdef1176#1{\mathtt{0x#1}}\mathdef1176{01}~~x{:}\hyperref[binary/modules:binary-tableidx]{\mathtt{tableidx}} &\Rightarrow& \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{table}}~x \\ &&|&
  \def\mathdef1177#1{\mathtt{0x#1}}\mathdef1177{02}~~x{:}\hyperref[binary/modules:binary-memidx]{\mathtt{memidx}} &\Rightarrow& \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{mem}}~x \\ &&|&
  \def\mathdef1178#1{\mathtt{0x#1}}\mathdef1178{03}~~x{:}\hyperref[binary/modules:binary-globalidx]{\mathtt{globalidx}} &\Rightarrow& \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{global}}~x \\
\end{array}\end{split}
\end{equation*}
\index{start section|textbf}\index{start function}\index{function index}\index{binary format!start function}\index{start function!binary format}\index{section!start}\index{start function!section}\ignorespaces \phantomsection\label{\detokenize{binary/modules:binary-start}}

\subsection{Start Section}
\label{\detokenize{binary/modules:binary-startsec}}\label{\detokenize{binary/modules:index-10}}\label{\detokenize{binary/modules:binary-start}}\label{\detokenize{binary/modules:start-section}}
The \sphinxstyleemphasis{start section} has the id 8.
It decodes into an optional {\hyperref[\detokenize{syntax/modules:syntax-start}]{\sphinxcrossref{\DUrole{std,std-ref}{start function}}}} that represents the \(\hyperref[syntax/modules:syntax-module]{\mathsf{start}}\) component of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1112#1{{}}\mathdef1112{start section} & \hyperref[binary/modules:binary-startsec]{\mathtt{startsec}} &::=&
  \mathit{st}^?{:}\hyperref[binary/modules:binary-section]{\mathtt{section}}_8(\hyperref[binary/modules:binary-start]{\mathtt{start}}) &\Rightarrow& \mathit{st}^? \\
\def\mathdef1112#1{{}}\mathdef1112{start function} & \hyperref[binary/modules:binary-start]{\mathtt{start}} &::=&
  x{:}\hyperref[binary/modules:binary-funcidx]{\mathtt{funcidx}} &\Rightarrow& \{ \hyperref[syntax/modules:syntax-start]{\mathsf{func}}~x \} \\
\end{array}\end{split}
\end{equation*}
\index{element section|textbf}\index{element}\index{table index}\index{expression}\index{function index}\index{binary format!element}\index{element!binary format}\index{section!element}\index{element!section}\index{table!element}\index{element!segment}\ignorespaces \phantomsection\label{\detokenize{binary/modules:binary-elem}}

\subsection{Element Section}
\label{\detokenize{binary/modules:binary-elem}}\label{\detokenize{binary/modules:binary-elemsec}}\label{\detokenize{binary/modules:index-11}}\label{\detokenize{binary/modules:element-section}}
The \sphinxstyleemphasis{element section} has the id 9.
It decodes into a vector of {\hyperref[\detokenize{syntax/modules:syntax-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{element segments}}}} that represent the \(\hyperref[syntax/modules:syntax-module]{\mathsf{elem}}\) component of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1112#1{{}}\mathdef1112{element section} & \hyperref[binary/modules:binary-elemsec]{\mathtt{elemsec}} &::=&
  \mathit{seg}^\ast{:}\hyperref[binary/modules:binary-section]{\mathtt{section}}_9(\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/modules:binary-elem]{\mathtt{elem}})) &\Rightarrow& \mathit{seg} \\
\def\mathdef1112#1{{}}\mathdef1112{element segment} & \hyperref[binary/modules:binary-elem]{\mathtt{elem}} &::=&
  x{:}\hyperref[binary/modules:binary-tableidx]{\mathtt{tableidx}}~~e{:}\hyperref[binary/instructions:binary-expr]{\mathtt{expr}}~~y^\ast{:}\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/modules:binary-funcidx]{\mathtt{funcidx}})
    &\Rightarrow& \{ \hyperref[syntax/modules:syntax-elem]{\mathsf{table}}~x, \hyperref[syntax/modules:syntax-elem]{\mathsf{offset}}~e, \hyperref[syntax/modules:syntax-elem]{\mathsf{init}}~y^\ast \} \\
\end{array}\end{split}
\end{equation*}
\index{code section|textbf}\index{function}\index{local}\index{type index}\index{function type}\index{binary format!function}\index{function!binary format}\index{binary format!local}\index{local!binary format}\index{section!code}\index{code!section}\ignorespaces \phantomsection\label{\detokenize{binary/modules:binary-code}}\phantomsection\label{\detokenize{binary/modules:binary-func}}\phantomsection\label{\detokenize{binary/modules:binary-local}}

\subsection{Code Section}
\label{\detokenize{binary/modules:index-12}}\label{\detokenize{binary/modules:code-section}}\label{\detokenize{binary/modules:binary-codesec}}\label{\detokenize{binary/modules:binary-local}}\label{\detokenize{binary/modules:binary-func}}\label{\detokenize{binary/modules:binary-code}}
The \sphinxstyleemphasis{code section} has the id 10.
It decodes into a vector of \sphinxstyleemphasis{code} entries that are pairs of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} vectors and {\hyperref[\detokenize{syntax/instructions:syntax-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{expressions}}}}.
They represent the \(\hyperref[syntax/modules:syntax-func]{\mathsf{locals}}\) and \(\hyperref[syntax/modules:syntax-func]{\mathsf{body}}\) field of the {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{functions}}}} in the \(\hyperref[syntax/modules:syntax-module]{\mathsf{funcs}}\) component of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}.
The \(\hyperref[syntax/modules:syntax-func]{\mathsf{type}}\) fields of the respective functions are encoded separately in the {\hyperref[\detokenize{binary/modules:binary-funcsec}]{\sphinxcrossref{\DUrole{std,std-ref}{function section}}}}.

The encoding of each code entry consists of
\begin{itemize}
\item {} 
the \(\hyperref[syntax/values:syntax-int]{\def\mathdef1118#1{{\mathit{u}#1}}\mathdef1118{\mathit{32}}}\) \sphinxstyleemphasis{size} of the function code in bytes,

\item {} 
the actual \sphinxstyleemphasis{function code}, which in turn consists of
\begin{itemize}
\item {} 
the declaration of \sphinxstyleemphasis{locals},

\item {} 
the function \sphinxstyleemphasis{body} as an {\hyperref[\detokenize{binary/instructions:binary-expr}]{\sphinxcrossref{\DUrole{std,std-ref}{expression}}}}.

\end{itemize}

\end{itemize}

Local declarations are compressed into a vector whose entries consist of
\begin{itemize}
\item {} 
a \(\hyperref[syntax/values:syntax-int]{\def\mathdef1118#1{{\mathit{u}#1}}\mathdef1118{\mathit{32}}}\) \sphinxstyleemphasis{count},

\item {} 
a {\hyperref[\detokenize{binary/types:binary-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}},

\end{itemize}

denoting \sphinxstyleemphasis{count} locals of the same value type.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad}l}
\def\mathdef1112#1{{}}\mathdef1112{code section} & \hyperref[binary/modules:binary-codesec]{\mathtt{codesec}} &::=&
  \mathit{code}^\ast{:}\hyperref[binary/modules:binary-section]{\mathtt{section}}_{10}(\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/modules:binary-code]{\mathtt{code}}))
    &\Rightarrow& \mathit{code}^\ast \\
\def\mathdef1112#1{{}}\mathdef1112{code} & \hyperref[binary/modules:binary-code]{\mathtt{code}} &::=&
  \mathit{size}{:}\hyperref[binary/values:binary-int]{\def\mathdef1139#1{{\mathtt{u}#1}}\mathdef1139{\mathtt{32}}}~~\mathit{code}{:}\hyperref[binary/modules:binary-func]{\mathtt{func}}
    &\Rightarrow& \mathit{code} & (\mathrel{\mbox{if}} \mathit{size} = ||\hyperref[binary/modules:binary-func]{\mathtt{func}}||) \\
\def\mathdef1112#1{{}}\mathdef1112{function} & \hyperref[binary/modules:binary-func]{\mathtt{func}} &::=&
  (t^\ast)^\ast{:}\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/modules:binary-local]{\mathtt{locals}})~~e{:}\hyperref[binary/instructions:binary-expr]{\mathtt{expr}}
    &\Rightarrow& \hyperref[syntax/conventions:notation-concat]{\mathrm{concat}}((t^\ast)^\ast), e^\ast
      & (\mathrel{\mbox{if}} |\hyperref[syntax/conventions:notation-concat]{\mathrm{concat}}((t^\ast)^\ast)| < 2^{32}) \\
\def\mathdef1112#1{{}}\mathdef1112{locals} & \hyperref[binary/modules:binary-local]{\mathtt{locals}} &::=&
  n{:}\hyperref[binary/values:binary-int]{\def\mathdef1139#1{{\mathtt{u}#1}}\mathdef1139{\mathtt{32}}}~~t{:}\hyperref[binary/types:binary-valtype]{\mathtt{valtype}} &\Rightarrow& t^n \\
\end{array}\end{split}
\end{equation*}
Here, \(\mathit{code}\) ranges over pairs \((\hyperref[syntax/types:syntax-valtype]{\mathit{valtype}}^\ast, \hyperref[syntax/instructions:syntax-expr]{\mathit{expr}})\).
The meta function \(\hyperref[syntax/conventions:notation-concat]{\mathrm{concat}}((t^\ast)^\ast)\) concatenates all sequences \(t_i^\ast\) in \((t^\ast)^\ast\).
Any code for which the length of the resulting sequence is out of bounds of the maximum size of a {\hyperref[\detokenize{syntax/conventions:syntax-vec}]{\sphinxcrossref{\DUrole{std,std-ref}{vector}}}} is malformed.

\begin{sphinxadmonition}{note}{Note:}
Like with {\hyperref[\detokenize{binary/modules:binary-section}]{\sphinxcrossref{\DUrole{std,std-ref}{sections}}}}, the code \(\mathit{size}\) is not needed for decoding, but can be used to skip functions when navigating through a binary.
The module is malformed if a size does not match the length of the respective function code.
\end{sphinxadmonition}

\index{data section|textbf}\index{data}\index{memory}\index{memory index}\index{expression}\index{byte}\index{binary format!data}\index{data!binary format}\index{section!data}\index{data!section}\index{memory!data}\index{data!segment}\ignorespaces \phantomsection\label{\detokenize{binary/modules:binary-data}}

\subsection{Data Section}
\label{\detokenize{binary/modules:index-13}}\label{\detokenize{binary/modules:data-section}}\label{\detokenize{binary/modules:binary-data}}\label{\detokenize{binary/modules:binary-datasec}}
The \sphinxstyleemphasis{data section} has the id 11.
It decodes into a vector of {\hyperref[\detokenize{syntax/modules:syntax-data}]{\sphinxcrossref{\DUrole{std,std-ref}{data segments}}}} that represent the \(\hyperref[syntax/modules:syntax-module]{\mathsf{data}}\) component of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef1112#1{{}}\mathdef1112{data section} & \hyperref[binary/modules:binary-datasec]{\mathtt{datasec}} &::=&
  \mathit{seg}^\ast{:}\hyperref[binary/modules:binary-section]{\mathtt{section}}_{11}(\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/modules:binary-data]{\mathtt{data}})) &\Rightarrow& \mathit{seg} \\
\def\mathdef1112#1{{}}\mathdef1112{data segment} & \hyperref[binary/modules:binary-data]{\mathtt{data}} &::=&
  x{:}\hyperref[binary/modules:binary-memidx]{\mathtt{memidx}}~~e{:}\hyperref[binary/instructions:binary-expr]{\mathtt{expr}}~~b^\ast{:}\hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[binary/values:binary-byte]{\mathtt{byte}})
    &\Rightarrow& \{ \hyperref[syntax/modules:syntax-data]{\mathsf{data}}~x, \hyperref[syntax/modules:syntax-data]{\mathsf{offset}}~e, \hyperref[syntax/modules:syntax-data]{\mathsf{init}}~b^\ast \} \\
\end{array}\end{split}
\end{equation*}
\index{module}\index{section}\index{type definition}\index{function type}\index{function}\index{table}\index{memory}\index{global}\index{element}\index{data}\index{start function}\index{import}\index{export}\index{context}\index{version}\index{binary format!module}\index{module!binary format}\ignorespaces \phantomsection\label{\detokenize{binary/modules:binary-magic}}\phantomsection\label{\detokenize{binary/modules:binary-version}}

\subsection{Modules}
\label{\detokenize{binary/modules:index-14}}\label{\detokenize{binary/modules:binary-version}}\label{\detokenize{binary/modules:binary-magic}}\label{\detokenize{binary/modules:id1}}\label{\detokenize{binary/modules:binary-module}}
The encoding of a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}} starts with a preamble containing a 4-byte magic number (the string \(\def\mathdef1179#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef1179{\backslash0asm}\)) and a version field.
The current version of the WebAssembly binary format is 1.

The preamble is followed by a sequence of {\hyperref[\detokenize{binary/modules:binary-section}]{\sphinxcrossref{\DUrole{std,std-ref}{sections}}}}.
{\hyperref[\detokenize{binary/modules:binary-customsec}]{\sphinxcrossref{\DUrole{std,std-ref}{Custom sections}}}} may be inserted at any place in this sequence,
while other sections must occur at most once and in the prescribed order.
All sections can be empty.
The lengths of vectors produced by the (possibly empty) {\hyperref[\detokenize{binary/modules:binary-funcsec}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}} and {\hyperref[\detokenize{binary/modules:binary-codesec}]{\sphinxcrossref{\DUrole{std,std-ref}{code}}}} section must match up.
\begin{equation*}
\begin{split}\begin{array}{llcllll}
\def\mathdef1112#1{{}}\mathdef1112{magic} & \hyperref[binary/modules:binary-magic]{\mathtt{magic}} &::=&
  \def\mathdef1180#1{\mathtt{0x#1}}\mathdef1180{00}~\def\mathdef1181#1{\mathtt{0x#1}}\mathdef1181{61}~\def\mathdef1182#1{\mathtt{0x#1}}\mathdef1182{73}~\def\mathdef1183#1{\mathtt{0x#1}}\mathdef1183{6D} \\
\def\mathdef1112#1{{}}\mathdef1112{version} & \hyperref[binary/modules:binary-version]{\mathtt{version}} &::=&
  \def\mathdef1184#1{\mathtt{0x#1}}\mathdef1184{01}~\def\mathdef1185#1{\mathtt{0x#1}}\mathdef1185{00}~\def\mathdef1186#1{\mathtt{0x#1}}\mathdef1186{00}~\def\mathdef1187#1{\mathtt{0x#1}}\mathdef1187{00} \\
\def\mathdef1112#1{{}}\mathdef1112{module} & \hyperref[binary/modules:binary-module]{\mathtt{module}} &::=&
  \hyperref[binary/modules:binary-magic]{\mathtt{magic}} \\ &&&
  \hyperref[binary/modules:binary-version]{\mathtt{version}} \\ &&&
  \hyperref[binary/modules:binary-customsec]{\mathtt{customsec}}^\ast \\ &&&
  \hyperref[syntax/types:syntax-functype]{\mathit{functype}}^\ast{:\,}\hyperref[binary/modules:binary-typesec]{\mathtt{typesec}} \\ &&&
  \hyperref[binary/modules:binary-customsec]{\mathtt{customsec}}^\ast \\ &&&
  \hyperref[syntax/modules:syntax-import]{\mathit{import}}^\ast{:\,}\hyperref[binary/modules:binary-importsec]{\mathtt{importsec}} \\ &&&
  \hyperref[binary/modules:binary-customsec]{\mathtt{customsec}}^\ast \\ &&&
  \hyperref[syntax/modules:syntax-typeidx]{\mathit{typeidx}}^n{:\,}\hyperref[binary/modules:binary-funcsec]{\mathtt{funcsec}} \\ &&&
  \hyperref[binary/modules:binary-customsec]{\mathtt{customsec}}^\ast \\ &&&
  \hyperref[syntax/modules:syntax-table]{\mathit{table}}^\ast{:\,}\hyperref[binary/modules:binary-tablesec]{\mathtt{tablesec}} \\ &&&
  \hyperref[binary/modules:binary-customsec]{\mathtt{customsec}}^\ast \\ &&&
  \hyperref[syntax/modules:syntax-mem]{\mathit{mem}}^\ast{:\,}\hyperref[binary/modules:binary-memsec]{\mathtt{memsec}} \\ &&&
  \hyperref[binary/modules:binary-customsec]{\mathtt{customsec}}^\ast \\ &&&
  \hyperref[syntax/modules:syntax-global]{\mathit{global}}^\ast{:\,}\hyperref[binary/modules:binary-globalsec]{\mathtt{globalsec}} \\ &&&
  \hyperref[binary/modules:binary-customsec]{\mathtt{customsec}}^\ast \\ &&&
  \hyperref[syntax/modules:syntax-export]{\mathit{export}}^\ast{:\,}\hyperref[binary/modules:binary-exportsec]{\mathtt{exportsec}} \\ &&&
  \hyperref[binary/modules:binary-customsec]{\mathtt{customsec}}^\ast \\ &&&
  \hyperref[syntax/modules:syntax-start]{\mathit{start}}^?{:\,}\hyperref[binary/modules:binary-startsec]{\mathtt{startsec}} \\ &&&
  \hyperref[binary/modules:binary-customsec]{\mathtt{customsec}}^\ast \\ &&&
  \hyperref[syntax/modules:syntax-elem]{\mathit{elem}}^\ast{:\,}\hyperref[binary/modules:binary-elemsec]{\mathtt{elemsec}} \\ &&&
  \hyperref[binary/modules:binary-customsec]{\mathtt{customsec}}^\ast \\ &&&
  \mathit{code}^n{:\,}\hyperref[binary/modules:binary-codesec]{\mathtt{codesec}} \\ &&&
  \hyperref[binary/modules:binary-customsec]{\mathtt{customsec}}^\ast \\ &&&
  \hyperref[syntax/modules:syntax-data]{\mathit{data}}^\ast{:\,}\hyperref[binary/modules:binary-datasec]{\mathtt{datasec}} \\ &&&
  \hyperref[binary/modules:binary-customsec]{\mathtt{customsec}}^\ast
  \quad\Rightarrow\quad \{~
    \begin{array}[t]{@{}l@{}}
    \hyperref[syntax/modules:syntax-module]{\mathsf{types}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}^\ast, \\
    \hyperref[syntax/modules:syntax-module]{\mathsf{funcs}}~\hyperref[syntax/modules:syntax-func]{\mathit{func}}^n, \\
    \hyperref[syntax/modules:syntax-module]{\mathsf{tables}}~\hyperref[syntax/modules:syntax-table]{\mathit{table}}^\ast, \\
    \hyperref[syntax/modules:syntax-module]{\mathsf{mems}}~\hyperref[syntax/modules:syntax-mem]{\mathit{mem}}^\ast, \\
    \hyperref[syntax/modules:syntax-module]{\mathsf{globals}}~\hyperref[syntax/modules:syntax-global]{\mathit{global}}^\ast, \\
    \hyperref[syntax/modules:syntax-module]{\mathsf{elem}}~\hyperref[syntax/modules:syntax-elem]{\mathit{elem}}^\ast, \\
    \hyperref[syntax/modules:syntax-module]{\mathsf{data}}~\hyperref[syntax/modules:syntax-data]{\mathit{data}}^\ast, \\
    \hyperref[syntax/modules:syntax-module]{\mathsf{start}}~\hyperref[syntax/modules:syntax-start]{\mathit{start}}^?, \\
    \hyperref[syntax/modules:syntax-module]{\mathsf{imports}}~\hyperref[syntax/modules:syntax-import]{\mathit{import}}^\ast, \\
    \hyperref[syntax/modules:syntax-module]{\mathsf{exports}}~\hyperref[syntax/modules:syntax-export]{\mathit{export}}^\ast ~\} \\
   \end{array} \\
\end{array}\end{split}
\end{equation*}
where for each \(t_i^\ast, e_i\) in \(\mathit{code}^n\),
\begin{equation*}
\begin{split}\hyperref[syntax/modules:syntax-func]{\mathit{func}}^n[i] = \{ \hyperref[syntax/modules:syntax-func]{\mathsf{type}}~\hyperref[syntax/modules:syntax-typeidx]{\mathit{typeidx}}^n[i], \hyperref[syntax/modules:syntax-func]{\mathsf{locals}}~t_i^\ast, \hyperref[syntax/modules:syntax-func]{\mathsf{body}}~e_i \} ) \\\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The version of the WebAssembly binary format may increase in the future
if backward-incompatible changes have to be made to the format.
However, such changes are expected to occur very infrequently, if ever.
The binary format is intended to be forward-compatible,
such that future extensions can be made without incrementing its version.
\end{sphinxadmonition}


\chapter{Text Format}
\label{\detokenize{text/index:text-format}}\label{\detokenize{text/index::doc}}\label{\detokenize{text/index:text}}
\index{text format|textbf}\index{Unicode}\index{UTF-8}\index{S-expression}\index{identifier}\index{file extension}\index{abstract syntax}\ignorespaces 

\section{Conventions}
\label{\detokenize{text/conventions:conventions}}\label{\detokenize{text/conventions::doc}}\label{\detokenize{text/conventions:index-0}}
The textual format for WebAssembly {\hyperref[\detokenize{intro/overview:module}]{\sphinxcrossref{\DUrole{std,std-ref}{modules}}}} is a rendering of their {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{abstract syntax}}}} into \sphinxhref{https://en.wikipedia.org/wiki/S-expression}{S-expressions}%
\begin{footnote}[35]\sphinxAtStartFootnote
\sphinxnolinkurl{https://en.wikipedia.org/wiki/S-expression}
%
\end{footnote}.

Like the {\hyperref[\detokenize{binary/index:binary}]{\sphinxcrossref{\DUrole{std,std-ref}{binary format}}}}, the text format is defined by an \sphinxstyleemphasis{attribute grammar}.
A text string is a well-formed description of a module if and only if it is generated by the grammar.
Each production of this grammar has at most one synthesized attribute: the abstract syntax that the respective character sequence expresses.
Thus, the attribute grammar implicitly defines a \sphinxstyleemphasis{parsing} function.
Some productions also take a {\hyperref[\detokenize{text/conventions:text-context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} as an inherited attribute
that records bound {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{identifers}}}}.

Except for a few exceptions, the core of the text grammar closely mirrors the grammar of the abstract syntax.
However, it also defines a number of \sphinxstyleemphasis{abbreviations} that are “syntactic sugar” over the core syntax.

The recommended extension for files containing WebAssembly modules in text format is “\(\mathtt{.wat}\)”.
Files with this extension are assumed to be encoded in UTF-8, as per \sphinxhref{http://www.unicode.org/versions/latest/}{Unicode}%
\begin{footnote}[36]\sphinxAtStartFootnote
\sphinxnolinkurl{http://www.unicode.org/versions/latest/}
%
\end{footnote} (Section 2.5).

\index{grammar notation}\index{notation}\index{Unicode}\index{text format!grammar}\index{text format!notation}\index{notation!text format}\ignorespaces 

\subsection{Grammar}
\label{\detokenize{text/conventions:grammar}}\label{\detokenize{text/conventions:text-grammar}}\label{\detokenize{text/conventions:index-1}}
The following conventions are adopted in defining grammar rules of the text format.
They mirror the conventions used for {\hyperref[\detokenize{syntax/conventions:grammar}]{\sphinxcrossref{\DUrole{std,std-ref}{abstract syntax}}}} and for the {\hyperref[\detokenize{binary/index:binary}]{\sphinxcrossref{\DUrole{std,std-ref}{binary format}}}}.
In order to distinguish symbols of the textual syntax from symbols of the abstract syntax, \(\mathtt{typewriter}\) font is adopted for the former.
\begin{itemize}
\item {} 
Terminal symbols are either literal strings of characters enclosed in quotes
or expressed as \sphinxhref{http://www.unicode.org/versions/latest/}{Unicode}%
\begin{footnote}[37]\sphinxAtStartFootnote
\sphinxnolinkurl{http://www.unicode.org/versions/latest/}
%
\end{footnote} code points: \(\def\mathdef2374#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2374{module}\), \(\def\mathdef2375#1{\mathrm{U{+}#1}}\mathdef2375{0A}\).
(All characters written literally are unambiguously drawn from the 7-bit \sphinxhref{http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986\%5bR2012\%5d}{ASCII}%
\begin{footnote}[38]\sphinxAtStartFootnote
\sphinxnolinkurl{http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986\%5bR2012\%5d}
%
\end{footnote} subset of Unicode.)

\item {} 
Nonterminal symbols are written in typewriter font: \(\mathtt{valtype}, \mathtt{instr}\).

\item {} 
\(T^n\) is a sequence of \(n\geq 0\) iterations  of \(T\).

\item {} 
\(T^\ast\) is a possibly empty sequence of iterations of \(T\).
(This is a shorthand for \(T^n\) used where \(n\) is not relevant.)

\item {} 
\(T^+\) is a sequence of one or more iterations of \(T\).
(This is a shorthand for \(T^n\) where \(n \geq 1\).)

\item {} 
\(T^?\) is an optional occurrence of \(T\).
(This is a shorthand for \(T^n\) where \(n \leq 1\).)

\item {} 
\(x{:}T\) denotes the same language as the nonterminal \(T\), but also binds the variable \(x\) to the attribute synthesized for \(T\).

\item {} 
Productions are written \(\mathtt{sym} ::= T_1 \Rightarrow A_1 ~|~ \dots ~|~ T_n \Rightarrow A_n\), where each \(A_i\) is the attribute that is synthesized for \(\mathtt{sym}\) in the given case, usually from attribute variables bound in \(T_i\).

\item {} 
Some productions are augmented by side conditions in parentheses, which restrict the applicability of the production. They provide a shorthand for a combinatorial expansion of the production into many separate cases.

\end{itemize}
\phantomsection\label{\detokenize{text/conventions:text-syntactic}}\begin{itemize}
\item {} 
A distinction is made between \sphinxstyleemphasis{lexical} and \sphinxstyleemphasis{syntactic} productions. For the latter, arbitrary {\hyperref[\detokenize{text/lexical:text-space}]{\sphinxcrossref{\DUrole{std,std-ref}{white space}}}} is allowed in any place where the grammar contains spaces. The productions defining {\hyperref[\detokenize{text/lexical:text-lexical}]{\sphinxcrossref{\DUrole{std,std-ref}{lexical syntax}}}} and the syntax of {\hyperref[\detokenize{text/values:text-value}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} are considered lexical, all others are syntactic.

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
For example, the {\hyperref[\detokenize{text/types:text-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{textual grammar}}}} for {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} is given as follows:
\begin{equation*}
\begin{split}\begin{array}{llcll@{\qquad\qquad}l}
\def\mathdef2315#1{{}}\mathdef2315{value types} & \hyperref[text/types:text-valtype]{\mathtt{valtype}} &::=&
  \def\mathdef2376#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2376{i32} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}} \\ &&|&
  \def\mathdef2377#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2377{i64} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}} \\ &&|&
  \def\mathdef2378#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2378{f32} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}} \\ &&|&
  \def\mathdef2379#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2379{f64} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}} \\
\end{array}\end{split}
\end{equation*}
The {\hyperref[\detokenize{text/types:text-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{textual grammar}}}} for {\hyperref[\detokenize{syntax/types:syntax-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{limits}}}} is defined as follows:
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2315#1{{}}\mathdef2315{limits} & \hyperref[text/types:text-limits]{\mathtt{limits}} &::=&
  n{:}\hyperref[text/values:text-int]{\def\mathdef2362#1{{\mathtt{u}#1}}\mathdef2362{\mathtt{32}}} &\Rightarrow& \{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~\epsilon \} \\ &&|&
  n{:}\hyperref[text/values:text-int]{\def\mathdef2362#1{{\mathtt{u}#1}}\mathdef2362{\mathtt{32}}}~~m{:}\hyperref[text/values:text-int]{\def\mathdef2362#1{{\mathtt{u}#1}}\mathdef2362{\mathtt{32}}} &\Rightarrow& \{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m \} \\
\end{array}\end{split}
\end{equation*}
The variables \(n\) and \(m\) name the attributes of the respective \(\hyperref[text/values:text-int]{\def\mathdef2362#1{{\mathtt{u}#1}}\mathdef2362{\mathtt{32}}}\) nonterminals, which in this case are the actual {\hyperref[\detokenize{syntax/values:syntax-uint}]{\sphinxcrossref{\DUrole{std,std-ref}{unsigned integers}}}} those parse into.
The attribute of the complete production then is the abstract syntax for the limit, expressed in terms of the former values.
\end{sphinxadmonition}

\index{abbreviations|textbf}\index{rewrite rule}\ignorespaces 

\subsection{Abbreviations}
\label{\detokenize{text/conventions:index-2}}\label{\detokenize{text/conventions:abbreviations}}\label{\detokenize{text/conventions:text-abbreviations}}
In addition to the core grammar, which corresponds directly to the {\hyperref[\detokenize{syntax/index:syntax}]{\sphinxcrossref{\DUrole{std,std-ref}{abstract syntax}}}}, the textual syntax also defines a number of \sphinxstyleemphasis{abbreviations} that can be used for convenience and readability.

Abbreviations are defined by \sphinxstyleemphasis{rewrite rules} specifying their expansion into the core syntax:
\begin{equation*}
\begin{split}\mathit{abbreviation~syntax} \quad\equiv\quad \mathit{expanded~syntax}\end{split}
\end{equation*}
These expansions are assumed to be applied, recursively and in order of appearance, before applying the core grammar rules to construct the abstract syntax.

\index{identifier context|textbf}\index{identifier}\index{index}\index{index space}\ignorespaces \phantomsection\label{\detokenize{text/conventions:text-context-wf}}

\subsection{Contexts}
\label{\detokenize{text/conventions:index-3}}\label{\detokenize{text/conventions:contexts}}\label{\detokenize{text/conventions:text-context}}\label{\detokenize{text/conventions:text-context-wf}}
The text format allows the use of symbolic {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{identifiers}}}} in place of {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{indices}}}}.
To resolve these identifiers into concrete indices,
some grammar production are indexed by an \sphinxstyleemphasis{identifier context} \(I\) as a synthesized attribute that records the declared identifiers in each {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{index space}}}}.
In addition, the context records the types defined in the module, so that {\hyperref[\detokenize{text/types:text-param}]{\sphinxcrossref{\DUrole{std,std-ref}{parameter}}}} indices can be computed for {\hyperref[\detokenize{text/modules:text-func}]{\sphinxcrossref{\DUrole{std,std-ref}{functions}}}}.

It is convenient to define identifier contexts as {\hyperref[\detokenize{syntax/conventions:notation-record}]{\sphinxcrossref{\DUrole{std,std-ref}{records}}}} \(I\) with abstract syntax as follows:
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2315#1{{}}\mathdef2315{(identifier context)} & I &::=&
  \begin{array}[t]{l@{~}ll}
  \{ & \hyperref[text/conventions:text-context]{\mathsf{types}} & (\hyperref[text/values:text-id]{\mathtt{id}}^?)^\ast, \\
     & \hyperref[text/conventions:text-context]{\mathsf{funcs}} & (\hyperref[text/values:text-id]{\mathtt{id}}^?)^\ast, \\
     & \hyperref[text/conventions:text-context]{\mathsf{tables}} & (\hyperref[text/values:text-id]{\mathtt{id}}^?)^\ast, \\
     & \hyperref[text/conventions:text-context]{\mathsf{mems}} & (\hyperref[text/values:text-id]{\mathtt{id}}^?)^\ast, \\
     & \hyperref[text/conventions:text-context]{\mathsf{globals}} & (\hyperref[text/values:text-id]{\mathtt{id}}^?)^\ast, \\
     & \hyperref[text/conventions:text-context]{\mathsf{locals}} & (\hyperref[text/values:text-id]{\mathtt{id}}^?)^\ast, \\
     & \hyperref[text/conventions:text-context]{\mathsf{labels}} & (\hyperref[text/values:text-id]{\mathtt{id}}^?)^\ast, \\
     & \hyperref[text/conventions:text-context]{\mathsf{typedefs}} & \hyperref[syntax/types:syntax-functype]{\mathit{functype}}^\ast ~\} \\
  \end{array}
\end{array}\end{split}
\end{equation*}
For each index space, such a context contains the list of {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{identifiers}}}} assigned to the defined indices.
Unnamed indices are associated with empty (\(\epsilon\)) entries in these lists.

An identifier context is \sphinxstyleemphasis{well-formed} if no index space contains duplicate identifiers.


\subsubsection{Conventions}
\label{\detokenize{text/conventions:id1}}
To avoid unnecessary clutter, empty components are omitted when writing out identifier contexts.
For example, the record \(\{\}\) is shorthand for an {\hyperref[\detokenize{text/conventions:text-context}]{\sphinxcrossref{\DUrole{std,std-ref}{identifier context}}}} whose components are all empty.

\index{vector}\index{text format!vector}\index{vector!text format}\ignorespaces 

\subsection{Vectors}
\label{\detokenize{text/conventions:text-vec}}\label{\detokenize{text/conventions:vectors}}\label{\detokenize{text/conventions:index-4}}
{\hyperref[\detokenize{syntax/conventions:syntax-vec}]{\sphinxcrossref{\DUrole{std,std-ref}{Vectors}}}} are written as plain sequences, but with a restriction on the length of these sequence.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef2315#1{{}}\mathdef2315{vector} & \hyperref[text/conventions:text-vec]{\mathtt{vec}}(\mathtt{A}) &::=&
  (x{:}\mathtt{A})^n &\Rightarrow& x^n & (\mathrel{\mbox{if}} n < 2^{32}) \\
\end{array}\end{split}
\end{equation*}
\index{lexical format}\ignorespaces 

\section{Lexical Format}
\label{\detokenize{text/lexical::doc}}\label{\detokenize{text/lexical:index-0}}\label{\detokenize{text/lexical:lexical-format}}\label{\detokenize{text/lexical:text-lexical}}
\index{character|textbf}\index{Unicode}\index{ASCII}\index{code point}\index{source text|textbf}\index{text format!character}\index{character!text format}\ignorespaces \phantomsection\label{\detokenize{text/lexical:source}}\phantomsection\label{\detokenize{text/lexical:text-source}}

\subsection{Characters}
\label{\detokenize{text/lexical:index-1}}\label{\detokenize{text/lexical:text-char}}\label{\detokenize{text/lexical:source}}\label{\detokenize{text/lexical:text-source}}\label{\detokenize{text/lexical:characters}}
The text format assigns meaning to \sphinxstyleemphasis{source text}, which consists of a sequence of \sphinxstyleemphasis{characters}.
Characters are assumed to be represented as valid \sphinxhref{http://www.unicode.org/versions/latest/}{Unicode}%
\begin{footnote}[39]\sphinxAtStartFootnote
\sphinxnolinkurl{http://www.unicode.org/versions/latest/}
%
\end{footnote} (Section 2.4) \sphinxstyleemphasis{code points}.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2710#1{{}}\mathdef2710{source} & \hyperref[text/lexical:text-source]{\mathtt{source}} &::=&
  \hyperref[text/lexical:text-char]{\mathtt{char}}^\ast \\
\def\mathdef2710#1{{}}\mathdef2710{character} & \hyperref[text/lexical:text-char]{\mathtt{char}} &::=&
  \def\mathdef2769#1{\mathrm{U{+}#1}}\mathdef2769{00} ~|~ \dots ~|~ \def\mathdef2770#1{\mathrm{U{+}#1}}\mathdef2770{D7FF} ~|~ \def\mathdef2771#1{\mathrm{U{+}#1}}\mathdef2771{E000} ~|~ \dots ~|~ \def\mathdef2772#1{\mathrm{U{+}#1}}\mathdef2772{10FFFF} \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
While source text may contain any Unicode character in {\hyperref[\detokenize{text/lexical:text-comment}]{\sphinxcrossref{\DUrole{std,std-ref}{comments}}}} or {\hyperref[\detokenize{text/values:text-string}]{\sphinxcrossref{\DUrole{std,std-ref}{string}}}} literals,
the rest of the grammar is formed exclusively from the characters supported by the 7-bit \sphinxhref{http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986\%5bR2012\%5d}{ASCII}%
\begin{footnote}[40]\sphinxAtStartFootnote
\sphinxnolinkurl{http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986\%5bR2012\%5d}
%
\end{footnote} subset of Unicode.
\end{sphinxadmonition}

\index{token|textbf}\index{keyword|textbf}\index{character}\index{white space}\index{comment}\index{source text}\index{text format!token}\ignorespaces \phantomsection\label{\detokenize{text/lexical:text-keyword}}\phantomsection\label{\detokenize{text/lexical:text-reserved}}

\subsection{Tokens}
\label{\detokenize{text/lexical:text-reserved}}\label{\detokenize{text/lexical:tokens}}\label{\detokenize{text/lexical:text-keyword}}\label{\detokenize{text/lexical:text-token}}\label{\detokenize{text/lexical:index-2}}
The character stream in the source text is divided, from left to right, into a sequence of \sphinxstyleemphasis{tokens}, as defined by the following grammar.
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef2710#1{{}}\mathdef2710{token} & \hyperref[text/lexical:text-token]{\mathtt{token}} &::=&
  \hyperref[text/lexical:text-keyword]{\mathtt{keyword}} ~|~ \hyperref[text/values:text-int]{\def\mathdef2753#1{{\mathtt{u}#1}}\mathdef2753{N}} ~|~ \hyperref[text/values:text-int]{\def\mathdef2759#1{{\mathtt{s}#1}}\mathdef2759{N}} ~|~ \hyperref[text/values:text-float]{\def\mathdef2765#1{{\mathtt{f}#1}}\mathdef2765{N}} ~|~ \hyperref[text/values:text-string]{\mathtt{string}} ~|~ \hyperref[text/values:text-id]{\mathtt{id}} ~|~
  \def\mathdef2773#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2773{(} ~|~ \def\mathdef2774#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2774{)} ~|~ \hyperref[text/lexical:text-reserved]{\mathtt{reserved}} \\
\def\mathdef2710#1{{}}\mathdef2710{keyword} & \hyperref[text/lexical:text-keyword]{\mathtt{keyword}} &::=&
  (\def\mathdef2775#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2775{a} ~|~ \dots ~|~ \def\mathdef2776#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2776{z})~\hyperref[text/values:text-idchar]{\mathtt{idchar}}^\ast
  \qquad (\mbox{if occurring as a literal terminal in the grammar}) \\
\def\mathdef2710#1{{}}\mathdef2710{reserved} & \hyperref[text/lexical:text-reserved]{\mathtt{reserved}} &::=&
  \hyperref[text/values:text-idchar]{\mathtt{idchar}}^+ \\
\end{array}\end{split}
\end{equation*}
Tokens are formed from the input character stream according to the \sphinxstyleemphasis{longest match} rule.
That is, the next token always consists of the longest possible sequence of characters that is recognized by the above lexical grammar.
Tokens can be separated by {\hyperref[\detokenize{text/lexical:text-space}]{\sphinxcrossref{\DUrole{std,std-ref}{white space}}}},
but except for strings, they cannot themselves contain whitespace.

The set of \sphinxstyleemphasis{keyword} tokens is defined implicitly, by all occurrences of a {\hyperref[\detokenize{text/conventions:text-grammar}]{\sphinxcrossref{\DUrole{std,std-ref}{terminal symbol}}}} in literal form, such as \(\def\mathdef2777#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2777{keyword}\), in a {\hyperref[\detokenize{text/conventions:text-syntactic}]{\sphinxcrossref{\DUrole{std,std-ref}{syntactic}}}} production of this chapter.

Any token that does not fall into any of the other categories is considered \sphinxstyleemphasis{reserved}, and cannot occur in source text.

\begin{sphinxadmonition}{note}{Note:}
The effect of defining the set of reserved tokens is that all tokens must be separated by either parentheses or {\hyperref[\detokenize{text/lexical:text-space}]{\sphinxcrossref{\DUrole{std,std-ref}{white space}}}}.
For example, \(\def\mathdef2778#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2778{0\$x}\) is a single reserved token.
Consequently, it is not recognized as two separate tokens \(\def\mathdef2779#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2779{0}\) and \(\def\mathdef2780#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2780{\$x}\), but instead disallowed.
This property of tokenization is not affected by the fact that the definition of reserved tokens overlaps with other token classes.
\end{sphinxadmonition}

\index{white space|textbf}\index{character}\index{ASCII}\index{text format!white space}\ignorespaces \phantomsection\label{\detokenize{text/lexical:text-format}}

\subsection{White Space}
\label{\detokenize{text/lexical:text-format}}\label{\detokenize{text/lexical:white-space}}\label{\detokenize{text/lexical:text-space}}\label{\detokenize{text/lexical:index-3}}
\sphinxstyleemphasis{White space} is any sequence of literal space characters, formatting characters, or {\hyperref[\detokenize{text/lexical:text-comment}]{\sphinxcrossref{\DUrole{std,std-ref}{comments}}}}.
The allowed formatting characters correspond to a subset of the \sphinxhref{http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986\%5bR2012\%5d}{ASCII}%
\begin{footnote}[41]\sphinxAtStartFootnote
\sphinxnolinkurl{http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986\%5bR2012\%5d}
%
\end{footnote} \sphinxstyleemphasis{format effectors}, namely, \sphinxstyleemphasis{horizontal tabulation} (\(\def\mathdef2781#1{\mathrm{U{+}#1}}\mathdef2781{09}\)), \sphinxstyleemphasis{line feed} (\(\def\mathdef2782#1{\mathrm{U{+}#1}}\mathdef2782{0A}\)), and \sphinxstyleemphasis{carriage return} (\(\def\mathdef2783#1{\mathrm{U{+}#1}}\mathdef2783{0D}\)).
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef2710#1{{}}\mathdef2710{white space} & \hyperref[text/lexical:text-space]{\mathtt{space}} &::=&
  (\def\mathdef2784#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2784{~~} ~|~ \hyperref[text/lexical:text-format]{\mathtt{format}} ~|~ \hyperref[text/lexical:text-comment]{\mathtt{comment}})^\ast \\
\def\mathdef2710#1{{}}\mathdef2710{format} & \hyperref[text/lexical:text-format]{\mathtt{format}} &::=&
  \def\mathdef2785#1{\mathrm{U{+}#1}}\mathdef2785{09} ~|~ \def\mathdef2786#1{\mathrm{U{+}#1}}\mathdef2786{0A} ~|~ \def\mathdef2787#1{\mathrm{U{+}#1}}\mathdef2787{0D} \\
\end{array}\end{split}
\end{equation*}
The only relevance of white space is to separate {\hyperref[\detokenize{text/lexical:text-token}]{\sphinxcrossref{\DUrole{std,std-ref}{tokens}}}}. It is otherwise ignored.

\index{comment|textbf}\index{character}\index{text format!comment}\ignorespaces 

\subsection{Comments}
\label{\detokenize{text/lexical:index-4}}\label{\detokenize{text/lexical:comments}}\label{\detokenize{text/lexical:text-comment}}
A \sphinxstyleemphasis{comment} can either be a \sphinxstyleemphasis{line comment}, started with a double semicolon \(\def\mathdef2752#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2752{{;}{;}}\) and extending to the end of the line,
or a \sphinxstyleemphasis{block comment}, enclosed in delimiters \(\def\mathdef2750#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2750{{(}{;}} \dots \def\mathdef2751#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2751{{;}{)}}\).
Block comments can be nested.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef2710#1{{}}\mathdef2710{comment} & \hyperref[text/lexical:text-comment]{\mathtt{comment}} &::=&
  \hyperref[text/lexical:text-comment]{\mathtt{linecomment}} ~|~ \hyperref[text/lexical:text-comment]{\mathtt{blockcomment}} \\
\def\mathdef2710#1{{}}\mathdef2710{line comment} & \hyperref[text/lexical:text-comment]{\mathtt{linecomment}} &::=&
  \def\mathdef2752#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2752{{;}{;}}~~\hyperref[text/lexical:text-comment]{\mathtt{linechar}}^\ast~~(\def\mathdef2788#1{\mathrm{U{+}#1}}\mathdef2788{0A} ~|~ \mathtt{eof}) \\
\def\mathdef2710#1{{}}\mathdef2710{line character} & \hyperref[text/lexical:text-comment]{\mathtt{linechar}} &::=&
  c{:}\hyperref[text/lexical:text-char]{\mathtt{char}} & (\mathrel{\mbox{if}} c \neq \def\mathdef2789#1{\mathrm{U{+}#1}}\mathdef2789{0A}) \\
\def\mathdef2710#1{{}}\mathdef2710{block comment} & \hyperref[text/lexical:text-comment]{\mathtt{blockcomment}} &::=&
  \def\mathdef2750#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2750{{(}{;}}~~\hyperref[text/lexical:text-comment]{\mathtt{blockchar}}^\ast~~\def\mathdef2751#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2751{{;}{)}} \\
\def\mathdef2710#1{{}}\mathdef2710{block character} & \hyperref[text/lexical:text-comment]{\mathtt{blockchar}} &::=&
  c{:}\hyperref[text/lexical:text-char]{\mathtt{char}} & (\mathrel{\mbox{if}} c \neq \def\mathdef2790#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2790{;} \wedge c \neq \def\mathdef2791#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2791{(}) \\ &&|&
  \def\mathdef2792#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2792{;} & (\mathrel{\mbox{if}}~\mbox{the next character is not}~\def\mathdef2793#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2793{)}) \\ &&|&
  \def\mathdef2794#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2794{(} & (\mathrel{\mbox{if}}~\mbox{the next character is not}~\def\mathdef2795#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2795{;}) \\ &&|&
  \hyperref[text/lexical:text-comment]{\mathtt{blockcomment}} \\
\end{array}\end{split}
\end{equation*}
Here, the pseudo token \(\mathtt{eof}\) indicates the end of the input.
The \sphinxstyleemphasis{look-ahead} restrictions on the productions for \(\hyperref[text/lexical:text-comment]{\mathtt{blockchar}}\) disambiguate the grammar such that only well-bracketed uses of block comment delimiters are allowed.

\begin{sphinxadmonition}{note}{Note:}
Any formatting and control characters are allowed inside comments.
\end{sphinxadmonition}

\index{value}\index{text format!value}\index{value!text format}\ignorespaces 

\section{Values}
\label{\detokenize{text/values:values}}\label{\detokenize{text/values::doc}}\label{\detokenize{text/values:text-value}}\label{\detokenize{text/values:index-0}}
The grammar productions in this section define \sphinxstyleemphasis{lexical syntax},
hence no {\hyperref[\detokenize{text/lexical:text-space}]{\sphinxcrossref{\DUrole{std,std-ref}{white space}}}} is allowed.

\index{integer}\index{unsigned integer}\index{signed integer}\index{uninterpreted integer}\index{text format!integer}\index{integer!text format}\index{text format!unsigned integer}\index{unsigned integer!text format}\index{text format!signed integer}\index{signed integer!text format}\index{text format!uninterpreted integer}\index{uninterpreted integer!text format}\ignorespaces \phantomsection\label{\detokenize{text/values:text-sign}}\phantomsection\label{\detokenize{text/values:text-digit}}\phantomsection\label{\detokenize{text/values:text-hexdigit}}\phantomsection\label{\detokenize{text/values:text-num}}\phantomsection\label{\detokenize{text/values:text-hexnum}}\phantomsection\label{\detokenize{text/values:text-sint}}\phantomsection\label{\detokenize{text/values:text-uint}}

\subsection{Integers}
\label{\detokenize{text/values:text-uint}}\label{\detokenize{text/values:text-digit}}\label{\detokenize{text/values:index-1}}\label{\detokenize{text/values:text-hexnum}}\label{\detokenize{text/values:text-num}}\label{\detokenize{text/values:text-sign}}\label{\detokenize{text/values:text-int}}\label{\detokenize{text/values:integers}}\label{\detokenize{text/values:text-sint}}\label{\detokenize{text/values:text-hexdigit}}
All {\hyperref[\detokenize{syntax/values:syntax-int}]{\sphinxcrossref{\DUrole{std,std-ref}{integers}}}} can be written in either decimal or hexadecimal notation.
In both cases, digits can optionally be separated by underscores.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad}l}
\def\mathdef3250#1{{}}\mathdef3250{sign} & \hyperref[text/values:text-sign]{\mathtt{sign}} &::=&
  \epsilon \Rightarrow {+} ~~|~~
  \def\mathdef3309#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3309{+} \Rightarrow {+} ~~|~~
  \def\mathdef3310#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3310{-} \Rightarrow {-} \\
\def\mathdef3250#1{{}}\mathdef3250{decimal digit} & \hyperref[text/values:text-digit]{\mathtt{digit}} &::=&
  \def\mathdef3311#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3311{0} \Rightarrow 0 ~~|~~ \dots ~~|~~ \def\mathdef3312#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3312{9} \Rightarrow 9 \\
\def\mathdef3250#1{{}}\mathdef3250{hexadecimal digit} & \hyperref[text/values:text-hexdigit]{\mathtt{hexdigit}} &::=&
  d{:}\hyperref[text/values:text-digit]{\mathtt{digit}} \Rightarrow d \\ &&|&
  \def\mathdef3313#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3313{A} \Rightarrow 10 ~~|~~ \dots ~~|~~ \def\mathdef3314#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3314{F} \Rightarrow 15 \\ &&|&
  \def\mathdef3315#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3315{a} \Rightarrow 10 ~~|~~ \dots ~~|~~ \def\mathdef3316#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3316{f} \Rightarrow 15
\\[1ex]
\def\mathdef3250#1{{}}\mathdef3250{decimal number} & \hyperref[text/values:text-num]{\mathtt{num}} &::=&
  d{:}\hyperref[text/values:text-digit]{\mathtt{digit}} &\Rightarrow& d \\ &&|&
  n{:}\hyperref[text/values:text-num]{\mathtt{num}}~~\def\mathdef3317#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3317{\_}^?~~d{:}\hyperref[text/values:text-digit]{\mathtt{digit}} &\Rightarrow& 10\cdot n + d \\
\def\mathdef3250#1{{}}\mathdef3250{hexadecimal number} & \hyperref[text/values:text-hexnum]{\mathtt{hexnum}} &::=&
  h{:}\hyperref[text/values:text-hexdigit]{\mathtt{hexdigit}} &\Rightarrow& h \\ &&|&
  n{:}\hyperref[text/values:text-hexnum]{\mathtt{hexnum}}~~\def\mathdef3318#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3318{\_}^?~~h{:}\hyperref[text/values:text-hexdigit]{\mathtt{hexdigit}} &\Rightarrow& 16\cdot n + h \\
\end{array}\end{split}
\end{equation*}
The allowed syntax for integer literals depends on size and signedness.
Moreover, their value must lie within the range of the respective type.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad}l}
\def\mathdef3250#1{{}}\mathdef3250{unsigned integer} & \hyperref[text/values:text-int]{\def\mathdef3293#1{{\mathtt{u}#1}}\mathdef3293{N}} &::=&
  n{:}\hyperref[text/values:text-num]{\mathtt{num}} &\Rightarrow& n & (\mathrel{\mbox{if}} n < 2^N) \\ &&|&
  \def\mathdef3319#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3319{0x}~~n{:}\hyperref[text/values:text-hexnum]{\mathtt{hexnum}} &\Rightarrow& n & (\mathrel{\mbox{if}} n < 2^N) \\
\def\mathdef3250#1{{}}\mathdef3250{signed integer} & \hyperref[text/values:text-int]{\def\mathdef3299#1{{\mathtt{s}#1}}\mathdef3299{N}} &::=&
  {\pm}{:}\hyperref[text/values:text-sign]{\mathtt{sign}}~~n{:}\hyperref[text/values:text-num]{\mathtt{num}} &\Rightarrow& \pm n & (\mathrel{\mbox{if}} -2^{N-1} \leq \pm n < 2^{N-1}) \\ &&|&
  {\pm}{:}\hyperref[text/values:text-sign]{\mathtt{sign}}~~\def\mathdef3320#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3320{0x}~~n{:}\hyperref[text/values:text-hexnum]{\mathtt{hexnum}} &\Rightarrow& \pm n & (\mathrel{\mbox{if}} -2^{N-1} \leq \pm n < 2^{N-1}) \\
\end{array}\end{split}
\end{equation*}
{\hyperref[\detokenize{syntax/values:syntax-int}]{\sphinxcrossref{\DUrole{std,std-ref}{Uninterpreted integers}}}} can be written as either signed or unsigned, and are normalized to unsigned in the abstract syntax.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef3250#1{{}}\mathdef3250{uninterpreted integers} & \hyperref[text/values:text-int]{\def\mathdef3302#1{{\mathtt{i}#1}}\mathdef3302{N}} &::=&
  n{:}\hyperref[text/values:text-int]{\def\mathdef3293#1{{\mathtt{u}#1}}\mathdef3293{N}} &\Rightarrow& n \\ &&|&
  i{:}\hyperref[text/values:text-int]{\def\mathdef3299#1{{\mathtt{s}#1}}\mathdef3299{N}} &\Rightarrow& n & (\mathrel{\mbox{if}} i = \hyperref[exec/numerics:aux-signed]{\mathrm{signed}}(n)) \\
\end{array}\end{split}
\end{equation*}
\index{floating-point number}\index{text format!floating-point number}\index{floating-point number!text format}\ignorespaces \phantomsection\label{\detokenize{text/values:text-frac}}\phantomsection\label{\detokenize{text/values:text-hexfrac}}\phantomsection\label{\detokenize{text/values:text-hexfloat}}

\subsection{Floating-Point}
\label{\detokenize{text/values:text-hexfrac}}\label{\detokenize{text/values:text-frac}}\label{\detokenize{text/values:floating-point}}\label{\detokenize{text/values:text-float}}\label{\detokenize{text/values:index-2}}\label{\detokenize{text/values:text-hexfloat}}
{\hyperref[\detokenize{syntax/values:syntax-float}]{\sphinxcrossref{\DUrole{std,std-ref}{Floating-point}}}} values can be represented in either decimal or hexadecimal notation.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef3250#1{{}}\mathdef3250{decimal floating-point fraction} & \hyperref[text/values:text-frac]{\mathtt{frac}} &::=&
  \epsilon &\Rightarrow& 0 \\ &&|&
  d{:}\hyperref[text/values:text-digit]{\mathtt{digit}}~~q{:}\hyperref[text/values:text-frac]{\mathtt{frac}} &\Rightarrow& (d+q)/10 \\ &&|&
  d{:}\hyperref[text/values:text-digit]{\mathtt{digit}}~~\def\mathdef3321#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3321{\_}~~p{:}\hyperref[text/values:text-digit]{\mathtt{digit}}~~q{:}\hyperref[text/values:text-frac]{\mathtt{frac}} &\Rightarrow& (d+(p+q)/10)/10 \\
\def\mathdef3250#1{{}}\mathdef3250{hexadecimal floating-point fraction} & \hyperref[text/values:text-hexfrac]{\mathtt{hexfrac}} &::=&
  \epsilon &\Rightarrow& 0 \\ &&|&
  h{:}\hyperref[text/values:text-hexdigit]{\mathtt{hexdigit}}~~q{:}\hyperref[text/values:text-hexfrac]{\mathtt{hexfrac}} &\Rightarrow& (h+q)/16 \\ &&|&
  h{:}\hyperref[text/values:text-hexdigit]{\mathtt{hexdigit}}~~\def\mathdef3322#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3322{\_}~~~~p{:}\hyperref[text/values:text-hexdigit]{\mathtt{hexdigit}}~~q{:}\hyperref[text/values:text-hexfrac]{\mathtt{hexfrac}} &\Rightarrow& (h+(p+q)/16)/16 \\
\def\mathdef3250#1{{}}\mathdef3250{decimal floating-point number} & \hyperref[text/values:text-float]{\mathtt{float}} &::=&
  p{:}\hyperref[text/values:text-num]{\mathtt{num}}~\def\mathdef3323#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3323{.}~q{:}\hyperref[text/values:text-frac]{\mathtt{frac}}
    &\Rightarrow& p+q \\ &&|&
  p{:}\hyperref[text/values:text-num]{\mathtt{num}}~(\def\mathdef3324#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3324{E}~|~\def\mathdef3325#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3325{e})~{\pm}{:}\hyperref[text/values:text-sign]{\mathtt{sign}}~e{:}\hyperref[text/values:text-num]{\mathtt{num}}
    &\Rightarrow& p\cdot 10^{\pm e} \\ &&|&
  p{:}\hyperref[text/values:text-num]{\mathtt{num}}~\def\mathdef3326#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3326{.}~q{:}\hyperref[text/values:text-frac]{\mathtt{frac}}~(\def\mathdef3327#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3327{E}~|~\def\mathdef3328#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3328{e})~{\pm}{:}\hyperref[text/values:text-sign]{\mathtt{sign}}~e{:}\hyperref[text/values:text-num]{\mathtt{num}}
    &\Rightarrow& (p+q)\cdot 10^{\pm e} \\
\def\mathdef3250#1{{}}\mathdef3250{hexadecimal floating-point number} & \hyperref[text/values:text-hexfloat]{\mathtt{hexfloat}} &::=&
  \def\mathdef3329#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3329{0x}~p{:}\hyperref[text/values:text-hexnum]{\mathtt{hexnum}}~\def\mathdef3330#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3330{.}~q{:}\hyperref[text/values:text-hexfrac]{\mathtt{hexfrac}}
    &\Rightarrow& p+q \\ &&|&
  \def\mathdef3331#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3331{0x}~p{:}\hyperref[text/values:text-hexnum]{\mathtt{hexnum}}~(\def\mathdef3332#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3332{P}~|~\def\mathdef3333#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3333{p})~{\pm}{:}\hyperref[text/values:text-sign]{\mathtt{sign}}~e{:}\hyperref[text/values:text-num]{\mathtt{num}}
    &\Rightarrow& p\cdot 2^{\pm e} \\ &&|&
  \def\mathdef3334#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3334{0x}~p{:}\hyperref[text/values:text-hexnum]{\mathtt{hexnum}}~\def\mathdef3335#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3335{.}~q{:}\hyperref[text/values:text-hexfrac]{\mathtt{hexfrac}}~(\def\mathdef3336#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3336{P}~|~\def\mathdef3337#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3337{p})~{\pm}{:}\hyperref[text/values:text-sign]{\mathtt{sign}}~e{:}\hyperref[text/values:text-num]{\mathtt{num}}
    &\Rightarrow& (p+q)\cdot 2^{\pm e}
\end{array}\end{split}
\end{equation*}
The value of a literal must not lie outside the representable range of the corresponding \sphinxhref{http://ieeexplore.ieee.org/document/4610935/}{IEEE 754-2008}%
\begin{footnote}[42]\sphinxAtStartFootnote
\sphinxnolinkurl{http://ieeexplore.ieee.org/document/4610935/}
%
\end{footnote} type
(that is, a numeric value must not overflow to \(\pm\mbox{infinity}\)),
but it may be {\hyperref[\detokenize{exec/numerics:aux-ieee}]{\sphinxcrossref{\DUrole{std,std-ref}{rounded}}}} to the nearest representable value.

\begin{sphinxadmonition}{note}{Note:}
Rounding can be prevented by using hexadecimal notation with no more significant bits than supported by the required type.
\end{sphinxadmonition}

Floating-point values may also be written as constants for \sphinxstyleemphasis{infinity} or \sphinxstyleemphasis{canonical NaN} (\sphinxstyleemphasis{not a number}).
Furthermore, arbitrary NaN values may be expressed by providing an explicit payload value.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef3250#1{{}}\mathdef3250{floating-point value} & \hyperref[text/values:text-float]{\def\mathdef3305#1{{\mathtt{f}#1}}\mathdef3305{N}} &::=&
  {\pm}{:}\hyperref[text/values:text-sign]{\mathtt{sign}}~z{:}\hyperref[text/values:text-float]{\def\mathdef3306#1{{\mathtt{f}#1}}\mathdef3306{N}\mathtt{mag}} &\Rightarrow& \pm z \\
\def\mathdef3250#1{{}}\mathdef3250{floating-point magnitude} & \hyperref[text/values:text-float]{\def\mathdef3306#1{{\mathtt{f}#1}}\mathdef3306{N}\mathtt{mag}} &::=&
  z{:}\hyperref[text/values:text-float]{\mathtt{float}} &\Rightarrow& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(z) & (\mathrel{\mbox{if}} \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(z) \neq \pm \infty) \\ &&|&
  z{:}\hyperref[text/values:text-hexfloat]{\mathtt{hexfloat}} &\Rightarrow& \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(z) & (\mathrel{\mbox{if}} \hyperref[exec/numerics:aux-ieee]{\mathrm{float}}_N(z) \neq \pm \infty) \\ &&|&
  \def\mathdef3338#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3338{inf} &\Rightarrow& \infty \\ &&|&
  \def\mathdef3339#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3339{nan} &\Rightarrow& \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(2^{\hyperref[syntax/values:aux-significand]{\mathrm{signif}}(N)-1}) \\ &&|&
  \def\mathdef3340#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3340{nan{:}0x}~n{:}\hyperref[text/values:text-hexnum]{\mathtt{hexnum}} &\Rightarrow& \hyperref[syntax/values:syntax-float]{\mathsf{nan}}(n) & (\mathrel{\mbox{if}} 1 \leq n < 2^{\hyperref[syntax/values:aux-significand]{\mathrm{signif}}(N)}) \\
\end{array}\end{split}
\end{equation*}
\index{string|textbf}\index{byte}\index{character}\index{ASCII}\index{Unicode}\index{UTF-8}\index{text format!byte}\index{byte!text format}\index{text format!string}\index{string!text format}\ignorespaces \phantomsection\label{\detokenize{text/values:text-byte}}

\subsection{Strings}
\label{\detokenize{text/values:strings}}\label{\detokenize{text/values:text-string}}\label{\detokenize{text/values:text-byte}}\label{\detokenize{text/values:index-3}}
\sphinxstyleemphasis{Strings} denote sequences of bytes that can represent both textual and binary data.
They are enclosed in quotation marks
and may contain any character other than \sphinxhref{http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986\%5bR2012\%5d}{ASCII}%
\begin{footnote}[43]\sphinxAtStartFootnote
\sphinxnolinkurl{http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986\%5bR2012\%5d}
%
\end{footnote} control characters, quotation marks (\(\def\mathdef3341#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3341{"}\)), or backslash (\(\def\mathdef3342#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3342{\backslash}\)),
except when expressed with an \sphinxstyleemphasis{escape sequence}.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef3250#1{{}}\mathdef3250{string} & \hyperref[text/values:text-string]{\mathtt{string}} &::=&
  \def\mathdef3343#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3343{"}~(b^\ast{:}\hyperref[text/values:text-string]{\mathtt{stringelem}})^\ast~\def\mathdef3344#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3344{"}
    &\Rightarrow& \hyperref[syntax/conventions:notation-concat]{\mathrm{concat}}((b^\ast)^\ast)
    & (\mathrel{\mbox{if}} |\hyperref[syntax/conventions:notation-concat]{\mathrm{concat}}((b^\ast)^\ast)| < 2^{32}) \\
\def\mathdef3250#1{{}}\mathdef3250{string element} & \hyperref[text/values:text-string]{\mathtt{stringelem}} &::=&
  c{:}\hyperref[text/values:text-string]{\mathtt{stringchar}} &\Rightarrow& \hyperref[binary/values:binary-utf8]{\mathrm{utf8}}(c) \\ &&|&
  \def\mathdef3345#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3345{\backslash}~n{:}\hyperref[text/values:text-hexdigit]{\mathtt{hexdigit}}~m{:}\hyperref[text/values:text-hexdigit]{\mathtt{hexdigit}}
    &\Rightarrow& 16\cdot n+m \\
\end{array}\end{split}
\end{equation*}
Each character in a string literal represents the byte sequence corresponding to its UTF-8 \sphinxhref{http://www.unicode.org/versions/latest/}{Unicode}%
\begin{footnote}[44]\sphinxAtStartFootnote
\sphinxnolinkurl{http://www.unicode.org/versions/latest/}
%
\end{footnote} (Section 2.5) encoding,
except for hexadecimal escape sequences \(\mbox{‘}\backslash hh\mbox{’}\), which represent raw bytes of the respective value.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef3250#1{{}}\mathdef3250{string character} & \hyperref[text/values:text-string]{\mathtt{stringchar}} &::=&
  c{:}\hyperref[text/lexical:text-char]{\mathtt{char}} &\Rightarrow& c \qquad
    & (\mathrel{\mbox{if}} c \geq \def\mathdef3346#1{\mathrm{U{+}#1}}\mathdef3346{20} \wedge c \neq \def\mathdef3347#1{\mathrm{U{+}#1}}\mathdef3347{7F} \wedge c \neq \def\mathdef3348#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3348{"} \wedge c \neq \def\mathdef3349#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3349{\backslash}) \\ &&|&
  \def\mathdef3350#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3350{\backslash t} &\Rightarrow& \def\mathdef3351#1{\mathrm{U{+}#1}}\mathdef3351{09} \\ &&|&
  \def\mathdef3352#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3352{\backslash n} &\Rightarrow& \def\mathdef3353#1{\mathrm{U{+}#1}}\mathdef3353{0A} \\ &&|&
  \def\mathdef3354#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3354{\backslash r} &\Rightarrow& \def\mathdef3355#1{\mathrm{U{+}#1}}\mathdef3355{0D} \\ &&|&
  \def\mathdef3356#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3356{\backslash{"}} &\Rightarrow& \def\mathdef3357#1{\mathrm{U{+}#1}}\mathdef3357{22} \\ &&|&
  \def\mathdef3358#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3358{\backslash{'}} &\Rightarrow& \def\mathdef3359#1{\mathrm{U{+}#1}}\mathdef3359{27} \\ &&|&
  \def\mathdef3360#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3360{\backslash\backslash} &\Rightarrow& \def\mathdef3361#1{\mathrm{U{+}#1}}\mathdef3361{5C} \\ &&|&
  \def\mathdef3362#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3362{\backslash u\{}~n{:}\hyperref[text/values:text-hexnum]{\mathtt{hexnum}}~\def\mathdef3363#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3363{\}}
    &\Rightarrow& \def\mathdef3364#1{\mathrm{U{+}#1}}\mathdef3364{(n)} & (\mathrel{\mbox{if}} n < \def\mathdef3365#1{\mathtt{0x#1}}\mathdef3365{D800} \vee \def\mathdef3366#1{\mathtt{0x#1}}\mathdef3366{E000} \leq n < \def\mathdef3367#1{\mathtt{0x#1}}\mathdef3367{110000}) \\
\end{array}\end{split}
\end{equation*}
\index{name}\index{byte}\index{character}\index{code point}\index{text format!name}\index{name!text format}\ignorespaces 

\subsection{Names}
\label{\detokenize{text/values:text-name}}\label{\detokenize{text/values:index-4}}\label{\detokenize{text/values:names}}
{\hyperref[\detokenize{syntax/values:syntax-name}]{\sphinxcrossref{\DUrole{std,std-ref}{Names}}}} are strings denoting a literal character sequence.
A name string must form a valid UTF-8 encoding as defined by \sphinxhref{http://www.unicode.org/versions/latest/}{Unicode}%
\begin{footnote}[45]\sphinxAtStartFootnote
\sphinxnolinkurl{http://www.unicode.org/versions/latest/}
%
\end{footnote} (Section 2.5) and is interpreted as a string of Unicode code points.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad}l}
\def\mathdef3250#1{{}}\mathdef3250{name} & \hyperref[text/values:text-name]{\mathtt{name}} &::=&
  b^\ast{:}\hyperref[text/values:text-string]{\mathtt{string}} &\Rightarrow& c^\ast & (\mathrel{\mbox{if}} b^\ast = \hyperref[binary/values:binary-utf8]{\mathrm{utf8}}(c^\ast)) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
Presuming the source text is itself encoded correctly,
strings that do not contain any uses of hexadecimal byte escapes are always valid names.
\end{sphinxadmonition}

\index{identifiers|textbf}\index{text format!identifiers}\index{identifiers!text format}\ignorespaces \phantomsection\label{\detokenize{text/values:text-idchar}}

\subsection{Identifiers}
\label{\detokenize{text/values:text-id}}\label{\detokenize{text/values:text-idchar}}\label{\detokenize{text/values:identifiers}}\label{\detokenize{text/values:index-5}}
{\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{Indices}}}} can be given in both numeric and symbolic form.
Symbolic \sphinxstyleemphasis{identifiers} that stand in lieu of indices start with \(\def\mathdef3368#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3368{\$}\), followed by any sequence of printable \sphinxhref{http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986\%5bR2012\%5d}{ASCII}%
\begin{footnote}[46]\sphinxAtStartFootnote
\sphinxnolinkurl{http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986\%5bR2012\%5d}
%
\end{footnote} characters that does not contain a space, quotation mark, comma, semicolon, or bracket.
\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad}l}
\def\mathdef3250#1{{}}\mathdef3250{identifier} & \hyperref[text/values:text-id]{\mathtt{id}} &::=&
  \def\mathdef3369#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3369{\$}~\hyperref[text/values:text-idchar]{\mathtt{idchar}}^+ \\
\def\mathdef3250#1{{}}\mathdef3250{identifier character} & \hyperref[text/values:text-idchar]{\mathtt{idchar}} &::=&
  \def\mathdef3370#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3370{0} ~~|~~ \dots ~~|~~ \def\mathdef3371#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3371{9} \\ &&|&
  \def\mathdef3372#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3372{A} ~~|~~ \dots ~~|~~ \def\mathdef3373#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3373{Z} \\ &&|&
  \def\mathdef3374#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3374{a} ~~|~~ \dots ~~|~~ \def\mathdef3375#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3375{z} \\ &&|&
  \def\mathdef3376#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3376{!} ~~|~~
  \def\mathdef3377#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3377{\#} ~~|~~
  \def\mathdef3378#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3378{\$} ~~|~~
  \def\mathdef3379#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3379{\%} ~~|~~
  \def\mathdef3380#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3380{\&} ~~|~~
  \def\mathdef3381#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3381{'} ~~|~~
  \def\mathdef3382#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3382{*} ~~|~~
  \def\mathdef3383#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3383{+} ~~|~~
  \def\mathdef3384#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3384{-} ~~|~~
  \def\mathdef3385#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3385{.} ~~|~~
  \def\mathdef3386#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3386{/} \\ &&|&
  \def\mathdef3387#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3387{:} ~~|~~
  \def\mathdef3388#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3388{<} ~~|~~
  \def\mathdef3389#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3389{=} ~~|~~
  \def\mathdef3390#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3390{>} ~~|~~
  \def\mathdef3391#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3391{?} ~~|~~
  \def\mathdef3392#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3392{@} ~~|~~
  \def\mathdef3393#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3393{\backslash} ~~|~~
  \def\mathdef3394#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3394{\hat{~~}} ~~|~~
  \def\mathdef3395#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3395{\_} ~~|~~
  \def\mathdef3396#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3396{\grave{~~}} ~~|~~
  \def\mathdef3397#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3397{|} ~~|~~
  \def\mathdef3398#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3398{\tilde{~~}} \\
\end{array}\end{split}
\end{equation*}

\subsubsection{Conventions}
\label{\detokenize{text/values:conventions}}\label{\detokenize{text/values:text-id-fresh}}
The expansion rules of some abbreviations require insertion of a \sphinxstyleemphasis{fresh} identifier.
That may be any syntactically valid identifier that does not already occur in the given source text.

\index{type}\index{text format!type}\index{type!text format}\ignorespaces 

\section{Types}
\label{\detokenize{text/types:types}}\label{\detokenize{text/types::doc}}\label{\detokenize{text/types:index-0}}\label{\detokenize{text/types:text-type}}
\index{value type}\index{text format!value type}\index{value type!text format}\ignorespaces 

\subsection{Value Types}
\label{\detokenize{text/types:text-valtype}}\label{\detokenize{text/types:value-types}}\label{\detokenize{text/types:index-1}}\begin{equation*}
\begin{split}\begin{array}{llcll@{\qquad\qquad}l}
\def\mathdef3162#1{{}}\mathdef3162{value type} & \hyperref[text/types:text-valtype]{\mathtt{valtype}} &::=&
  \def\mathdef3221#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3221{i32} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}} \\ &&|&
  \def\mathdef3222#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3222{i64} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}} \\ &&|&
  \def\mathdef3223#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3223{f32} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}} \\ &&|&
  \def\mathdef3224#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3224{f64} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}} \\
\end{array}\end{split}
\end{equation*}
\index{function type}\index{value type}\index{result type}\index{text format!function type}\index{function type!text format}\ignorespaces \phantomsection\label{\detokenize{text/types:text-param}}\phantomsection\label{\detokenize{text/types:text-result}}

\subsection{Function Types}
\label{\detokenize{text/types:text-param}}\label{\detokenize{text/types:function-types}}\label{\detokenize{text/types:text-functype}}\label{\detokenize{text/types:index-2}}\label{\detokenize{text/types:text-result}}\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef3162#1{{}}\mathdef3162{function type} & \hyperref[text/types:text-functype]{\mathtt{functype}} &::=&
  \def\mathdef3225#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3225{(}~\def\mathdef3226#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3226{func}~~t_1^\ast{:\,}\hyperref[text/conventions:text-vec]{\mathtt{vec}}(\hyperref[text/types:text-functype]{\mathtt{param}})~~t_2^\ast{:\,}\hyperref[text/conventions:text-vec]{\mathtt{vec}}(\hyperref[text/types:text-functype]{\mathtt{result}})~\def\mathdef3227#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3227{)}
    &\Rightarrow& [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast] \\
\def\mathdef3162#1{{}}\mathdef3162{parameter} & \hyperref[text/types:text-functype]{\mathtt{param}} &::=&
  \def\mathdef3228#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3228{(}~\def\mathdef3229#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3229{param}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~t{:}\hyperref[text/types:text-valtype]{\mathtt{valtype}}~\def\mathdef3230#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3230{)}
    &\Rightarrow& t \\
\def\mathdef3162#1{{}}\mathdef3162{result} & \hyperref[text/types:text-functype]{\mathtt{result}} &::=&
  \def\mathdef3231#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3231{(}~\def\mathdef3232#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3232{result}~~t{:}\hyperref[text/types:text-valtype]{\mathtt{valtype}}~\def\mathdef3233#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3233{)}
    &\Rightarrow& t \\
\end{array}\end{split}
\end{equation*}

\subsubsection{Abbreviations}
\label{\detokenize{text/types:abbreviations}}
Multiple anonymous parameters or results may be combined into a single declaration:
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef3162#1{{}}\mathdef3162{parameter} &
  \def\mathdef3234#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3234{(}~~\def\mathdef3235#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3235{param}~~\hyperref[text/types:text-valtype]{\mathtt{valtype}}^\ast~~\def\mathdef3236#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3236{)} &\equiv&
  (\def\mathdef3237#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3237{(}~~\def\mathdef3238#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3238{param}~~\hyperref[text/types:text-valtype]{\mathtt{valtype}}~~\def\mathdef3239#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3239{)})^\ast \\
\def\mathdef3162#1{{}}\mathdef3162{result} &
  \def\mathdef3240#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3240{(}~~\def\mathdef3241#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3241{result}~~\hyperref[text/types:text-valtype]{\mathtt{valtype}}^\ast~~\def\mathdef3242#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3242{)} &\equiv&
  (\def\mathdef3243#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3243{(}~~\def\mathdef3244#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3244{result}~~\hyperref[text/types:text-valtype]{\mathtt{valtype}}~~\def\mathdef3245#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3245{)})^\ast \\
\end{array}\end{split}
\end{equation*}
\index{limits}\index{text format!limits}\index{limits!text format}\ignorespaces 

\subsection{Limits}
\label{\detokenize{text/types:text-limits}}\label{\detokenize{text/types:limits}}\label{\detokenize{text/types:index-3}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef3162#1{{}}\mathdef3162{limits} & \hyperref[text/types:text-limits]{\mathtt{limits}} &::=&
  n{:}\hyperref[text/values:text-int]{\def\mathdef3209#1{{\mathtt{u}#1}}\mathdef3209{\mathtt{32}}} &\Rightarrow& \{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~\epsilon \} \\ &&|&
  n{:}\hyperref[text/values:text-int]{\def\mathdef3209#1{{\mathtt{u}#1}}\mathdef3209{\mathtt{32}}}~~m{:}\hyperref[text/values:text-int]{\def\mathdef3209#1{{\mathtt{u}#1}}\mathdef3209{\mathtt{32}}} &\Rightarrow& \{ \hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m \} \\
\end{array}\end{split}
\end{equation*}
\index{memory type}\index{limits}\index{page size}\index{text format!memory type}\index{memory type!text format}\ignorespaces 

\subsection{Memory Types}
\label{\detokenize{text/types:index-4}}\label{\detokenize{text/types:memory-types}}\label{\detokenize{text/types:text-memtype}}\begin{equation*}
\begin{split}\begin{array}{llclll@{\qquad\qquad}l}
\def\mathdef3162#1{{}}\mathdef3162{memory type} & \hyperref[text/types:text-memtype]{\mathtt{memtype}} &::=&
  \mathit{lim}{:}\hyperref[text/types:text-limits]{\mathtt{limits}} &\Rightarrow& \mathit{lim} \\
\end{array}\end{split}
\end{equation*}
\index{table type}\index{element type}\index{limits}\index{text format!table type}\index{table type!text format}\index{text format!element type}\index{element type!text format}\ignorespaces \phantomsection\label{\detokenize{text/types:text-elemtype}}

\subsection{Table Types}
\label{\detokenize{text/types:text-tabletype}}\label{\detokenize{text/types:table-types}}\label{\detokenize{text/types:text-elemtype}}\label{\detokenize{text/types:index-5}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef3162#1{{}}\mathdef3162{table type} & \hyperref[text/types:text-tabletype]{\mathtt{tabletype}} &::=&
  \mathit{lim}{:}\hyperref[text/types:text-limits]{\mathtt{limits}}~~\mathit{et}{:}\hyperref[text/types:text-elemtype]{\mathtt{elemtype}} &\Rightarrow& \mathit{lim}~\mathit{et} \\
\def\mathdef3162#1{{}}\mathdef3162{element type} & \hyperref[text/types:text-elemtype]{\mathtt{elemtype}} &::=&
  \def\mathdef3246#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3246{funcref} &\Rightarrow& \hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}} \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
Additional element types may be introduced in future versions of WebAssembly.
\end{sphinxadmonition}

\index{global type}\index{mutability}\index{value type}\index{text format!global type}\index{global type!text format}\index{text format!mutability}\index{mutability!text format}\ignorespaces 

\subsection{Global Types}
\label{\detokenize{text/types:global-types}}\label{\detokenize{text/types:index-6}}\label{\detokenize{text/types:text-globaltype}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef3162#1{{}}\mathdef3162{global type} & \hyperref[text/types:text-globaltype]{\mathtt{globaltype}} &::=&
  t{:}\hyperref[text/types:text-valtype]{\mathtt{valtype}} &\Rightarrow& \hyperref[syntax/types:syntax-mut]{\mathsf{const}}~t \\ &&|&
  \def\mathdef3247#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3247{(}~\def\mathdef3248#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3248{mut}~~t{:}\hyperref[text/types:text-valtype]{\mathtt{valtype}}~\def\mathdef3249#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3249{)} &\Rightarrow& \hyperref[syntax/types:syntax-mut]{\mathsf{var}}~t \\
\end{array}\end{split}
\end{equation*}
\index{instruction}\ignorespaces 

\section{Instructions}
\label{\detokenize{text/instructions:text-instr}}\label{\detokenize{text/instructions:instructions}}\label{\detokenize{text/instructions::doc}}\label{\detokenize{text/instructions:index-0}}
Instructions are syntactically distinguished into \sphinxstyleemphasis{plain} and \sphinxstyleemphasis{structured} instructions.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2439#1{{}}\mathdef2439{instruction} & \hyperref[text/instructions:text-instr]{\mathtt{instr}}_I &::=&
  \mathit{in}{:}\hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I
    &\Rightarrow& \mathit{in} \\ &&|&
  \mathit{in}{:}\hyperref[text/instructions:text-blockinstr]{\mathtt{blockinstr}}_I
    &\Rightarrow& \mathit{in} \\
\end{array}\end{split}
\end{equation*}
In addition, as a syntactic abbreviation, instructions can be written as S-expressions in {\hyperref[\detokenize{text/instructions:text-foldedinstr}]{\sphinxcrossref{\DUrole{std,std-ref}{folded}}}} form, to group them visually.

\index{index}\index{label index}\index{text format!label index}\index{label index!text format}\ignorespaces 

\subsection{Labels}
\label{\detokenize{text/instructions:labels}}\label{\detokenize{text/instructions:text-label}}\label{\detokenize{text/instructions:index-1}}
{\hyperref[\detokenize{text/instructions:text-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{Structured control instructions}}}} can be annotated with a symbolic {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{label identifier}}}}.
They are the only {\hyperref[\detokenize{text/modules:text-index}]{\sphinxcrossref{\DUrole{std,std-ref}{symbolic identifiers}}}} that can be bound locally in an instruction sequence.
The following grammar handles the corresponding update to the {\hyperref[\detokenize{text/conventions:text-context}]{\sphinxcrossref{\DUrole{std,std-ref}{identifier context}}}} by {\hyperref[\detokenize{syntax/conventions:notation-compose}]{\sphinxcrossref{\DUrole{std,std-ref}{composing}}}} the context with an additional label entry.
\begin{equation*}
\begin{split}\begin{array}{llcllll}
\def\mathdef2439#1{{}}\mathdef2439{label} & \hyperref[text/instructions:text-label]{\mathtt{label}}_I &::=&
  v{:}\hyperref[text/values:text-id]{\mathtt{id}} &\Rightarrow& \{\hyperref[text/conventions:text-context]{\mathsf{labels}}~v\} \hyperref[syntax/conventions:notation-compose]{\oplus} I
    & (\mathrel{\mbox{if}} v \notin I.\hyperref[text/conventions:text-context]{\mathsf{labels}}) \\ &&|&
  \epsilon &\Rightarrow& \{\hyperref[text/conventions:text-context]{\mathsf{labels}}~(\epsilon)\} \hyperref[syntax/conventions:notation-compose]{\oplus} I \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The new label entry is inserted at the \sphinxstyleemphasis{beginning} of the label list in the identifier context.
This effectively shifts all existing labels up by one,
mirroring the fact that control instructions are indexed relatively not absolutely.
\end{sphinxadmonition}

\index{control instructions}\index{structured control}\index{label}\index{block}\index{branch}\index{result type}\index{label index}\index{function index}\index{type index}\index{vector}\index{polymorphism}\index{text format!instruction}\index{instruction!text format}\ignorespaces \phantomsection\label{\detokenize{text/instructions:text-blockinstr}}\phantomsection\label{\detokenize{text/instructions:text-plaininstr}}

\subsection{Control Instructions}
\label{\detokenize{text/instructions:control-instructions}}\label{\detokenize{text/instructions:text-instr-control}}\label{\detokenize{text/instructions:text-plaininstr}}\label{\detokenize{text/instructions:index-2}}\label{\detokenize{text/instructions:text-blockinstr}}\phantomsection\label{\detokenize{text/instructions:text-blocktype}}\phantomsection\label{\detokenize{text/instructions:text-block}}\phantomsection\label{\detokenize{text/instructions:text-loop}}\phantomsection\label{\detokenize{text/instructions:text-if}}\phantomsection\label{\detokenize{text/instructions:text-instr-block}}
{\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{Structured control instructions}}}} can bind an optional symbolic {\hyperref[\detokenize{text/instructions:text-label}]{\sphinxcrossref{\DUrole{std,std-ref}{label identifier}}}}.
The same label identifier may optionally be repeated after the corresponding \(\mathtt{end}\) and \(\mathtt{else}\) pseudo instructions, to indicate the matching delimiters.

Their {\hyperref[\detokenize{syntax/instructions:syntax-blocktype}]{\sphinxcrossref{\DUrole{std,std-ref}{block type}}}} is given as a {\hyperref[\detokenize{text/modules:text-typeuse}]{\sphinxcrossref{\DUrole{std,std-ref}{type use}}}}, analogous to the type of {\hyperref[\detokenize{text/modules:text-func}]{\sphinxcrossref{\DUrole{std,std-ref}{functions}}}}.
However, the special case of a type use that is syntactically empty or consists of only a single {\hyperref[\detokenize{text/types:text-result}]{\sphinxcrossref{\DUrole{std,std-ref}{result}}}} is not regarded as an {\hyperref[\detokenize{text/modules:text-typeuse-abbrev}]{\sphinxcrossref{\DUrole{std,std-ref}{abbreviation}}}} for an inline {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}}, but is parsed directly into an optional {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2439#1{{}}\mathdef2439{block type} & \hyperref[text/instructions:text-blocktype]{\mathtt{blocktype}}_I &
\begin{array}[t]{@{}c@{}} ::= \\ | \\ \end{array}
&
\begin{array}[t]{@{}lcll@{}}
  (t{:}\hyperref[text/types:text-functype]{\mathtt{result}})^? &\Rightarrow& t^? \\
  x,I'{:}\hyperref[text/modules:text-typeuse]{\mathtt{typeuse}}_I &\Rightarrow& x & (\mathrel{\mbox{if}} I' = \{\}) \\
\end{array} \\
\def\mathdef2439#1{{}}\mathdef2439{block instruction} & \hyperref[text/instructions:text-blockinstr]{\mathtt{blockinstr}}_I &::=&
  \def\mathdef2498#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2498{block}~~I'{:}\hyperref[text/instructions:text-label]{\mathtt{label}}_I~~\mathit{bt}{:}\hyperref[text/instructions:text-blocktype]{\mathtt{blocktype}}~~(\mathit{in}{:}\hyperref[text/instructions:text-instr]{\mathtt{instr}}_{I'})^\ast~~\def\mathdef2499#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2499{end}~~\hyperref[text/values:text-id]{\mathtt{id}}^?
    \\ &&&\qquad \Rightarrow\quad \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{block}}~\mathit{bt}~\mathit{in}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}
    \qquad\quad~~ (\mathrel{\mbox{if}} \hyperref[text/values:text-id]{\mathtt{id}}^? = \epsilon \vee \hyperref[text/values:text-id]{\mathtt{id}}^? = \hyperref[text/instructions:text-label]{\mathtt{label}}) \\ &&|&
  \def\mathdef2500#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2500{loop}~~I'{:}\hyperref[text/instructions:text-label]{\mathtt{label}}_I~~\mathit{bt}{:}\hyperref[text/instructions:text-blocktype]{\mathtt{blocktype}}~~(\mathit{in}{:}\hyperref[text/instructions:text-instr]{\mathtt{instr}}_{I'})^\ast~~\def\mathdef2501#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2501{end}~~\hyperref[text/values:text-id]{\mathtt{id}}^?
    \\ &&&\qquad \Rightarrow\quad \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{loop}}~\mathit{bt}~\mathit{in}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}
    \qquad\qquad (\mathrel{\mbox{if}} \hyperref[text/values:text-id]{\mathtt{id}}^? = \epsilon \vee \hyperref[text/values:text-id]{\mathtt{id}}^? = \hyperref[text/instructions:text-label]{\mathtt{label}}) \\ &&|&
  \def\mathdef2502#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2502{if}~~I'{:}\hyperref[text/instructions:text-label]{\mathtt{label}}_I~~\mathit{bt}{:}\hyperref[text/instructions:text-blocktype]{\mathtt{blocktype}}~~(\mathit{in}_1{:}\hyperref[text/instructions:text-instr]{\mathtt{instr}}_{I'})^\ast~~
    \def\mathdef2503#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2503{else}~~\hyperref[text/values:text-id]{\mathtt{id}}_1^?~~(\mathit{in}_2{:}\hyperref[text/instructions:text-instr]{\mathtt{instr}}_{I'})^\ast~~\def\mathdef2504#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2504{end}~~\hyperref[text/values:text-id]{\mathtt{id}}_2^?
    \\ &&&\qquad \Rightarrow\quad \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}~\mathit{bt}~\mathit{in}_1^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{else}}~\mathit{in}_2^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}
    \qquad (\mathrel{\mbox{if}} \hyperref[text/values:text-id]{\mathtt{id}}_1^? = \epsilon \vee \hyperref[text/values:text-id]{\mathtt{id}}_1^? = \hyperref[text/instructions:text-label]{\mathtt{label}}, \hyperref[text/values:text-id]{\mathtt{id}}_2^? = \epsilon \vee \hyperref[text/values:text-id]{\mathtt{id}}_2^? = \hyperref[text/instructions:text-label]{\mathtt{label}}) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The side condition stating that the {\hyperref[\detokenize{text/conventions:text-context}]{\sphinxcrossref{\DUrole{std,std-ref}{identifier context}}}} \(I'\) must be empty in the rule for \(\hyperref[text/modules:text-typeuse]{\mathtt{typeuse}}\) block types enforces that no identifier can be bound in any \(\hyperref[text/types:text-functype]{\mathtt{param}}\) declaration for a block type.
\end{sphinxadmonition}
\phantomsection\label{\detokenize{text/instructions:text-nop}}\phantomsection\label{\detokenize{text/instructions:text-unreachable}}\phantomsection\label{\detokenize{text/instructions:text-br}}\phantomsection\label{\detokenize{text/instructions:text-br-if}}\phantomsection\label{\detokenize{text/instructions:text-br-table}}\phantomsection\label{\detokenize{text/instructions:text-return}}\phantomsection\label{\detokenize{text/instructions:text-call}}\phantomsection\label{\detokenize{text/instructions:text-call-indirect}}
All other control instruction are represented verbatim.
\begin{equation*}
\begin{split}\begin{array}{llcllll}
\def\mathdef2439#1{{}}\mathdef2439{plain instruction} & \hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I &::=&
  \def\mathdef2505#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2505{unreachable} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}} \\ &&|&
  \def\mathdef2506#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2506{nop} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{nop}} \\ &&|&
  \def\mathdef2507#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2507{br}~~l{:}\hyperref[text/modules:text-labelidx]{\mathtt{labelidx}}_I &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br}}~l \\ &&|&
  \def\mathdef2508#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2508{br\_if}~~l{:}\hyperref[text/modules:text-labelidx]{\mathtt{labelidx}}_I &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_if}}~l \\ &&|&
  \def\mathdef2509#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2509{br\_table}~~l^\ast{:}\hyperref[text/conventions:text-vec]{\mathtt{vec}}(\hyperref[text/modules:text-labelidx]{\mathtt{labelidx}}_I)~~l_N{:}\hyperref[text/modules:text-labelidx]{\mathtt{labelidx}}_I
    &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_table}}~l^\ast~l_N \\ &&|&
  \def\mathdef2510#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2510{return} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{return}} \\ &&|&
  \def\mathdef2511#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2511{call}~~x{:}\hyperref[text/modules:text-funcidx]{\mathtt{funcidx}}_I &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call}}~x \\ &&|&
  \def\mathdef2512#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2512{call\_indirect}~~x,I'{:}\hyperref[text/modules:text-typeuse]{\mathtt{typeuse}}_I &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call\_indirect}}~x
    & (\mathrel{\mbox{if}} I' = \{\}) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The side condition stating that the {\hyperref[\detokenize{text/conventions:text-context}]{\sphinxcrossref{\DUrole{std,std-ref}{identifier context}}}} \(I'\) must be empty in the rule for \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{call\_indirect}}\) enforces that no identifier can be bound in any \(\hyperref[text/types:text-functype]{\mathtt{param}}\) declaration appearing in the type annotation.
\end{sphinxadmonition}


\subsubsection{Abbreviations}
\label{\detokenize{text/instructions:abbreviations}}
The \(\def\mathdef2513#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2513{else}\) keyword of an \(\def\mathdef2514#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2514{if}\) instruction can be omitted if the following instruction sequence is empty.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2439#1{{}}\mathdef2439{block instruction} &
  \def\mathdef2515#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2515{if}~~\hyperref[text/instructions:text-label]{\mathtt{label}}~~\hyperref[text/instructions:text-blocktype]{\mathtt{blocktype}}~~\hyperref[text/instructions:text-instr]{\mathtt{instr}}^\ast~~\def\mathdef2516#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2516{end}
    &\equiv&
  \def\mathdef2517#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2517{if}~~\hyperref[text/instructions:text-label]{\mathtt{label}}~~\hyperref[text/instructions:text-blocktype]{\mathtt{blocktype}}~~\hyperref[text/instructions:text-instr]{\mathtt{instr}}^\ast~~\def\mathdef2518#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2518{else}~~\def\mathdef2519#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2519{end}
\end{array}\end{split}
\end{equation*}
\index{value type}\index{polymorphism}\index{text format!instruction}\index{instruction!text format}\ignorespaces 

\subsection{Parametric Instructions}
\label{\detokenize{text/instructions:text-instr-parametric}}\label{\detokenize{text/instructions:parametric-instructions}}\label{\detokenize{text/instructions:index-3}}\phantomsection\label{\detokenize{text/instructions:text-drop}}\phantomsection\label{\detokenize{text/instructions:text-select}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2439#1{{}}\mathdef2439{instruction} & \hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I &::=& \dots \\ &&|&
  \def\mathdef2520#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2520{drop} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{drop}} \\ &&|&
  \def\mathdef2521#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2521{select} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-parametric]{\mathsf{select}} \\
\end{array}\end{split}
\end{equation*}
\index{variable instructions}\index{local index}\index{global index}\index{text format!instruction}\index{instruction!text format}\ignorespaces 

\subsection{Variable Instructions}
\label{\detokenize{text/instructions:index-4}}\label{\detokenize{text/instructions:text-instr-variable}}\label{\detokenize{text/instructions:variable-instructions}}\phantomsection\label{\detokenize{text/instructions:text-local-get}}\phantomsection\label{\detokenize{text/instructions:text-local-set}}\phantomsection\label{\detokenize{text/instructions:text-local-tee}}\phantomsection\label{\detokenize{text/instructions:text-global-get}}\phantomsection\label{\detokenize{text/instructions:text-global-set}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2439#1{{}}\mathdef2439{instruction} & \hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I &::=& \dots \\ &&|&
  \def\mathdef2522#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2522{local.get}~~x{:}\hyperref[text/modules:text-localidx]{\mathtt{localidx}}_I &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.get}}~x \\ &&|&
  \def\mathdef2523#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2523{local.set}~~x{:}\hyperref[text/modules:text-localidx]{\mathtt{localidx}}_I &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.set}}~x \\ &&|&
  \def\mathdef2524#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2524{local.tee}~~x{:}\hyperref[text/modules:text-localidx]{\mathtt{localidx}}_I &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{local.tee}}~x \\ &&|&
  \def\mathdef2525#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2525{global.get}~~x{:}\hyperref[text/modules:text-globalidx]{\mathtt{globalidx}}_I &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.get}}~x \\ &&|&
  \def\mathdef2526#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2526{global.set}~~x{:}\hyperref[text/modules:text-globalidx]{\mathtt{globalidx}}_I &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-variable]{\mathsf{global.set}}~x \\
\end{array}\end{split}
\end{equation*}
\index{memory instruction}\index{memory index}\index{text format!instruction}\index{instruction!text format}\ignorespaces 

\subsection{Memory Instructions}
\label{\detokenize{text/instructions:memory-instructions}}\label{\detokenize{text/instructions:text-instr-memory}}\label{\detokenize{text/instructions:index-5}}\phantomsection\label{\detokenize{text/instructions:text-memarg}}\phantomsection\label{\detokenize{text/instructions:text-load}}\phantomsection\label{\detokenize{text/instructions:text-loadn}}\phantomsection\label{\detokenize{text/instructions:text-store}}\phantomsection\label{\detokenize{text/instructions:text-storen}}\phantomsection\label{\detokenize{text/instructions:text-memory-size}}\phantomsection\label{\detokenize{text/instructions:text-memory-grow}}
The offset and alignment immediates to memory instructions are optional.
The offset defaults to \(\mathtt{0}\), the alignment to the storage size of the respective memory access, which is its \sphinxstyleemphasis{natural alignment}.
Lexically, an \(\hyperref[text/instructions:text-memarg]{\mathtt{offset}}\) or \(\hyperref[text/instructions:text-memarg]{\mathtt{align}}\) phrase is considered a single {\hyperref[\detokenize{text/lexical:text-keyword}]{\sphinxcrossref{\DUrole{std,std-ref}{keyword token}}}}, so no {\hyperref[\detokenize{text/lexical:text-space}]{\sphinxcrossref{\DUrole{std,std-ref}{white space}}}} is allowed around the \(\def\mathdef2527#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2527{=}\).
\begin{equation*}
\begin{split}\begin{array}{llcllll}
\def\mathdef2439#1{{}}\mathdef2439{memory argument} & \hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_N &::=&
  o{:}\hyperref[text/instructions:text-memarg]{\mathtt{offset}}~~a{:}\hyperref[text/instructions:text-memarg]{\mathtt{align}}_N &\Rightarrow& \{ \hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{align}}~n,~\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{offset}}~o \} & (\mathrel{\mbox{if}} a = 2^n) \\
\def\mathdef2439#1{{}}\mathdef2439{memory offset} & \hyperref[text/instructions:text-memarg]{\mathtt{offset}} &::=&
  \def\mathdef2528#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2528{offset{=}}o{:}\hyperref[text/values:text-int]{\def\mathdef2486#1{{\mathtt{u}#1}}\mathdef2486{\mathtt{32}}} &\Rightarrow& o \\ &&|&
  \epsilon &\Rightarrow& 0 \\
\def\mathdef2439#1{{}}\mathdef2439{memory alignment} & \hyperref[text/instructions:text-memarg]{\mathtt{align}}_N &::=&
  \def\mathdef2529#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2529{align{=}}a{:}\hyperref[text/values:text-int]{\def\mathdef2486#1{{\mathtt{u}#1}}\mathdef2486{\mathtt{32}}} &\Rightarrow& a \\ &&|&
  \epsilon &\Rightarrow& N \\
\def\mathdef2439#1{{}}\mathdef2439{instruction} & \hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I &::=& \dots \\ &&|&
  \def\mathdef2530#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2530{i32.load}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_4 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}~m \\ &&|&
  \def\mathdef2531#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2531{i64.load}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_8 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}~m \\ &&|&
  \def\mathdef2532#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2532{f32.load}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_4 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}~m \\ &&|&
  \def\mathdef2533#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2533{f64.load}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_8 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}~m \\ &&|&
  \def\mathdef2534#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2534{i32.load8\_s}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_1 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{8\_s}~m \\ &&|&
  \def\mathdef2535#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2535{i32.load8\_u}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_1 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{8\_u}~m \\ &&|&
  \def\mathdef2536#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2536{i32.load16\_s}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_2 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{16\_s}~m \\ &&|&
  \def\mathdef2537#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2537{i32.load16\_u}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_2 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{16\_u}~m \\ &&|&
  \def\mathdef2538#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2538{i64.load8\_s}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_1 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{8\_s}~m \\ &&|&
  \def\mathdef2539#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2539{i64.load8\_u}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_1 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{8\_u}~m \\ &&|&
  \def\mathdef2540#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2540{i64.load16\_s}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_2 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{16\_s}~m \\ &&|&
  \def\mathdef2541#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2541{i64.load16\_u}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_2 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{16\_u}~m \\ &&|&
  \def\mathdef2542#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2542{i64.load32\_s}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_4 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{32\_s}~m \\ &&|&
  \def\mathdef2543#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2543{i64.load32\_u}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_4 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{load}}\mathsf{32\_u}~m \\ &&|&
  \def\mathdef2544#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2544{i32.store}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_4 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}~m \\ &&|&
  \def\mathdef2545#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2545{i64.store}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_8 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}~m \\ &&|&
  \def\mathdef2546#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2546{f32.store}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_4 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}~m \\ &&|&
  \def\mathdef2547#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2547{f64.store}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_8 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}~m \\ &&|&
  \def\mathdef2548#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2548{i32.store8}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_1 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}\mathsf{8}~m \\ &&|&
  \def\mathdef2549#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2549{i32.store16}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_2 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}\mathsf{16}~m \\ &&|&
  \def\mathdef2550#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2550{i64.store8}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_1 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}\mathsf{8}~m \\ &&|&
  \def\mathdef2551#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2551{i64.store16}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_2 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}\mathsf{16}~m \\ &&|&
  \def\mathdef2552#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2552{i64.store32}~~m{:}\hyperref[text/instructions:text-memarg]{\mathtt{memarg}}_4 &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{store}}\mathsf{32}~m \\ &&|&
  \def\mathdef2553#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2553{memory.size} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.size}} \\ &&|&
  \def\mathdef2554#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2554{memory.grow} &\Rightarrow& \hyperref[syntax/instructions:syntax-instr-memory]{\mathsf{memory.grow}} \\
\end{array}\end{split}
\end{equation*}
\index{numeric instruction}\index{text format!instruction}\index{instruction!text format}\ignorespaces 

\subsection{Numeric Instructions}
\label{\detokenize{text/instructions:index-6}}\label{\detokenize{text/instructions:text-instr-numeric}}\label{\detokenize{text/instructions:numeric-instructions}}\phantomsection\label{\detokenize{text/instructions:text-const}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2439#1{{}}\mathdef2439{instruction} & \hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I &::=& \dots \\&&|&
  \def\mathdef2555#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2555{i32.const}~~n{:}\hyperref[text/values:text-int]{\def\mathdef2492#1{{\mathtt{i}#1}}\mathdef2492{\mathtt{32}}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~n \\ &&|&
  \def\mathdef2556#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2556{i64.const}~~n{:}\hyperref[text/values:text-int]{\def\mathdef2493#1{{\mathtt{i}#1}}\mathdef2493{\mathtt{64}}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~n \\ &&|&
  \def\mathdef2557#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2557{f32.const}~~z{:}\hyperref[text/values:text-float]{\def\mathdef2496#1{{\mathtt{f}#1}}\mathdef2496{\mathtt{32}}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~z \\ &&|&
  \def\mathdef2558#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2558{f64.const}~~z{:}\hyperref[text/values:text-float]{\def\mathdef2497#1{{\mathtt{f}#1}}\mathdef2497{\mathtt{64}}} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~z \\
\end{array}\end{split}
\end{equation*}\phantomsection\label{\detokenize{text/instructions:text-unop}}\phantomsection\label{\detokenize{text/instructions:text-binop}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef2439#1{{}}\mathdef2439{instruction}} & \phantom{\hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I} &\phantom{::=}& \phantom{thisisenough} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef2559#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2559{i32.clz} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{clz}} \\ &&|&
  \def\mathdef2560#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2560{i32.ctz} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ctz}} \\ &&|&
  \def\mathdef2561#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2561{i32.popcnt} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{popcnt}} \\ &&|&
  \def\mathdef2562#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2562{i32.add} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}} \\ &&|&
  \def\mathdef2563#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2563{i32.sub} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{sub}} \\ &&|&
  \def\mathdef2564#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2564{i32.mul} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{mul}} \\ &&|&
  \def\mathdef2565#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2565{i32.div\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{div}}\mathsf{\_s} \\ &&|&
  \def\mathdef2566#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2566{i32.div\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{div}}\mathsf{\_u} \\ &&|&
  \def\mathdef2567#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2567{i32.rem\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rem}}\mathsf{\_s} \\ &&|&
  \def\mathdef2568#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2568{i32.rem\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rem}}\mathsf{\_u} \\ &&|&
  \def\mathdef2569#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2569{i32.and} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{and}} \\ &&|&
  \def\mathdef2570#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2570{i32.or} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{or}} \\ &&|&
  \def\mathdef2571#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2571{i32.xor} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{xor}} \\ &&|&
  \def\mathdef2572#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2572{i32.shl} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{shl}} \\ &&|&
  \def\mathdef2573#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2573{i32.shr\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{shr}}\mathsf{\_s} \\ &&|&
  \def\mathdef2574#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2574{i32.shr\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{shr}}\mathsf{\_u} \\ &&|&
  \def\mathdef2575#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2575{i32.rotl} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rotl}} \\ &&|&
  \def\mathdef2576#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2576{i32.rotr} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rotr}} \\
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef2439#1{{}}\mathdef2439{instruction}} & \phantom{\hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I} &\phantom{::=}& \phantom{thisisenough} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef2577#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2577{i64.clz} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{clz}} \\ &&|&
  \def\mathdef2578#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2578{i64.ctz} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ctz}} \\ &&|&
  \def\mathdef2579#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2579{i64.popcnt} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{popcnt}} \\ &&|&
  \def\mathdef2580#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2580{i64.add} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}} \\ &&|&
  \def\mathdef2581#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2581{i64.sub} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{sub}} \\ &&|&
  \def\mathdef2582#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2582{i64.mul} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{mul}} \\ &&|&
  \def\mathdef2583#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2583{i64.div\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{div}}\mathsf{\_s} \\ &&|&
  \def\mathdef2584#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2584{i64.div\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{div}}\mathsf{\_u} \\ &&|&
  \def\mathdef2585#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2585{i64.rem\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rem}}\mathsf{\_s} \\ &&|&
  \def\mathdef2586#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2586{i64.rem\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rem}}\mathsf{\_u} \\ &&|&
  \def\mathdef2587#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2587{i64.and} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{and}} \\ &&|&
  \def\mathdef2588#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2588{i64.or} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{or}} \\ &&|&
  \def\mathdef2589#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2589{i64.xor} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{xor}} \\ &&|&
  \def\mathdef2590#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2590{i64.shl} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{shl}} \\ &&|&
  \def\mathdef2591#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2591{i64.shr\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{shr}}\mathsf{\_s} \\ &&|&
  \def\mathdef2592#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2592{i64.shr\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{shr}}\mathsf{\_u} \\ &&|&
  \def\mathdef2593#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2593{i64.rotl} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rotl}} \\ &&|&
  \def\mathdef2594#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2594{i64.rotr} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{rotr}} \\
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef2439#1{{}}\mathdef2439{instruction}} & \phantom{\hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I} &\phantom{::=}& \phantom{thisisenough} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef2595#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2595{f32.abs} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{abs}} \\ &&|&
  \def\mathdef2596#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2596{f32.neg} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{neg}} \\ &&|&
  \def\mathdef2597#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2597{f32.ceil} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ceil}} \\ &&|&
  \def\mathdef2598#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2598{f32.floor} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{floor}} \\ &&|&
  \def\mathdef2599#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2599{f32.trunc} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}} \\ &&|&
  \def\mathdef2600#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2600{f32.nearest} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{nearest}} \\ &&|&
  \def\mathdef2601#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2601{f32.sqrt} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{sqrt}} \\ &&|&
  \def\mathdef2602#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2602{f32.add} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}} \\ &&|&
  \def\mathdef2603#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2603{f32.sub} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{sub}} \\ &&|&
  \def\mathdef2604#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2604{f32.mul} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{mul}} \\ &&|&
  \def\mathdef2605#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2605{f32.div} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{div}} \\ &&|&
  \def\mathdef2606#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2606{f32.min} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{min}} \\ &&|&
  \def\mathdef2607#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2607{f32.max} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{max}} \\ &&|&
  \def\mathdef2608#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2608{f32.copysign} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{copysign}} \\
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef2439#1{{}}\mathdef2439{instruction}} & \phantom{\hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I} &\phantom{::=}& \phantom{thisisenough} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef2609#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2609{f64.abs} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{abs}} \\ &&|&
  \def\mathdef2610#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2610{f64.neg} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{neg}} \\ &&|&
  \def\mathdef2611#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2611{f64.ceil} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ceil}} \\ &&|&
  \def\mathdef2612#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2612{f64.floor} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{floor}} \\ &&|&
  \def\mathdef2613#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2613{f64.trunc} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}} \\ &&|&
  \def\mathdef2614#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2614{f64.nearest} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{nearest}} \\ &&|&
  \def\mathdef2615#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2615{f64.sqrt} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{sqrt}} \\ &&|&
  \def\mathdef2616#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2616{f64.add} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}} \\ &&|&
  \def\mathdef2617#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2617{f64.sub} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{sub}} \\ &&|&
  \def\mathdef2618#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2618{f64.mul} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{mul}} \\ &&|&
  \def\mathdef2619#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2619{f64.div} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{div}} \\ &&|&
  \def\mathdef2620#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2620{f64.min} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{min}} \\ &&|&
  \def\mathdef2621#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2621{f64.max} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{max}} \\ &&|&
  \def\mathdef2622#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2622{f64.copysign} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{copysign}} \\
\end{array}\end{split}
\end{equation*}\phantomsection\label{\detokenize{text/instructions:text-testop}}\phantomsection\label{\detokenize{text/instructions:text-relop}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef2439#1{{}}\mathdef2439{instruction}} & \phantom{\hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I} &\phantom{::=}& \phantom{thisisenough} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef2623#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2623{i32.eqz} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{eqz}} \\ &&|&
  \def\mathdef2624#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2624{i32.eq} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{eq}} \\ &&|&
  \def\mathdef2625#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2625{i32.ne} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ne}} \\ &&|&
  \def\mathdef2626#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2626{i32.lt\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{lt}}\mathsf{\_s} \\ &&|&
  \def\mathdef2627#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2627{i32.lt\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{lt}}\mathsf{\_u} \\ &&|&
  \def\mathdef2628#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2628{i32.gt\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{gt}}\mathsf{\_s} \\ &&|&
  \def\mathdef2629#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2629{i32.gt\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{gt}}\mathsf{\_u} \\ &&|&
  \def\mathdef2630#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2630{i32.le\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{le}}\mathsf{\_s} \\ &&|&
  \def\mathdef2631#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2631{i32.le\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{le}}\mathsf{\_u} \\ &&|&
  \def\mathdef2632#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2632{i32.ge\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ge}}\mathsf{\_s} \\ &&|&
  \def\mathdef2633#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2633{i32.ge\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ge}}\mathsf{\_u} \\
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef2439#1{{}}\mathdef2439{instruction}} & \phantom{\hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I} &\phantom{::=}& \phantom{thisisenough} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef2634#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2634{i64.eqz} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{eqz}} \\ &&|&
  \def\mathdef2635#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2635{i64.eq} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{eq}} \\ &&|&
  \def\mathdef2636#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2636{i64.ne} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ne}} \\ &&|&
  \def\mathdef2637#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2637{i64.lt\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{lt}}\mathsf{\_s} \\ &&|&
  \def\mathdef2638#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2638{i64.lt\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{lt}}\mathsf{\_u} \\ &&|&
  \def\mathdef2639#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2639{i64.gt\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{gt}}\mathsf{\_s} \\ &&|&
  \def\mathdef2640#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2640{i64.gt\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{gt}}\mathsf{\_u} \\ &&|&
  \def\mathdef2641#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2641{i64.le\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{le}}\mathsf{\_s} \\ &&|&
  \def\mathdef2642#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2642{i64.le\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{le}}\mathsf{\_u} \\ &&|&
  \def\mathdef2643#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2643{i64.ge\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ge}}\mathsf{\_s} \\ &&|&
  \def\mathdef2644#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2644{i64.ge\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ge}}\mathsf{\_u} \\
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef2439#1{{}}\mathdef2439{instruction}} & \phantom{\hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I} &\phantom{::=}& \phantom{thisisenough} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef2645#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2645{f32.eq} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{eq}} \\ &&|&
  \def\mathdef2646#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2646{f32.ne} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ne}} \\ &&|&
  \def\mathdef2647#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2647{f32.lt} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{lt}} \\ &&|&
  \def\mathdef2648#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2648{f32.gt} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{gt}} \\ &&|&
  \def\mathdef2649#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2649{f32.le} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{le}} \\ &&|&
  \def\mathdef2650#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2650{f32.ge} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ge}} \\
\end{array}\end{split}
\end{equation*}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef2439#1{{}}\mathdef2439{instruction}} & \phantom{\hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I} &\phantom{::=}& \phantom{thisisenough} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef2651#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2651{f64.eq} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{eq}} \\ &&|&
  \def\mathdef2652#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2652{f64.ne} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ne}} \\ &&|&
  \def\mathdef2653#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2653{f64.lt} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{lt}} \\ &&|&
  \def\mathdef2654#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2654{f64.gt} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{gt}} \\ &&|&
  \def\mathdef2655#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2655{f64.le} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{le}} \\ &&|&
  \def\mathdef2656#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2656{f64.ge} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{ge}} \\
\end{array}\end{split}
\end{equation*}\phantomsection\label{\detokenize{text/instructions:text-cvtop}}\begin{equation*}
\begin{split}\begin{array}{llclll}
\phantom{\def\mathdef2439#1{{}}\mathdef2439{instruction}} & \phantom{\hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}_I} &\phantom{::=}& \phantom{thisisenough} && \phantom{thisshouldbeenough} \\[-2ex] &&|&
  \def\mathdef2657#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2657{i32.wrap\_i64} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{wrap}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}} \\ &&|&
  \def\mathdef2658#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2658{i32.trunc\_f32\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}\mathsf{\_s} \\ &&|&
  \def\mathdef2659#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2659{i32.trunc\_f32\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}\mathsf{\_u} \\ &&|&
  \def\mathdef2660#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2660{i32.trunc\_f64\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}\mathsf{\_s} \\ &&|&
  \def\mathdef2661#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2661{i32.trunc\_f64\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}\mathsf{\_u} \\ &&|&
  \def\mathdef2662#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2662{i64.extend\_i32\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{extend}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{\_s} \\ &&|&
  \def\mathdef2663#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2663{i64.extend\_i32\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{extend}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{\_u} \\ &&|&
  \def\mathdef2664#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2664{i64.trunc\_f32\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}\mathsf{\_s} \\ &&|&
  \def\mathdef2665#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2665{i64.trunc\_f32\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}\mathsf{\_u} \\ &&|&
  \def\mathdef2666#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2666{i64.trunc\_f64\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}\mathsf{\_s} \\ &&|&
  \def\mathdef2667#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2667{i64.trunc\_f64\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{trunc}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}\mathsf{\_u} \\ &&|&
  \def\mathdef2668#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2668{f32.convert\_i32\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{\_s} \\ &&|&
  \def\mathdef2669#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2669{f32.convert\_i32\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{\_u} \\ &&|&
  \def\mathdef2670#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2670{f32.convert\_i64\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}\mathsf{\_s} \\ &&|&
  \def\mathdef2671#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2671{f32.convert\_i64\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}\mathsf{\_u} \\ &&|&
  \def\mathdef2672#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2672{f32.demote\_f64} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{demote}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}} \\ &&|&
  \def\mathdef2673#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2673{f64.convert\_i32\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{\_s} \\ &&|&
  \def\mathdef2674#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2674{f64.convert\_i32\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}\mathsf{\_u} \\ &&|&
  \def\mathdef2675#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2675{f64.convert\_i64\_s} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}\mathsf{\_s} \\ &&|&
  \def\mathdef2676#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2676{f64.convert\_i64\_u} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{convert}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}\mathsf{\_u} \\ &&|&
  \def\mathdef2677#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2677{f64.promote\_f32} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{promote}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f32}} \\ &&|&
  \def\mathdef2678#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2678{i32.reinterpret\_f32} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{reinterpret}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f32}} \\ &&|&
  \def\mathdef2679#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2679{i64.reinterpret\_f64} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{reinterpret}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{f64}} \\ &&|&
  \def\mathdef2680#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2680{f32.reinterpret\_i32} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{reinterpret}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}} \\ &&|&
  \def\mathdef2681#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2681{f64.reinterpret\_i64} &\Rightarrow& \hyperref[syntax/types:syntax-valtype]{\mathsf{f64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{reinterpret}}\mathsf{\_}\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}} \\
\end{array}\end{split}
\end{equation*}
\index{folded instruction|textbf}\index{S-expression}\ignorespaces 

\subsection{Folded Instructions}
\label{\detokenize{text/instructions:index-7}}\label{\detokenize{text/instructions:text-foldedinstr}}\label{\detokenize{text/instructions:folded-instructions}}
Instructions can be written as S-expressions by grouping them into \sphinxstyleemphasis{folded} form. In that notation, an instruction is wrapped in parentheses and optionally includes nested folded instructions to indicate its operands.

In the case of {\hyperref[\detokenize{text/instructions:text-instr-block}]{\sphinxcrossref{\DUrole{std,std-ref}{block instructions}}}}, the folded form omits the \(\def\mathdef2682#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2682{end}\) delimiter.
For \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{if}}\) instructions, both branches have to be wrapped into nested S-expressions, headed by the keywords \(\def\mathdef2683#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2683{then}\) and \(\def\mathdef2684#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2684{else}\).

The set of all phrases defined by the following abbreviations recursively forms the auxiliary syntactic class \(\hyperref[text/instructions:text-foldedinstr]{\mathtt{foldedinstr}}\).
Such a folded instruction can appear anywhere a regular instruction can.
\begin{equation*}
\begin{split}\begin{array}{lllll}
\def\mathdef2439#1{{}}\mathdef2439{instruction} &
  \def\mathdef2685#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2685{(}~\hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}}~~\hyperref[text/instructions:text-foldedinstr]{\mathtt{foldedinstr}}^\ast~\def\mathdef2686#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2686{)}
    &\equiv\quad \hyperref[text/instructions:text-foldedinstr]{\mathtt{foldedinstr}}^\ast~~\hyperref[text/instructions:text-plaininstr]{\mathtt{plaininstr}} \\ &
  \def\mathdef2687#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2687{(}~\def\mathdef2688#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2688{block}~~\hyperref[text/instructions:text-label]{\mathtt{label}}~~\hyperref[text/instructions:text-blocktype]{\mathtt{blocktype}}~~\hyperref[text/instructions:text-instr]{\mathtt{instr}}^\ast~\def\mathdef2689#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2689{)}
    &\equiv\quad \def\mathdef2690#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2690{block}~~\hyperref[text/instructions:text-label]{\mathtt{label}}~~\hyperref[text/instructions:text-blocktype]{\mathtt{blocktype}}~~\hyperref[text/instructions:text-instr]{\mathtt{instr}}^\ast~~\def\mathdef2691#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2691{end} \\ &
  \def\mathdef2692#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2692{(}~\def\mathdef2693#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2693{loop}~~\hyperref[text/instructions:text-label]{\mathtt{label}}~~\hyperref[text/instructions:text-blocktype]{\mathtt{blocktype}}~~\hyperref[text/instructions:text-instr]{\mathtt{instr}}^\ast~\def\mathdef2694#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2694{)}
    &\equiv\quad \def\mathdef2695#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2695{loop}~~\hyperref[text/instructions:text-label]{\mathtt{label}}~~\hyperref[text/instructions:text-blocktype]{\mathtt{blocktype}}~~\hyperref[text/instructions:text-instr]{\mathtt{instr}}^\ast~~\def\mathdef2696#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2696{end} \\ &
  \def\mathdef2697#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2697{(}~\def\mathdef2698#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2698{if}~~\hyperref[text/instructions:text-label]{\mathtt{label}}~~\hyperref[text/instructions:text-blocktype]{\mathtt{blocktype}}~~\hyperref[text/instructions:text-foldedinstr]{\mathtt{foldedinstr}}^\ast
    &\hspace{-3ex} \def\mathdef2699#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2699{(}~\def\mathdef2700#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2700{then}~~\hyperref[text/instructions:text-instr]{\mathtt{instr}}_1^\ast~\def\mathdef2701#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2701{)}~~\def\mathdef2702#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2702{(}~\def\mathdef2703#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2703{else}~~\hyperref[text/instructions:text-instr]{\mathtt{instr}}_2^\ast~\def\mathdef2704#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2704{)}^?~~\def\mathdef2705#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2705{)}
    \quad\equiv \\ &\qquad
      \hyperref[text/instructions:text-foldedinstr]{\mathtt{foldedinstr}}^\ast~~\def\mathdef2706#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2706{if}~~\hyperref[text/instructions:text-label]{\mathtt{label}}~~\hyperref[text/instructions:text-blocktype]{\mathtt{blocktype}} &\hspace{-1ex} \hyperref[text/instructions:text-instr]{\mathtt{instr}}_1^\ast~~\def\mathdef2707#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2707{else}~~(\hyperref[text/instructions:text-instr]{\mathtt{instr}}_2^\ast)^?~\def\mathdef2708#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2708{end} \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
For example, the instruction sequence
\begin{equation*}
\begin{split}\mathtt{(get\_local~\$x)~(i32.const~2)~i32.add~(i32.const~3)~i32.mul}\end{split}
\end{equation*}
can be folded into
\begin{equation*}
\begin{split}\mathtt{(i32.mul~(i32.add~(get\_local~\$x)~(i32.const~2))~(i32.const~3))}\end{split}
\end{equation*}
Folded instructions are solely syntactic sugar,
no additional syntactic or type-based checking is implied.
\end{sphinxadmonition}

\index{expression}\index{text format!expression}\index{expression!text format}\index{expression!constant}\ignorespaces 

\subsection{Expressions}
\label{\detokenize{text/instructions:expressions}}\label{\detokenize{text/instructions:text-expr}}\label{\detokenize{text/instructions:index-8}}
Expressions are written as instruction sequences.
No explicit \(\def\mathdef2709#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2709{end}\) keyword is included, since they only occur in bracketed positions.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2439#1{{}}\mathdef2439{expression} & \hyperref[text/instructions:text-expr]{\mathtt{expr}} &::=&
  (\mathit{in}{:}\hyperref[text/instructions:text-instr]{\mathtt{instr}})^\ast &\Rightarrow& \mathit{in}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \\
\end{array}\end{split}
\end{equation*}

\section{Modules}
\label{\detokenize{text/modules::doc}}\label{\detokenize{text/modules:modules}}
\index{index}\index{type index}\index{function index}\index{table index}\index{memory index}\index{global index}\index{local index}\index{label index}\index{text format!type index}\index{type index!text format}\index{text format!function index}\index{function index!text format}\index{text format!table index}\index{table index!text format}\index{text format!memory index}\index{memory index!text format}\index{text format!global index}\index{global index!text format}\index{text format!local index}\index{local index!text format}\index{text format!label index}\index{label index!text format}\ignorespaces \phantomsection\label{\detokenize{text/modules:text-typeidx}}\phantomsection\label{\detokenize{text/modules:text-funcidx}}\phantomsection\label{\detokenize{text/modules:text-tableidx}}\phantomsection\label{\detokenize{text/modules:text-memidx}}\phantomsection\label{\detokenize{text/modules:text-globalidx}}\phantomsection\label{\detokenize{text/modules:text-localidx}}\phantomsection\label{\detokenize{text/modules:text-labelidx}}

\subsection{Indices}
\label{\detokenize{text/modules:text-memidx}}\label{\detokenize{text/modules:text-tableidx}}\label{\detokenize{text/modules:text-funcidx}}\label{\detokenize{text/modules:indices}}\label{\detokenize{text/modules:index-0}}\label{\detokenize{text/modules:text-globalidx}}\label{\detokenize{text/modules:text-localidx}}\label{\detokenize{text/modules:text-typeidx}}\label{\detokenize{text/modules:text-index}}\label{\detokenize{text/modules:text-labelidx}}
{\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{Indices}}}} can be given either in raw numeric form or as symbolic {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{identifiers}}}} when bound by a respective construct.
Such identifiers are looked up in the suitable space of the {\hyperref[\detokenize{text/conventions:text-context}]{\sphinxcrossref{\DUrole{std,std-ref}{identifier context}}}} \(I\).
\begin{equation*}
\begin{split}\begin{array}{llcllllllll}
\def\mathdef2796#1{{}}\mathdef2796{type index} & \hyperref[text/modules:text-typeidx]{\mathtt{typeidx}}_I &::=&
  x{:}\hyperref[text/values:text-int]{\def\mathdef2843#1{{\mathtt{u}#1}}\mathdef2843{\mathtt{32}}} &\Rightarrow& x \\&&|&
  v{:}\hyperref[text/values:text-id]{\mathtt{id}} &\Rightarrow& x & (\mathrel{\mbox{if}} I.\hyperref[text/conventions:text-context]{\mathsf{types}}[x] = v) \\
\def\mathdef2796#1{{}}\mathdef2796{function index} & \hyperref[text/modules:text-funcidx]{\mathtt{funcidx}}_I &::=&
  x{:}\hyperref[text/values:text-int]{\def\mathdef2843#1{{\mathtt{u}#1}}\mathdef2843{\mathtt{32}}} &\Rightarrow& x \\&&|&
  v{:}\hyperref[text/values:text-id]{\mathtt{id}} &\Rightarrow& x & (\mathrel{\mbox{if}} I.\hyperref[text/conventions:text-context]{\mathsf{funcs}}[x] = v) \\
\def\mathdef2796#1{{}}\mathdef2796{table index} & \hyperref[text/modules:text-tableidx]{\mathtt{tableidx}}_I &::=&
  x{:}\hyperref[text/values:text-int]{\def\mathdef2843#1{{\mathtt{u}#1}}\mathdef2843{\mathtt{32}}} &\Rightarrow& x \\&&|&
  v{:}\hyperref[text/values:text-id]{\mathtt{id}} &\Rightarrow& x & (\mathrel{\mbox{if}} I.\hyperref[text/conventions:text-context]{\mathsf{tables}}[x] = v) \\
\def\mathdef2796#1{{}}\mathdef2796{memory index} & \hyperref[text/modules:text-memidx]{\mathtt{memidx}}_I &::=&
  x{:}\hyperref[text/values:text-int]{\def\mathdef2843#1{{\mathtt{u}#1}}\mathdef2843{\mathtt{32}}} &\Rightarrow& x \\&&|&
  v{:}\hyperref[text/values:text-id]{\mathtt{id}} &\Rightarrow& x & (\mathrel{\mbox{if}} I.\hyperref[text/conventions:text-context]{\mathsf{mems}}[x] = v) \\
\def\mathdef2796#1{{}}\mathdef2796{global index} & \hyperref[text/modules:text-globalidx]{\mathtt{globalidx}}_I &::=&
  x{:}\hyperref[text/values:text-int]{\def\mathdef2843#1{{\mathtt{u}#1}}\mathdef2843{\mathtt{32}}} &\Rightarrow& x \\&&|&
  v{:}\hyperref[text/values:text-id]{\mathtt{id}} &\Rightarrow& x & (\mathrel{\mbox{if}} I.\hyperref[text/conventions:text-context]{\mathsf{globals}}[x] = v) \\
\def\mathdef2796#1{{}}\mathdef2796{local index} & \hyperref[text/modules:text-localidx]{\mathtt{localidx}}_I &::=&
  x{:}\hyperref[text/values:text-int]{\def\mathdef2843#1{{\mathtt{u}#1}}\mathdef2843{\mathtt{32}}} &\Rightarrow& x \\&&|&
  v{:}\hyperref[text/values:text-id]{\mathtt{id}} &\Rightarrow& x & (\mathrel{\mbox{if}} I.\hyperref[text/conventions:text-context]{\mathsf{locals}}[x] = v) \\
\def\mathdef2796#1{{}}\mathdef2796{label index} & \hyperref[text/modules:text-labelidx]{\mathtt{labelidx}}_I &::=&
  l{:}\hyperref[text/values:text-int]{\def\mathdef2843#1{{\mathtt{u}#1}}\mathdef2843{\mathtt{32}}} &\Rightarrow& l \\&&|&
  v{:}\hyperref[text/values:text-id]{\mathtt{id}} &\Rightarrow& l & (\mathrel{\mbox{if}} I.\hyperref[text/conventions:text-context]{\mathsf{labels}}[l] = v) \\
\end{array}\end{split}
\end{equation*}
\index{type definition}\index{identifier}\index{text format!type definition}\index{type definition!text format}\ignorespaces 

\subsection{Types}
\label{\detokenize{text/modules:types}}\label{\detokenize{text/modules:text-typedef}}\label{\detokenize{text/modules:index-1}}
Type definitions can bind a symbolic {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{type identifier}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{type definition} & \hyperref[text/modules:text-typedef]{\mathtt{type}} &::=&
  \def\mathdef2855#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2855{(}~\def\mathdef2856#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2856{type}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\mathit{ft}{:}\hyperref[text/types:text-functype]{\mathtt{functype}}~\def\mathdef2857#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2857{)}
    &\Rightarrow& \mathit{ft} \\
\end{array}\end{split}
\end{equation*}
\index{type use}\index{text format!type use}\index{type use!text format}\ignorespaces 

\subsection{Type Uses}
\label{\detokenize{text/modules:index-2}}\label{\detokenize{text/modules:type-uses}}\label{\detokenize{text/modules:text-typeuse}}
A \sphinxstyleemphasis{type use} is a reference to a {\hyperref[\detokenize{text/types:text-type}]{\sphinxcrossref{\DUrole{std,std-ref}{type definition}}}}.
It may optionally be augmented by explicit inlined {\hyperref[\detokenize{text/types:text-param}]{\sphinxcrossref{\DUrole{std,std-ref}{parameter}}}} and {\hyperref[\detokenize{text/types:text-result}]{\sphinxcrossref{\DUrole{std,std-ref}{result}}}} declarations.
That allows binding symbolic {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{identifiers}}}} to name the {\hyperref[\detokenize{text/modules:text-localidx}]{\sphinxcrossref{\DUrole{std,std-ref}{local indices}}}} of parameters.
If inline declarations are given, then their types must match the referenced {\hyperref[\detokenize{text/types:text-type}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}}.
\begin{equation*}
\begin{split}\begin{array}{llcllll}
\def\mathdef2796#1{{}}\mathdef2796{type use} & \hyperref[text/modules:text-typeuse]{\mathtt{typeuse}}_I &::=&
  \def\mathdef2858#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2858{(}~\def\mathdef2859#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2859{type}~~x{:}\hyperref[text/modules:text-typeidx]{\mathtt{typeidx}}_I~\def\mathdef2860#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2860{)}
    \quad\Rightarrow\quad x, I' \\ &&& \qquad
    (\mathrel{\mbox{if}} \begin{array}[t]{@{}l@{}}
     I.\hyperref[text/conventions:text-context]{\mathsf{typedefs}}[x] = [t_1^n] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast] \wedge
     I' = \{\hyperref[text/conventions:text-context]{\mathsf{locals}}~(\epsilon)^n\}) \\
     \end{array} \\[1ex] &&|&
  \def\mathdef2861#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2861{(}~\def\mathdef2862#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2862{type}~~x{:}\hyperref[text/modules:text-typeidx]{\mathtt{typeidx}}_I~\def\mathdef2863#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2863{)}
  ~~(t_1{:}\hyperref[text/types:text-functype]{\mathtt{param}})^\ast~~(t_2{:}\hyperref[text/types:text-functype]{\mathtt{result}})^\ast
    \quad\Rightarrow\quad x, I' \\ &&& \qquad
    (\mathrel{\mbox{if}} \begin{array}[t]{@{}l@{}}
     I.\hyperref[text/conventions:text-context]{\mathsf{typedefs}}[x] = [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast] \wedge
     I' = \{\hyperref[text/conventions:text-context]{\mathsf{locals}}~\mathrm{id}(\hyperref[text/types:text-functype]{\mathtt{param}})^\ast\} ~\hyperref[text/conventions:text-context-wf]{\mbox{well-formed}}) \\
     \end{array} \\
\end{array}\end{split}
\end{equation*}
The synthesized attribute of a \(\hyperref[text/modules:text-typeuse]{\mathtt{typeuse}}\) is a pair consisting of both the used {\hyperref[\detokenize{syntax/modules:syntax-typeidx}]{\sphinxcrossref{\DUrole{std,std-ref}{type index}}}} and the updated {\hyperref[\detokenize{text/conventions:text-context}]{\sphinxcrossref{\DUrole{std,std-ref}{identifier context}}}} including possible parameter identifiers.
The following auxiliary function extracts optional identifiers from parameters:
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad\qquad}l}
\mathrm{id}(\def\mathdef2864#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2864{(}~\def\mathdef2865#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2865{param}~\hyperref[text/values:text-id]{\mathtt{id}}^?~\dots~\def\mathdef2866#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2866{)}) &=& \hyperref[text/values:text-id]{\mathtt{id}}^? \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
Both productions overlap for the case that the function type is \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} []\).
However, in that case, they also produce the same results, so that the choice is immaterial.

The {\hyperref[\detokenize{text/conventions:text-context-wf}]{\sphinxcrossref{\DUrole{std,std-ref}{well-formedness}}}} condition on \(I'\) ensures that the parameters do not contain duplicate identifier.
\end{sphinxadmonition}


\subsubsection{Abbreviations}
\label{\detokenize{text/modules:abbreviations}}\label{\detokenize{text/modules:text-typeuse-abbrev}}
A \(\hyperref[text/modules:text-typeuse]{\mathtt{typeuse}}\) may also be replaced entirely by inline {\hyperref[\detokenize{text/types:text-param}]{\sphinxcrossref{\DUrole{std,std-ref}{parameter}}}} and {\hyperref[\detokenize{text/types:text-result}]{\sphinxcrossref{\DUrole{std,std-ref}{result}}}} declarations.
In that case, a {\hyperref[\detokenize{syntax/modules:syntax-typeidx}]{\sphinxcrossref{\DUrole{std,std-ref}{type index}}}} is automatically inserted:
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{type use} &
  (t_1{:}\hyperref[text/types:text-functype]{\mathtt{param}})^\ast~~(t_2{:}\hyperref[text/types:text-functype]{\mathtt{result}})^\ast &\equiv&
  \def\mathdef2867#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2867{(}~\def\mathdef2868#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2868{type}~~x~\def\mathdef2869#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2869{)}~~\hyperref[text/types:text-functype]{\mathtt{param}}^\ast~~\hyperref[text/types:text-functype]{\mathtt{result}}^\ast \\
\end{array}\end{split}
\end{equation*}
where \(x\) is the smallest existing {\hyperref[\detokenize{syntax/modules:syntax-typeidx}]{\sphinxcrossref{\DUrole{std,std-ref}{type index}}}} whose definition in the current module is the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).
If no such index exists, then a new {\hyperref[\detokenize{text/types:text-type}]{\sphinxcrossref{\DUrole{std,std-ref}{type definition}}}} of the form
\begin{equation*}
\begin{split}\def\mathdef2870#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2870{(}~\def\mathdef2871#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2871{type}~~\def\mathdef2872#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2872{(}~\def\mathdef2873#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2873{func}~~\hyperref[text/types:text-functype]{\mathtt{param}}^\ast~~\hyperref[text/types:text-functype]{\mathtt{result}}~\def\mathdef2874#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2874{)}~\def\mathdef2875#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2875{)}\end{split}
\end{equation*}
is inserted at the end of the module.

Abbreviations are expanded in the order they appear, such that previously inserted type definitions are reused by consecutive expansions.

\index{import}\index{name}\index{function type}\index{table type}\index{memory type}\index{global type}\index{text format!import}\index{import!text format}\ignorespaces \phantomsection\label{\detokenize{text/modules:text-importdesc}}

\subsection{Imports}
\label{\detokenize{text/modules:text-importdesc}}\label{\detokenize{text/modules:text-import}}\label{\detokenize{text/modules:index-3}}\label{\detokenize{text/modules:imports}}
The descriptors in imports can bind a symbolic function, table, memory, or global {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{identifier}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{import} & \hyperref[text/modules:text-import]{\mathtt{import}}_I &::=&
  \def\mathdef2876#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2876{(}~\def\mathdef2877#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2877{import}~~\mathit{mod}{:}\hyperref[text/values:text-name]{\mathtt{name}}~~\mathit{nm}{:}\hyperref[text/values:text-name]{\mathtt{name}}~~d{:}\hyperref[text/modules:text-importdesc]{\mathtt{importdesc}}_I~\def\mathdef2878#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2878{)} \\ &&& \qquad
    \Rightarrow\quad \{ \hyperref[syntax/modules:syntax-import]{\mathsf{module}}~\mathit{mod}, \hyperref[syntax/modules:syntax-import]{\mathsf{name}}~\mathit{nm}, \hyperref[syntax/modules:syntax-import]{\mathsf{desc}}~d \} \\[1ex]
\def\mathdef2796#1{{}}\mathdef2796{import description} & \hyperref[text/modules:text-importdesc]{\mathtt{importdesc}}_I &::=&
  \def\mathdef2879#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2879{(}~\def\mathdef2880#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2880{func}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~x,I'{:}\hyperref[text/modules:text-typeuse]{\mathtt{typeuse}}_I~\def\mathdef2881#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2881{)}
    &\Rightarrow& \hyperref[syntax/modules:syntax-importdesc]{\mathsf{func}}~x \\ &&|&
  \def\mathdef2882#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2882{(}~\def\mathdef2883#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2883{table}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\mathit{tt}{:}\hyperref[text/types:text-tabletype]{\mathtt{tabletype}}~\def\mathdef2884#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2884{)}
    &\Rightarrow& \hyperref[syntax/modules:syntax-importdesc]{\mathsf{table}}~\mathit{tt} \\ &&|&
  \def\mathdef2885#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2885{(}~\def\mathdef2886#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2886{memory}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\mathit{mt}{:}\hyperref[text/types:text-memtype]{\mathtt{memtype}}~\def\mathdef2887#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2887{)}
    &\Rightarrow& \hyperref[syntax/modules:syntax-importdesc]{\mathsf{mem}}~~\mathit{mt} \\ &&|&
  \def\mathdef2888#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2888{(}~\def\mathdef2889#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2889{global}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\mathit{gt}{:}\hyperref[text/types:text-globaltype]{\mathtt{globaltype}}~\def\mathdef2890#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2890{)}
    &\Rightarrow& \hyperref[syntax/modules:syntax-importdesc]{\mathsf{global}}~\mathit{gt} \\
\end{array}\end{split}
\end{equation*}

\subsubsection{Abbreviations}
\label{\detokenize{text/modules:id1}}
As an abbreviation, imports may also be specified inline with {\hyperref[\detokenize{text/modules:text-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}}, {\hyperref[\detokenize{text/modules:text-table}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}}, {\hyperref[\detokenize{text/modules:text-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memory}}}}, or {\hyperref[\detokenize{text/modules:text-global}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}} definitions; see the respective sections.

\index{function}\index{type index}\index{function type}\index{identifier}\index{local}\index{text format!function}\index{function!text format}\index{text format!local}\index{local!text format}\ignorespaces \phantomsection\label{\detokenize{text/modules:text-local}}

\subsection{Functions}
\label{\detokenize{text/modules:text-func}}\label{\detokenize{text/modules:functions}}\label{\detokenize{text/modules:text-local}}\label{\detokenize{text/modules:index-4}}
Function definitions can bind a symbolic {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{function identifier}}}}, and {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{local identifiers}}}} for its {\hyperref[\detokenize{text/modules:text-typeuse}]{\sphinxcrossref{\DUrole{std,std-ref}{parameters}}}} and locals.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{function} & \hyperref[text/modules:text-func]{\mathtt{func}}_I &::=&
  \def\mathdef2891#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2891{(}~\def\mathdef2892#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2892{func}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~x,I'{:}\hyperref[text/modules:text-typeuse]{\mathtt{typeuse}}_I~~
  (t{:}\hyperref[text/modules:text-local]{\mathtt{local}})^\ast~~(\mathit{in}{:}\hyperref[text/instructions:text-instr]{\mathtt{instr}}_{I''})^\ast~\def\mathdef2893#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2893{)} \\ &&& \qquad
    \Rightarrow\quad \{ \hyperref[syntax/modules:syntax-func]{\mathsf{type}}~x, \hyperref[syntax/modules:syntax-func]{\mathsf{locals}}~t^\ast, \hyperref[syntax/modules:syntax-func]{\mathsf{body}}~\mathit{in}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} \} \\ &&& \qquad\qquad\qquad
    (\mathrel{\mbox{if}} I'' = I' \hyperref[syntax/conventions:notation-compose]{\oplus} \{\hyperref[text/conventions:text-context]{\mathsf{locals}}~\mathrm{id}(\hyperref[text/modules:text-local]{\mathtt{local}})^\ast\} ~\hyperref[text/conventions:text-context-wf]{\mbox{well-formed}}) \\[1ex]
\def\mathdef2796#1{{}}\mathdef2796{local} & \hyperref[text/modules:text-local]{\mathtt{local}} &::=&
  \def\mathdef2894#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2894{(}~\def\mathdef2895#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2895{local}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~t{:}\hyperref[text/types:text-valtype]{\mathtt{valtype}}~\def\mathdef2896#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2896{)}
    \quad\Rightarrow\quad t \\
\end{array}\end{split}
\end{equation*}
The definition of the local {\hyperref[\detokenize{text/conventions:text-context}]{\sphinxcrossref{\DUrole{std,std-ref}{identifier context}}}} \(I''\) uses the following auxiliary function to extract optional identifiers from locals:
\begin{equation*}
\begin{split}\begin{array}{lcl@{\qquad\qquad}l}
\mathrm{id}(\def\mathdef2897#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2897{(}~\def\mathdef2898#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2898{local}~\hyperref[text/values:text-id]{\mathtt{id}}^?~\dots~\def\mathdef2899#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2899{)}) &=& \hyperref[text/values:text-id]{\mathtt{id}}^? \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The {\hyperref[\detokenize{text/conventions:text-context-wf}]{\sphinxcrossref{\DUrole{std,std-ref}{well-formedness}}}} condition on \(I''\) ensures that parameters and locals do not contain duplicate identifiers.
\end{sphinxadmonition}

\index{import}\index{name}\index{text format!import}\index{import!text format}\ignorespaces 
\index{export}\index{name}\index{index}\index{function index}\index{text format!export}\index{export!text format}\ignorespaces 

\subsubsection{Abbreviations}
\label{\detokenize{text/modules:id2}}\label{\detokenize{text/modules:index-6}}\label{\detokenize{text/modules:text-func-abbrev}}
Multiple anonymous locals may be combined into a single declaration:
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{local} &
  \def\mathdef2900#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2900{(}~~\def\mathdef2901#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2901{local}~~\hyperref[text/types:text-valtype]{\mathtt{valtype}}^\ast~~\def\mathdef2902#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2902{)} &\equiv&
  (\def\mathdef2903#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2903{(}~~\def\mathdef2904#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2904{local}~~\hyperref[text/types:text-valtype]{\mathtt{valtype}}~~\def\mathdef2905#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2905{)})^\ast \\
\end{array}\end{split}
\end{equation*}
Functions can be defined as {\hyperref[\detokenize{text/modules:text-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}} or {\hyperref[\detokenize{text/modules:text-export}]{\sphinxcrossref{\DUrole{std,std-ref}{exports}}}} inline:
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{module field} &
  \def\mathdef2906#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2906{(}~\def\mathdef2907#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2907{func}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\def\mathdef2908#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2908{(}~\def\mathdef2909#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2909{import}~~\hyperref[text/values:text-name]{\mathtt{name}}_1~~\hyperref[text/values:text-name]{\mathtt{name}}_2~\def\mathdef2910#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2910{)}~~\hyperref[text/modules:text-typeuse]{\mathtt{typeuse}}~\def\mathdef2911#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2911{)} \quad\equiv \\ & \qquad
    \def\mathdef2912#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2912{(}~\def\mathdef2913#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2913{import}~~\hyperref[text/values:text-name]{\mathtt{name}}_1~~\hyperref[text/values:text-name]{\mathtt{name}}_2~~\def\mathdef2914#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2914{(}~\def\mathdef2915#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2915{func}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\hyperref[text/modules:text-typeuse]{\mathtt{typeuse}}~\def\mathdef2916#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2916{)}~\def\mathdef2917#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2917{)} \\[1ex] &
  \def\mathdef2918#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2918{(}~\def\mathdef2919#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2919{func}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\def\mathdef2920#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2920{(}~\def\mathdef2921#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2921{export}~~\hyperref[text/values:text-name]{\mathtt{name}}~\def\mathdef2922#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2922{)}~~\dots~\def\mathdef2923#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2923{)} \quad\equiv \\ & \qquad
    \def\mathdef2924#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2924{(}~\def\mathdef2925#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2925{export}~~\hyperref[text/values:text-name]{\mathtt{name}}~~\def\mathdef2926#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2926{(}~\def\mathdef2927#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2927{func}~~\hyperref[text/values:text-id]{\mathtt{id}}'~\def\mathdef2928#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2928{)}~\def\mathdef2929#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2929{)}~~
    \def\mathdef2930#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2930{(}~\def\mathdef2931#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2931{func}~~\hyperref[text/values:text-id]{\mathtt{id}}'~~\dots~\def\mathdef2932#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2932{)}
    \\ & \qquad\qquad
    (\mathrel{\mbox{if}} \hyperref[text/values:text-id]{\mathtt{id}}' = \hyperref[text/values:text-id]{\mathtt{id}}^? \neq \epsilon \vee \hyperref[text/values:text-id]{\mathtt{id}}' ~\hyperref[text/values:text-id-fresh]{\mbox{fresh}}) \\
\end{array}\end{split}
\end{equation*}
The latter abbreviation can be applied repeatedly, with “\(\dots\)” containing another import or export.

\index{table}\index{table type}\index{identifier}\index{text format!table}\index{table!text format}\ignorespaces 

\subsection{Tables}
\label{\detokenize{text/modules:text-table}}\label{\detokenize{text/modules:index-7}}\label{\detokenize{text/modules:tables}}
Table definitions can bind a symbolic {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{table identifier}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{table} & \hyperref[text/modules:text-table]{\mathtt{table}}_I &::=&
  \def\mathdef2933#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2933{(}~\def\mathdef2934#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2934{table}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\mathit{tt}{:}\hyperref[text/types:text-tabletype]{\mathtt{tabletype}}~\def\mathdef2935#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2935{)}
    &\Rightarrow& \{ \hyperref[syntax/modules:syntax-table]{\mathsf{type}}~\mathit{tt} \} \\
\end{array}\end{split}
\end{equation*}
\index{import}\index{name}\index{text format!import}\index{import!text format}\ignorespaces 
\index{export}\index{name}\index{index}\index{table index}\index{text format!export}\index{export!text format}\ignorespaces 
\index{element}\index{table index}\index{function index}\index{text format!element}\index{element!text format}\index{table!element}\index{element!segment}\ignorespaces 

\subsubsection{Abbreviations}
\label{\detokenize{text/modules:text-table-abbrev}}\label{\detokenize{text/modules:index-10}}\label{\detokenize{text/modules:id3}}
An {\hyperref[\detokenize{text/modules:text-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{element segment}}}} can be given inline with a table definition, in which case its offset is \(0\) and the {\hyperref[\detokenize{text/types:text-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{limits}}}} of the {\hyperref[\detokenize{text/types:text-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table type}}}} are inferred from the length of the given segment:
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{module field} &
  \def\mathdef2936#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2936{(}~\def\mathdef2937#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2937{table}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\hyperref[text/types:text-elemtype]{\mathtt{elemtype}}~~\def\mathdef2938#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2938{(}~\def\mathdef2939#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2939{elem}~~x^n{:}\hyperref[text/conventions:text-vec]{\mathtt{vec}}(\hyperref[text/modules:text-funcidx]{\mathtt{funcidx}})~\def\mathdef2940#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2940{)}~~\def\mathdef2941#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2941{)} \quad\equiv \\ & \qquad
    \def\mathdef2942#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2942{(}~\def\mathdef2943#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2943{table}~~\hyperref[text/values:text-id]{\mathtt{id}}'~~n~~n~~\hyperref[text/types:text-elemtype]{\mathtt{elemtype}}~\def\mathdef2944#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2944{)}~~
    \def\mathdef2945#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2945{(}~\def\mathdef2946#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2946{elem}~~\hyperref[text/values:text-id]{\mathtt{id}}'~~\def\mathdef2947#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2947{(}~\def\mathdef2948#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2948{i32.const}~~\def\mathdef2949#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2949{0}~\def\mathdef2950#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2950{)}~~\hyperref[text/conventions:text-vec]{\mathtt{vec}}(\hyperref[text/modules:text-funcidx]{\mathtt{funcidx}})~\def\mathdef2951#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2951{)}
    \\ & \qquad\qquad
    (\mathrel{\mbox{if}} \hyperref[text/values:text-id]{\mathtt{id}}' = \hyperref[text/values:text-id]{\mathtt{id}}^? \neq \epsilon \vee \hyperref[text/values:text-id]{\mathtt{id}}' ~\hyperref[text/values:text-id-fresh]{\mbox{fresh}}) \\
\end{array}\end{split}
\end{equation*}
Tables can be defined as {\hyperref[\detokenize{text/modules:text-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}} or {\hyperref[\detokenize{text/modules:text-export}]{\sphinxcrossref{\DUrole{std,std-ref}{exports}}}} inline:
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{module field} &
  \def\mathdef2952#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2952{(}~\def\mathdef2953#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2953{table}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\def\mathdef2954#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2954{(}~\def\mathdef2955#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2955{import}~~\hyperref[text/values:text-name]{\mathtt{name}}_1~~\hyperref[text/values:text-name]{\mathtt{name}}_2~\def\mathdef2956#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2956{)}~~\hyperref[text/types:text-tabletype]{\mathtt{tabletype}}~\def\mathdef2957#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2957{)} \quad\equiv \\ & \qquad
    \def\mathdef2958#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2958{(}~\def\mathdef2959#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2959{import}~~\hyperref[text/values:text-name]{\mathtt{name}}_1~~\hyperref[text/values:text-name]{\mathtt{name}}_2~~\def\mathdef2960#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2960{(}~\def\mathdef2961#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2961{table}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\hyperref[text/types:text-tabletype]{\mathtt{tabletype}}~\def\mathdef2962#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2962{)}~\def\mathdef2963#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2963{)} \\[1ex] &
  \def\mathdef2964#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2964{(}~\def\mathdef2965#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2965{table}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\def\mathdef2966#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2966{(}~\def\mathdef2967#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2967{export}~~\hyperref[text/values:text-name]{\mathtt{name}}~\def\mathdef2968#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2968{)}~~\dots~\def\mathdef2969#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2969{)} \quad\equiv \\ & \qquad
    \def\mathdef2970#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2970{(}~\def\mathdef2971#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2971{export}~~\hyperref[text/values:text-name]{\mathtt{name}}~~\def\mathdef2972#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2972{(}~\def\mathdef2973#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2973{table}~~\hyperref[text/values:text-id]{\mathtt{id}}'~\def\mathdef2974#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2974{)}~\def\mathdef2975#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2975{)}~~
    \def\mathdef2976#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2976{(}~\def\mathdef2977#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2977{table}~~\hyperref[text/values:text-id]{\mathtt{id}}'~~\dots~\def\mathdef2978#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2978{)}
    \\ & \qquad\qquad
    (\mathrel{\mbox{if}} \hyperref[text/values:text-id]{\mathtt{id}}' = \hyperref[text/values:text-id]{\mathtt{id}}^? \neq \epsilon \vee \hyperref[text/values:text-id]{\mathtt{id}}' ~\hyperref[text/values:text-id-fresh]{\mbox{fresh}}) \\
\end{array}\end{split}
\end{equation*}
The latter abbreviation can be applied repeatedly, with “\(\dots\)” containing another import or export or an inline elements segment.

\index{memory}\index{memory type}\index{identifier}\index{text format!memory}\index{memory!text format}\ignorespaces 

\subsection{Memories}
\label{\detokenize{text/modules:text-mem}}\label{\detokenize{text/modules:index-11}}\label{\detokenize{text/modules:memories}}
Memory definitions can bind a symbolic {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{memory identifier}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{memory} & \hyperref[text/modules:text-mem]{\mathtt{mem}}_I &::=&
  \def\mathdef2979#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2979{(}~\def\mathdef2980#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2980{memory}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\mathit{mt}{:}\hyperref[text/types:text-memtype]{\mathtt{memtype}}~\def\mathdef2981#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2981{)}
    &\Rightarrow& \{ \hyperref[syntax/modules:syntax-mem]{\mathsf{type}}~\mathit{mt} \} \\
\end{array}\end{split}
\end{equation*}
\index{import}\index{name}\index{text format!import}\index{import!text format}\ignorespaces 
\index{export}\index{name}\index{index}\index{memory index}\index{text format!export}\index{export!text format}\ignorespaces 
\index{data}\index{memory}\index{memory index}\index{expression}\index{byte}\index{page size}\index{text format!data}\index{data!text format}\index{memory!data}\index{data!segment}\ignorespaces 

\subsubsection{Abbreviations}
\label{\detokenize{text/modules:text-mem-abbrev}}\label{\detokenize{text/modules:id4}}\label{\detokenize{text/modules:index-14}}
A {\hyperref[\detokenize{text/modules:text-data}]{\sphinxcrossref{\DUrole{std,std-ref}{data segment}}}} can be given inline with a memory definition, in which case its offset is \(0\) the {\hyperref[\detokenize{text/types:text-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{limits}}}} of the {\hyperref[\detokenize{text/types:text-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory type}}}} are inferred from the length of the data, rounded up to {\hyperref[\detokenize{exec/runtime:page-size}]{\sphinxcrossref{\DUrole{std,std-ref}{page size}}}}:
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{module field} &
  \def\mathdef2982#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2982{(}~\def\mathdef2983#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2983{memory}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\def\mathdef2984#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2984{(}~\def\mathdef2985#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2985{data}~~b^n{:}\hyperref[text/modules:text-datastring]{\mathtt{datastring}}~\def\mathdef2986#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2986{)}~~\def\mathdef2987#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2987{)} \quad\equiv \\ & \qquad
    \def\mathdef2988#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2988{(}~\def\mathdef2989#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2989{memory}~~\hyperref[text/values:text-id]{\mathtt{id}}'~~m~~m~\def\mathdef2990#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2990{)}~~
    \def\mathdef2991#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2991{(}~\def\mathdef2992#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2992{data}~~\hyperref[text/values:text-id]{\mathtt{id}}'~~\def\mathdef2993#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2993{(}~\def\mathdef2994#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2994{i32.const}~~\def\mathdef2995#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2995{0}~\def\mathdef2996#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2996{)}~~\hyperref[text/modules:text-datastring]{\mathtt{datastring}}~\def\mathdef2997#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2997{)}
    \\ & \qquad\qquad
    (\mathrel{\mbox{if}} \hyperref[text/values:text-id]{\mathtt{id}}' = \hyperref[text/values:text-id]{\mathtt{id}}^? \neq \epsilon \vee \hyperref[text/values:text-id]{\mathtt{id}}' ~\hyperref[text/values:text-id-fresh]{\mbox{fresh}}, m = \mathrm{ceil}(n / 64\mathrm{Ki})) \\
\end{array}\end{split}
\end{equation*}
Memories can be defined as {\hyperref[\detokenize{text/modules:text-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}} or {\hyperref[\detokenize{text/modules:text-export}]{\sphinxcrossref{\DUrole{std,std-ref}{exports}}}} inline:
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{module field} &
  \def\mathdef2998#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2998{(}~\def\mathdef2999#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef2999{memory}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\def\mathdef3000#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3000{(}~\def\mathdef3001#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3001{import}~~\hyperref[text/values:text-name]{\mathtt{name}}_1~~\hyperref[text/values:text-name]{\mathtt{name}}_2~\def\mathdef3002#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3002{)}~~\hyperref[text/types:text-memtype]{\mathtt{memtype}}~\def\mathdef3003#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3003{)} \quad\equiv \\ & \qquad
    \def\mathdef3004#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3004{(}~\def\mathdef3005#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3005{import}~~\hyperref[text/values:text-name]{\mathtt{name}}_1~~\hyperref[text/values:text-name]{\mathtt{name}}_2~~\def\mathdef3006#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3006{(}~\def\mathdef3007#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3007{memory}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\hyperref[text/types:text-memtype]{\mathtt{memtype}}~\def\mathdef3008#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3008{)}~\def\mathdef3009#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3009{)}
    \\[1ex] &
  \def\mathdef3010#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3010{(}~\def\mathdef3011#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3011{memory}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\def\mathdef3012#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3012{(}~\def\mathdef3013#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3013{export}~~\hyperref[text/values:text-name]{\mathtt{name}}~\def\mathdef3014#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3014{)}~~\dots~\def\mathdef3015#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3015{)} \quad\equiv \\ & \qquad
    \def\mathdef3016#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3016{(}~\def\mathdef3017#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3017{export}~~\hyperref[text/values:text-name]{\mathtt{name}}~~\def\mathdef3018#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3018{(}~\def\mathdef3019#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3019{memory}~~\hyperref[text/values:text-id]{\mathtt{id}}'~\def\mathdef3020#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3020{)}~\def\mathdef3021#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3021{)}~~
    \def\mathdef3022#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3022{(}~\def\mathdef3023#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3023{memory}~~\hyperref[text/values:text-id]{\mathtt{id}}'~~\dots~\def\mathdef3024#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3024{)}
    \\ & \qquad\qquad
    (\mathrel{\mbox{if}} \hyperref[text/values:text-id]{\mathtt{id}}' = \hyperref[text/values:text-id]{\mathtt{id}}^? \neq \epsilon \vee \hyperref[text/values:text-id]{\mathtt{id}}' ~\hyperref[text/values:text-id-fresh]{\mbox{fresh}}) \\
\end{array}\end{split}
\end{equation*}
The latter abbreviation can be applied repeatedly, with “\(\dots\)” containing another import or export or an inline data segment.

\index{global}\index{global type}\index{identifier}\index{expression}\index{text format!global}\index{global!text format}\ignorespaces 

\subsection{Globals}
\label{\detokenize{text/modules:globals}}\label{\detokenize{text/modules:index-15}}\label{\detokenize{text/modules:text-global}}
Global definitions can bind a symbolic {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{global identifier}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{global} & \hyperref[text/modules:text-global]{\mathtt{global}}_I &::=&
  \def\mathdef3025#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3025{(}~\def\mathdef3026#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3026{global}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\mathit{gt}{:}\hyperref[text/types:text-globaltype]{\mathtt{globaltype}}~~e{:}\hyperref[text/instructions:text-expr]{\mathtt{expr}}_I~\def\mathdef3027#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3027{)}
    &\Rightarrow& \{ \hyperref[syntax/modules:syntax-global]{\mathsf{type}}~\mathit{gt}, \hyperref[syntax/modules:syntax-global]{\mathsf{init}}~e \} \\
\end{array}\end{split}
\end{equation*}
\index{import}\index{name}\index{text format!import}\index{import!text format}\ignorespaces 
\index{export}\index{name}\index{index}\index{global index}\index{text format!export}\index{export!text format}\ignorespaces 

\subsubsection{Abbreviations}
\label{\detokenize{text/modules:text-global-abbrev}}\label{\detokenize{text/modules:id5}}\label{\detokenize{text/modules:index-17}}
Globals can be defined as {\hyperref[\detokenize{text/modules:text-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}} or {\hyperref[\detokenize{text/modules:text-export}]{\sphinxcrossref{\DUrole{std,std-ref}{exports}}}} inline:
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{module field} &
  \def\mathdef3028#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3028{(}~\def\mathdef3029#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3029{global}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\def\mathdef3030#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3030{(}~\def\mathdef3031#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3031{import}~~\hyperref[text/values:text-name]{\mathtt{name}}_1~~\hyperref[text/values:text-name]{\mathtt{name}}_2~\def\mathdef3032#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3032{)}~~\hyperref[text/types:text-globaltype]{\mathtt{globaltype}}~\def\mathdef3033#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3033{)} \quad\equiv \\ & \qquad
    \def\mathdef3034#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3034{(}~\def\mathdef3035#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3035{import}~~\hyperref[text/values:text-name]{\mathtt{name}}_1~~\hyperref[text/values:text-name]{\mathtt{name}}_2~~\def\mathdef3036#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3036{(}~\def\mathdef3037#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3037{global}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\hyperref[text/types:text-globaltype]{\mathtt{globaltype}}~\def\mathdef3038#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3038{)}~\def\mathdef3039#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3039{)}
    \\[1ex] &
  \def\mathdef3040#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3040{(}~\def\mathdef3041#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3041{global}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~\def\mathdef3042#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3042{(}~\def\mathdef3043#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3043{export}~~\hyperref[text/values:text-name]{\mathtt{name}}~\def\mathdef3044#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3044{)}~~\dots~\def\mathdef3045#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3045{)} \quad\equiv \\ & \qquad
    \def\mathdef3046#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3046{(}~\def\mathdef3047#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3047{export}~~\hyperref[text/values:text-name]{\mathtt{name}}~~\def\mathdef3048#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3048{(}~\def\mathdef3049#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3049{global}~~\hyperref[text/values:text-id]{\mathtt{id}}'~\def\mathdef3050#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3050{)}~\def\mathdef3051#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3051{)}~~
    \def\mathdef3052#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3052{(}~\def\mathdef3053#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3053{global}~~\hyperref[text/values:text-id]{\mathtt{id}}'~~\dots~\def\mathdef3054#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3054{)}
    \\ & \qquad\qquad
    (\mathrel{\mbox{if}} \hyperref[text/values:text-id]{\mathtt{id}}' = \hyperref[text/values:text-id]{\mathtt{id}}^? \neq \epsilon \vee \hyperref[text/values:text-id]{\mathtt{id}}' ~\hyperref[text/values:text-id-fresh]{\mbox{fresh}}) \\
\end{array}\end{split}
\end{equation*}
The latter abbreviation can be applied repeatedly, with “\(\dots\)” containing another import or export.

\index{export}\index{name}\index{index}\index{function index}\index{table index}\index{memory index}\index{global index}\index{text format!export}\index{export!text format}\ignorespaces \phantomsection\label{\detokenize{text/modules:text-exportdesc}}

\subsection{Exports}
\label{\detokenize{text/modules:exports}}\label{\detokenize{text/modules:text-exportdesc}}\label{\detokenize{text/modules:text-export}}\label{\detokenize{text/modules:index-18}}
The syntax for exports mirrors their {\hyperref[\detokenize{syntax/modules:syntax-export}]{\sphinxcrossref{\DUrole{std,std-ref}{abstract syntax}}}} directly.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{export} & \hyperref[text/modules:text-export]{\mathtt{export}}_I &::=&
  \def\mathdef3055#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3055{(}~\def\mathdef3056#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3056{export}~~\mathit{nm}{:}\hyperref[text/values:text-name]{\mathtt{name}}~~d{:}\hyperref[text/modules:text-exportdesc]{\mathtt{exportdesc}}_I~\def\mathdef3057#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3057{)}
    &\Rightarrow& \{ \hyperref[syntax/modules:syntax-export]{\mathsf{name}}~\mathit{nm}, \hyperref[syntax/modules:syntax-export]{\mathsf{desc}}~d \} \\
\def\mathdef2796#1{{}}\mathdef2796{export description} & \hyperref[text/modules:text-exportdesc]{\mathtt{exportdesc}}_I &::=&
  \def\mathdef3058#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3058{(}~\def\mathdef3059#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3059{func}~~x{:}\hyperref[binary/modules:binary-funcidx]{\mathtt{funcidx}}_I~\def\mathdef3060#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3060{)}
    &\Rightarrow& \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{func}}~x \\ &&|&
  \def\mathdef3061#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3061{(}~\def\mathdef3062#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3062{table}~~x{:}\hyperref[binary/modules:binary-tableidx]{\mathtt{tableidx}}_I~\def\mathdef3063#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3063{)}
    &\Rightarrow& \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{table}}~x \\ &&|&
  \def\mathdef3064#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3064{(}~\def\mathdef3065#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3065{memory}~~x{:}\hyperref[binary/modules:binary-memidx]{\mathtt{memidx}}_I~\def\mathdef3066#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3066{)}
    &\Rightarrow& \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{mem}}~x \\ &&|&
  \def\mathdef3067#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3067{(}~\def\mathdef3068#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3068{global}~~x{:}\hyperref[binary/modules:binary-globalidx]{\mathtt{globalidx}}_I~\def\mathdef3069#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3069{)}
    &\Rightarrow& \hyperref[syntax/modules:syntax-exportdesc]{\mathsf{global}}~x \\
\end{array}\end{split}
\end{equation*}

\subsubsection{Abbreviations}
\label{\detokenize{text/modules:id6}}
As an abbreviation, exports may also be specified inline with {\hyperref[\detokenize{text/modules:text-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}}, {\hyperref[\detokenize{text/modules:text-table}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}}, {\hyperref[\detokenize{text/modules:text-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memory}}}}, or {\hyperref[\detokenize{text/modules:text-global}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}} definitions; see the respective sections.

\index{start function}\index{function index}\index{text format!start function}\index{start function!text format}\ignorespaces 

\subsection{Start Function}
\label{\detokenize{text/modules:start-function}}\label{\detokenize{text/modules:text-start}}\label{\detokenize{text/modules:index-19}}
A {\hyperref[\detokenize{syntax/modules:syntax-start}]{\sphinxcrossref{\DUrole{std,std-ref}{start function}}}} is defined in terms of its index.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{start function} & \hyperref[text/modules:text-start]{\mathtt{start}}_I &::=&
  \def\mathdef3070#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3070{(}~\def\mathdef3071#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3071{start}~~x{:}\hyperref[text/modules:text-funcidx]{\mathtt{funcidx}}_I~\def\mathdef3072#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3072{)}
    &\Rightarrow& \{ \hyperref[syntax/modules:syntax-start]{\mathsf{func}}~x \} \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
At most one start function may occur in a module,
which is ensured by a suitable side condition on the \(\hyperref[text/modules:text-module]{\mathtt{module}}\) grammar.
\end{sphinxadmonition}

\index{element}\index{table index}\index{expression}\index{function index}\index{text format!element}\index{element!text format}\index{table!element}\index{element!segment}\ignorespaces 

\subsection{Element Segments}
\label{\detokenize{text/modules:element-segments}}\label{\detokenize{text/modules:text-elem}}\label{\detokenize{text/modules:index-20}}
Element segments allow for an optional {\hyperref[\detokenize{text/modules:text-tableidx}]{\sphinxcrossref{\DUrole{std,std-ref}{table index}}}} to identify the table to initialize.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{element segment} & \hyperref[text/modules:text-elem]{\mathtt{elem}}_I &::=&
  \def\mathdef3073#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3073{(}~\def\mathdef3074#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3074{elem}~~x{:}\hyperref[text/modules:text-tableidx]{\mathtt{tableidx}}_I~~\def\mathdef3075#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3075{(}~\def\mathdef3076#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3076{offset}~~e{:}\hyperref[text/instructions:text-expr]{\mathtt{expr}}_I~\def\mathdef3077#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3077{)}~~y^\ast{:}\hyperref[text/conventions:text-vec]{\mathtt{vec}}(\hyperref[text/modules:text-funcidx]{\mathtt{funcidx}}_I)~\def\mathdef3078#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3078{)} \\ &&& \qquad
    \Rightarrow\quad \{ \hyperref[syntax/modules:syntax-elem]{\mathsf{table}}~x, \hyperref[syntax/modules:syntax-elem]{\mathsf{offset}}~e, \hyperref[syntax/modules:syntax-elem]{\mathsf{init}}~y^\ast \} \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
In the current version of WebAssembly, the only valid table index is 0
or a symbolic {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{table identifier}}}} resolving to the same value.
\end{sphinxadmonition}


\subsubsection{Abbreviations}
\label{\detokenize{text/modules:id7}}
As an abbreviation, a single instruction may occur in place of the offset:
\begin{equation*}
\begin{split}\begin{array}{llcll}
\def\mathdef2796#1{{}}\mathdef2796{element offset} &
  \hyperref[text/instructions:text-instr]{\mathtt{instr}} &\equiv&
  \def\mathdef3079#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3079{(}~\def\mathdef3080#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3080{offset}~~\hyperref[text/instructions:text-instr]{\mathtt{instr}}~\def\mathdef3081#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3081{)}
\end{array}\end{split}
\end{equation*}
Also, the table index can be omitted, defaulting to \(\mathtt{0}\).
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{element segment} &
 \def\mathdef3082#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3082{(}~\def\mathdef3083#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3083{elem}~~\def\mathdef3084#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3084{(}~\def\mathdef3085#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3085{offset}~~\hyperref[text/instructions:text-expr]{\mathtt{expr}}_I~\def\mathdef3086#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3086{)}~~\dots~\def\mathdef3087#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3087{)}
    &\equiv&
  \def\mathdef3088#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3088{(}~\def\mathdef3089#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3089{elem}~~0~~\def\mathdef3090#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3090{(}~\def\mathdef3091#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3091{offset}~~\hyperref[text/instructions:text-expr]{\mathtt{expr}}_I~\def\mathdef3092#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3092{)}~~\dots~\def\mathdef3093#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3093{)}
\end{array}\end{split}
\end{equation*}
As another abbreviation, element segments may also be specified inline with {\hyperref[\detokenize{text/modules:text-table}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}} definitions; see the respective section.

\index{data}\index{memory}\index{memory index}\index{expression}\index{byte}\index{text format!data}\index{data!text format}\index{memory!data}\index{data!segment}\ignorespaces \phantomsection\label{\detokenize{text/modules:text-datastring}}

\subsection{Data Segments}
\label{\detokenize{text/modules:index-21}}\label{\detokenize{text/modules:text-datastring}}\label{\detokenize{text/modules:text-data}}\label{\detokenize{text/modules:data-segments}}
Data segments allow for an optional {\hyperref[\detokenize{text/modules:text-memidx}]{\sphinxcrossref{\DUrole{std,std-ref}{memory index}}}} to identify the memory to initialize.
The data is written as a {\hyperref[\detokenize{text/values:text-string}]{\sphinxcrossref{\DUrole{std,std-ref}{string}}}}, which may be split up into a possibly empty sequence of individual string literals.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{data segment} & \hyperref[text/modules:text-data]{\mathtt{data}}_I &::=&
  \def\mathdef3094#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3094{(}~\def\mathdef3095#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3095{data}~~x{:}\hyperref[text/modules:text-memidx]{\mathtt{memidx}}_I~~\def\mathdef3096#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3096{(}~\def\mathdef3097#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3097{offset}~~e{:}\hyperref[text/instructions:text-expr]{\mathtt{expr}}_I~\def\mathdef3098#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3098{)}~~b^\ast{:}\hyperref[text/modules:text-datastring]{\mathtt{datastring}}~\def\mathdef3099#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3099{)} \\ &&& \qquad
    \Rightarrow\quad \{ \hyperref[syntax/modules:syntax-data]{\mathsf{data}}~x', \hyperref[syntax/modules:syntax-data]{\mathsf{offset}}~e, \hyperref[syntax/modules:syntax-data]{\mathsf{init}}~b^\ast \} \\[1ex]
\def\mathdef2796#1{{}}\mathdef2796{data string} & \hyperref[text/modules:text-datastring]{\mathtt{datastring}} &::=&
  (b^\ast{:}\hyperref[text/values:text-string]{\mathtt{string}})^\ast \quad\Rightarrow\quad \hyperref[syntax/conventions:notation-concat]{\mathrm{concat}}((b^\ast)^\ast) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
In the current version of WebAssembly, the only valid memory index is 0
or a symbolic {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{memory identifier}}}} resolving to the same value.
\end{sphinxadmonition}


\subsubsection{Abbreviations}
\label{\detokenize{text/modules:id8}}
As an abbreviation, a single instruction may occur in place of the offset:
\begin{equation*}
\begin{split}\begin{array}{llcll}
\def\mathdef2796#1{{}}\mathdef2796{data offset} &
  \hyperref[text/instructions:text-instr]{\mathtt{instr}} &\equiv&
  \def\mathdef3100#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3100{(}~\def\mathdef3101#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3101{offset}~~\hyperref[text/instructions:text-instr]{\mathtt{instr}}~\def\mathdef3102#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3102{)}
\end{array}\end{split}
\end{equation*}
Also, the memory index can be omitted, defaulting to \(\mathtt{0}\).
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef2796#1{{}}\mathdef2796{data segment} &
 \def\mathdef3103#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3103{(}~\def\mathdef3104#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3104{data}~~\def\mathdef3105#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3105{(}~\def\mathdef3106#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3106{offset}~~\hyperref[text/instructions:text-expr]{\mathtt{expr}}_I~\def\mathdef3107#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3107{)}~~\dots~\def\mathdef3108#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3108{)}
    &\equiv&
  \def\mathdef3109#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3109{(}~\def\mathdef3110#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3110{data}~~0~~\def\mathdef3111#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3111{(}~\def\mathdef3112#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3112{offset}~~\hyperref[text/instructions:text-expr]{\mathtt{expr}}_I~\def\mathdef3113#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3113{)}~~\dots~\def\mathdef3114#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3114{)}
\end{array}\end{split}
\end{equation*}
As another abbreviation, data segments may also be specified inline with {\hyperref[\detokenize{text/modules:text-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memory}}}} definitions; see the respective section.

\index{module}\index{type definition}\index{function type}\index{function}\index{table}\index{memory}\index{global}\index{element}\index{data}\index{start function}\index{import}\index{export}\index{identifier context}\index{identifier}\index{name section}\index{text format!module}\index{module!text format}\index{section!name}\ignorespaces \phantomsection\label{\detokenize{text/modules:text-modulefield}}

\subsection{Modules}
\label{\detokenize{text/modules:index-22}}\label{\detokenize{text/modules:text-modulefield}}\label{\detokenize{text/modules:text-module}}\label{\detokenize{text/modules:id9}}
A module consists of a sequence of fields that can occur in any order.
All definitions and their respective bound {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{identifiers}}}} scope over the entire module, including the text preceding them.

A module may optionally bind an {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{identifier}}}} that names the module.
The name serves a documentary role only.

\begin{sphinxadmonition}{note}{Note:}
Tools may include the module name in the {\hyperref[\detokenize{appendix/custom:binary-namesec}]{\sphinxcrossref{\DUrole{std,std-ref}{name section}}}} of the {\hyperref[\detokenize{binary/index:binary}]{\sphinxcrossref{\DUrole{std,std-ref}{binary format}}}}.
\end{sphinxadmonition}
\begin{equation*}
\begin{split}\begin{array}{lll}
\def\mathdef2796#1{{}}\mathdef2796{module} & \hyperref[text/modules:text-module]{\mathtt{module}} &
\begin{array}[t]{@{}cllll}
::=&
  \def\mathdef3115#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3115{(}~\def\mathdef3116#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3116{module}~~\hyperref[text/values:text-id]{\mathtt{id}}^?~~(m{:}\hyperref[text/modules:text-modulefield]{\mathtt{modulefield}}_I)^\ast~\def\mathdef3117#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3117{)}
    \quad\Rightarrow\quad \hyperref[syntax/conventions:notation-compose]{\bigoplus} m^\ast \\
    &\qquad (\mathrel{\mbox{if}} I = \hyperref[syntax/conventions:notation-compose]{\bigoplus} \mathrm{idc}(\hyperref[text/modules:text-modulefield]{\mathtt{modulefield}})^\ast ~\hyperref[text/conventions:text-context-wf]{\mbox{well-formed}}) \\
\end{array} \\[1ex]
\def\mathdef2796#1{{}}\mathdef2796{module field} & \hyperref[text/modules:text-modulefield]{\mathtt{modulefield}}_I &
\begin{array}[t]{@{}clll}
::=&
  \mathit{ty}{:}\hyperref[text/modules:text-typedef]{\mathtt{type}} &\Rightarrow& \{\hyperref[syntax/modules:syntax-module]{\mathsf{types}}~\mathit{ty}\} \\ |&
  \mathit{im}{:}\hyperref[text/modules:text-import]{\mathtt{import}}_I &\Rightarrow& \{\hyperref[syntax/modules:syntax-module]{\mathsf{imports}}~\mathit{im}\} \\ |&
  \mathit{fn}{:}\hyperref[text/modules:text-func]{\mathtt{func}}_I &\Rightarrow& \{\hyperref[syntax/modules:syntax-module]{\mathsf{funcs}}~\mathit{fn}\} \\ |&
  \mathit{ta}{:}\hyperref[text/modules:text-table]{\mathtt{table}}_I &\Rightarrow& \{\hyperref[syntax/modules:syntax-module]{\mathsf{tables}}~\mathit{ta}\} \\ |&
  \mathit{me}{:}\hyperref[text/modules:text-mem]{\mathtt{mem}}_I &\Rightarrow& \{\hyperref[syntax/modules:syntax-module]{\mathsf{mems}}~\mathit{me}\} \\ |&
  \mathit{gl}{:}\hyperref[text/modules:text-global]{\mathtt{global}}_I &\Rightarrow& \{\hyperref[syntax/modules:syntax-module]{\mathsf{globals}}~\mathit{gl}\} \\ |&
  \mathit{ex}{:}\hyperref[text/modules:text-export]{\mathtt{export}}_I &\Rightarrow& \{\hyperref[syntax/modules:syntax-module]{\mathsf{exports}}~\mathit{ex}\} \\ |&
  \mathit{st}{:}\hyperref[text/modules:text-start]{\mathtt{start}}_I &\Rightarrow& \{\hyperref[syntax/modules:syntax-module]{\mathsf{start}}~\mathit{st}\} \\ |&
  \mathit{el}{:}\hyperref[text/modules:text-elem]{\mathtt{elem}}_I &\Rightarrow& \{\hyperref[syntax/modules:syntax-module]{\mathsf{elem}}~\mathit{el}\} \\ |&
  \mathit{da}{:}\hyperref[text/modules:text-data]{\mathtt{data}}_I &\Rightarrow& \{\hyperref[syntax/modules:syntax-module]{\mathsf{data}}~\mathit{da}\} \\
\end{array}
\end{array}\end{split}
\end{equation*}
The following restrictions are imposed on the composition of {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{modules}}}}: \(m_1 \hyperref[syntax/conventions:notation-compose]{\oplus} m_2\) is defined if and only if
\begin{itemize}
\item {} 
\(m_1.\hyperref[syntax/modules:syntax-module]{\mathsf{start}} = \epsilon \vee m_2.\hyperref[syntax/modules:syntax-module]{\mathsf{start}} = \epsilon\)

\item {} 
\(m_1.\hyperref[syntax/modules:syntax-module]{\mathsf{funcs}} = m_1.\hyperref[syntax/modules:syntax-module]{\mathsf{tables}} = m_1.\hyperref[syntax/modules:syntax-module]{\mathsf{mems}} = m_1.\hyperref[syntax/modules:syntax-module]{\mathsf{globals}} = \epsilon \vee m_2.\hyperref[syntax/modules:syntax-module]{\mathsf{imports}} = \epsilon\)

\end{itemize}

\begin{sphinxadmonition}{note}{Note:}
The first condition ensures that there is at most one start function.
The second condition enforces that all {\hyperref[\detokenize{text/modules:text-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}} must occur before any regular definition of a {\hyperref[\detokenize{text/modules:text-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}}, {\hyperref[\detokenize{text/modules:text-table}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}}, {\hyperref[\detokenize{text/modules:text-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memory}}}}, or {\hyperref[\detokenize{text/modules:text-global}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}},
thereby maintaining the ordering of the respective {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{index spaces}}}}.

The {\hyperref[\detokenize{text/conventions:text-context-wf}]{\sphinxcrossref{\DUrole{std,std-ref}{well-formedness}}}} condition on \(I\) in the grammar for \(\hyperref[text/modules:text-module]{\mathtt{module}}\) ensures that no namespace contains duplicate identifiers.
\end{sphinxadmonition}

The definition of the initial {\hyperref[\detokenize{text/conventions:text-context}]{\sphinxcrossref{\DUrole{std,std-ref}{identifier context}}}} \(I\) uses the following auxiliary definition which maps each relevant definition to a singular context with one (possibly empty) identifier:
\begin{equation*}
\begin{split}\begin{array}{@{}lcl@{\qquad\qquad}l}
\mathrm{idc}(\def\mathdef3118#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3118{(}~\def\mathdef3119#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3119{type}~\hyperref[text/values:text-id]{\mathtt{id}}^?~\mathit{ft}{:}\hyperref[text/types:text-functype]{\mathtt{functype}}~\def\mathdef3120#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3120{)}) &=&
  \{\hyperref[text/conventions:text-context]{\mathsf{types}}~(\hyperref[text/values:text-id]{\mathtt{id}}^?), \hyperref[text/conventions:text-context]{\mathsf{typedefs}}~\mathit{ft}\} \\
\mathrm{idc}(\def\mathdef3121#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3121{(}~\def\mathdef3122#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3122{func}~\hyperref[text/values:text-id]{\mathtt{id}}^?~\dots~\def\mathdef3123#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3123{)}) &=&
  \{\hyperref[text/conventions:text-context]{\mathsf{funcs}}~(\hyperref[text/values:text-id]{\mathtt{id}}^?)\} \\
\mathrm{idc}(\def\mathdef3124#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3124{(}~\def\mathdef3125#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3125{table}~\hyperref[text/values:text-id]{\mathtt{id}}^?~\dots~\def\mathdef3126#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3126{)}) &=&
  \{\hyperref[text/conventions:text-context]{\mathsf{tables}}~(\hyperref[text/values:text-id]{\mathtt{id}}^?)\} \\
\mathrm{idc}(\def\mathdef3127#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3127{(}~\def\mathdef3128#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3128{memory}~\hyperref[text/values:text-id]{\mathtt{id}}^?~\dots~\def\mathdef3129#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3129{)}) &=&
  \{\hyperref[text/conventions:text-context]{\mathsf{mems}}~(\hyperref[text/values:text-id]{\mathtt{id}}^?)\} \\
\mathrm{idc}(\def\mathdef3130#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3130{(}~\def\mathdef3131#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3131{global}~\hyperref[text/values:text-id]{\mathtt{id}}^?~\dots~\def\mathdef3132#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3132{)}) &=&
  \{\hyperref[text/conventions:text-context]{\mathsf{globals}}~(\hyperref[text/values:text-id]{\mathtt{id}}^?)\} \\
\mathrm{idc}(\def\mathdef3133#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3133{(}~\def\mathdef3134#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3134{import}~\dots~\def\mathdef3135#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3135{(}~\def\mathdef3136#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3136{func}~\hyperref[text/values:text-id]{\mathtt{id}}^?~\dots~\def\mathdef3137#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3137{)}~\def\mathdef3138#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3138{)}) &=&
  \{\hyperref[text/conventions:text-context]{\mathsf{funcs}}~(\hyperref[text/values:text-id]{\mathtt{id}}^?)\} \\
\mathrm{idc}(\def\mathdef3139#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3139{(}~\def\mathdef3140#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3140{import}~\dots~\def\mathdef3141#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3141{(}~\def\mathdef3142#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3142{table}~\hyperref[text/values:text-id]{\mathtt{id}}^?~\dots~\def\mathdef3143#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3143{)}~\def\mathdef3144#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3144{)}) &=&
  \{\hyperref[text/conventions:text-context]{\mathsf{tables}}~(\hyperref[text/values:text-id]{\mathtt{id}}^?)\} \\
\mathrm{idc}(\def\mathdef3145#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3145{(}~\def\mathdef3146#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3146{import}~\dots~\def\mathdef3147#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3147{(}~\def\mathdef3148#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3148{memory}~\hyperref[text/values:text-id]{\mathtt{id}}^?~\dots~\def\mathdef3149#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3149{)}~\def\mathdef3150#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3150{)}) &=&
  \{\hyperref[text/conventions:text-context]{\mathsf{mems}}~(\hyperref[text/values:text-id]{\mathtt{id}}^?)\} \\
\mathrm{idc}(\def\mathdef3151#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3151{(}~\def\mathdef3152#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3152{import}~\dots~\def\mathdef3153#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3153{(}~\def\mathdef3154#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3154{global}~\hyperref[text/values:text-id]{\mathtt{id}}^?~\dots~\def\mathdef3155#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3155{)}~\def\mathdef3156#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3156{)}) &=&
  \{\hyperref[text/conventions:text-context]{\mathsf{globals}}~(\hyperref[text/values:text-id]{\mathtt{id}}^?)\} \\
\mathrm{idc}(\def\mathdef3157#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3157{(}~\dots~\def\mathdef3158#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3158{)}) &=&
  \{\} \\
\end{array}\end{split}
\end{equation*}

\subsubsection{Abbreviations}
\label{\detokenize{text/modules:id10}}
In a source file, the toplevel \(\mathtt{(module}~\dots\mathtt{)}\) surrounding the module body may be omitted.
\begin{equation*}
\begin{split}\begin{array}{llcll}
\def\mathdef2796#1{{}}\mathdef2796{module} &
  \hyperref[text/modules:text-modulefield]{\mathtt{modulefield}}^\ast &\equiv&
  \def\mathdef3159#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3159{(}~\def\mathdef3160#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3160{module}~~\hyperref[text/modules:text-modulefield]{\mathtt{modulefield}}^\ast~\def\mathdef3161#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef3161{)}
\end{array}\end{split}
\end{equation*}

\chapter{Appendix}
\label{\detokenize{appendix/index:id1}}\label{\detokenize{appendix/index::doc}}\label{\detokenize{appendix/index:appendix}}
\index{embedding|textbf}\index{embedder}\index{implementation}\index{host}\ignorespaces 

\section{Embedding}
\label{\detokenize{appendix/embedding:embedding}}\label{\detokenize{appendix/embedding::doc}}\label{\detokenize{appendix/embedding:index-0}}\label{\detokenize{appendix/embedding:embed}}
A WebAssembly implementation will typically be \sphinxstyleemphasis{embedded} into a \sphinxstyleemphasis{host} environment.
An \sphinxstyleemphasis{embedder} implements the connection between such a host environment and the WebAssembly semantics as defined in the main body of this specification.
An embedder is expected to interact with the semantics in well-defined ways.

This section defines a suitable interface to the WebAssembly semantics in the form of entry points through which an embedder can access it.
The interface is intended to be complete, in the sense that an embedder does not need to reference other functional parts of the WebAssembly specification directly.

\begin{sphinxadmonition}{note}{Note:}
On the other hand, an embedder does not need to provide the host environment with access to all functionality defined in this interface.
For example, an implementation may not support {\hyperref[\detokenize{appendix/embedding:embed-parse-module}]{\sphinxcrossref{\DUrole{std,std-ref}{parsing}}}} of the {\hyperref[\detokenize{text/index:text}]{\sphinxcrossref{\DUrole{std,std-ref}{text format}}}}.
\end{sphinxadmonition}

In the description of the embedder interface, syntactic classes from the {\hyperref[\detokenize{syntax/index:syntax}]{\sphinxcrossref{\DUrole{std,std-ref}{abstract syntax}}}} and the {\hyperref[\detokenize{exec/runtime:syntax-runtime}]{\sphinxcrossref{\DUrole{std,std-ref}{runtime’s abstract machine}}}} are used as names for variables that range over the possible objects from that class.
Hence, these syntactic classes can also be interpreted as types.

\phantomsection\label{\detokenize{appendix/embedding:embed-error}}
Failure of an interface operation is indicated by an auxiliary syntactic class:
\begin{equation*}
\begin{split}\begin{array}{llll}
\def\mathdef121#1{{}}\mathdef121{(error)} & \hyperref[appendix/embedding:embed-error]{\mathit{error}} &::=& \hyperref[appendix/embedding:embed-error]{\mathsf{error}} \\
\end{array}\end{split}
\end{equation*}
In addition to the error conditions specified explicitly in this section, implementations may also return errors when specific {\hyperref[\detokenize{appendix/implementation:impl}]{\sphinxcrossref{\DUrole{std,std-ref}{implementation limitations}}}} are reached.

\begin{sphinxadmonition}{note}{Note:}
Errors are abstract and unspecific with this definition.
Implementations can refine it to carry suitable classifications and diagnostic messages.
\end{sphinxadmonition}

\index{allocation}\index{store}\ignorespaces 

\subsection{Store}
\label{\detokenize{appendix/embedding:index-1}}\label{\detokenize{appendix/embedding:store}}\label{\detokenize{appendix/embedding:embed-store}}

\subsubsection{\protect\(\mathrm{init\_store}() : \hyperref[exec/runtime:syntax-store]{\mathit{store}}\protect\)}
\label{\detokenize{appendix/embedding:id1}}\label{\detokenize{appendix/embedding:embed-init-store}}\begin{enumerate}
\item {} 
Return the empty {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}}.

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{init\_store}() &=& \{ \hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}~\epsilon,~ \hyperref[exec/runtime:syntax-store]{\mathsf{mems}}~\epsilon,~ \hyperref[exec/runtime:syntax-store]{\mathsf{tables}}~\epsilon,~ \hyperref[exec/runtime:syntax-store]{\mathsf{globals}}~\epsilon \} \\
\end{array}\end{split}
\end{equation*}
\index{module}\ignorespaces 

\subsection{Modules}
\label{\detokenize{appendix/embedding:embed-module}}\label{\detokenize{appendix/embedding:index-2}}\label{\detokenize{appendix/embedding:modules}}
\index{binary format}\ignorespaces 

\subsubsection{\protect\(\mathrm{decode\_module}(\hyperref[syntax/values:syntax-byte]{\mathit{byte}}^\ast) : \hyperref[syntax/modules:syntax-module]{\mathit{module}} ~|~ \hyperref[appendix/embedding:embed-error]{\mathit{error}}\protect\)}
\label{\detokenize{appendix/embedding:embed-decode-module}}\label{\detokenize{appendix/embedding:id2}}\label{\detokenize{appendix/embedding:index-3}}\begin{enumerate}
\item {} 
If there exists a derivation for the {\hyperref[\detokenize{syntax/values:syntax-byte}]{\sphinxcrossref{\DUrole{std,std-ref}{byte}}}} sequence \(\hyperref[syntax/values:syntax-byte]{\mathit{byte}}^\ast\) as a \(\hyperref[binary/modules:binary-module]{\mathtt{module}}\) according to the {\hyperref[\detokenize{binary/modules:binary-module}]{\sphinxcrossref{\DUrole{std,std-ref}{binary grammar for modules}}}}, yielding a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}} \(m\), then return \(m\).

\item {} 
Else, return \(\hyperref[appendix/embedding:embed-error]{\mathsf{error}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{decode\_module}(b^\ast) &=& m && (\mathrel{\mbox{if}} \hyperref[binary/modules:binary-module]{\mathtt{module}} \stackrel\ast\Longrightarrow m{:}b^\ast) \\
\mathrm{decode\_module}(b^\ast) &=& \hyperref[appendix/embedding:embed-error]{\mathsf{error}} && (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}
\index{text format}\ignorespaces 

\subsubsection{\protect\(\mathrm{parse\_module}(\hyperref[syntax/values:syntax-name]{\mathit{codepoint}}^\ast) : \hyperref[syntax/modules:syntax-module]{\mathit{module}} ~|~ \hyperref[appendix/embedding:embed-error]{\mathit{error}}\protect\)}
\label{\detokenize{appendix/embedding:index-4}}\label{\detokenize{appendix/embedding:embed-parse-module}}\label{\detokenize{appendix/embedding:id3}}\begin{enumerate}
\item {} 
If there exists a derivation for the {\hyperref[\detokenize{text/lexical:text-source}]{\sphinxcrossref{\DUrole{std,std-ref}{source}}}} \(\hyperref[syntax/values:syntax-name]{\mathit{codepoint}}^\ast\) as a \(\hyperref[text/modules:text-module]{\mathtt{module}}\) according to the {\hyperref[\detokenize{text/modules:text-module}]{\sphinxcrossref{\DUrole{std,std-ref}{text grammar for modules}}}}, yielding a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}} \(m\), then return \(m\).

\item {} 
Else, return \(\hyperref[appendix/embedding:embed-error]{\mathsf{error}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{parse\_module}(c^\ast) &=& m && (\mathrel{\mbox{if}} \hyperref[text/modules:text-module]{\mathtt{module}} \stackrel\ast\Longrightarrow m{:}c^\ast) \\
\mathrm{parse\_module}(c^\ast) &=& \hyperref[appendix/embedding:embed-error]{\mathsf{error}} && (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}
\index{validation}\ignorespaces 

\subsubsection{\protect\(\mathrm{validate\_module}(\hyperref[syntax/modules:syntax-module]{\mathit{module}}) : \hyperref[appendix/embedding:embed-error]{\mathit{error}}^?\protect\)}
\label{\detokenize{appendix/embedding:embed-validate-module}}\label{\detokenize{appendix/embedding:id4}}\label{\detokenize{appendix/embedding:index-5}}\begin{enumerate}
\item {} 
If \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}\) is {\hyperref[\detokenize{valid/modules:valid-module}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}, then return nothing.

\item {} 
Else, return \(\hyperref[appendix/embedding:embed-error]{\mathsf{error}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{validate\_module}(m) &=& \epsilon && (\mathrel{\mbox{if}} {} \hyperref[valid/modules:valid-module]{\vdash} m : \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast \hyperref[syntax/types:syntax-functype]{\rightarrow} {\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}'}^\ast) \\
\mathrm{validate\_module}(m) &=& \hyperref[appendix/embedding:embed-error]{\mathsf{error}} && (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}
\index{instantiation}\index{module instance}\ignorespaces 

\subsubsection{\protect\(\mathrm{instantiate\_module}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[syntax/modules:syntax-module]{\mathit{module}}, \hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^\ast) : (\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}} ~|~ \hyperref[appendix/embedding:embed-error]{\mathit{error}})\protect\)}
\label{\detokenize{appendix/embedding:id5}}\label{\detokenize{appendix/embedding:embed-instantiate-module}}\label{\detokenize{appendix/embedding:index-6}}\begin{enumerate}
\item {} 
Try {\hyperref[\detokenize{exec/modules:exec-instantiation}]{\sphinxcrossref{\DUrole{std,std-ref}{instantiating}}}} \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}\) in \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}\) with {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external values}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}^\ast\) as imports:

\end{enumerate}
\begin{enumerate}
\item {} 
If it succeeds with a {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instance}}}} \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\), then let \(\mathit{result}\) be \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\).

\item {} 
Else, let \(\mathit{result}\) be \(\hyperref[appendix/embedding:embed-error]{\mathsf{error}}\).

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Return the new store paired with \(\mathit{result}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{instantiate\_module}(S, m, \mathit{ev}^\ast) &=& (S', F.\hyperref[exec/runtime:syntax-frame]{\mathsf{module}}) && (\mathrel{\mbox{if}} \hyperref[exec/modules:exec-instantiation]{\mathrm{instantiate}}(S, m, \mathit{ev}^\ast) \hyperref[exec/conventions:formal-notation]{\hookrightarrow}^\ast S'; F; \epsilon) \\
\mathrm{instantiate\_module}(S, m, \mathit{ev}^\ast) &=& (S', \hyperref[appendix/embedding:embed-error]{\mathsf{error}}) && (\mathrel{\mbox{if}} \hyperref[exec/modules:exec-instantiation]{\mathrm{instantiate}}(S, m, \mathit{ev}^\ast) \hyperref[exec/conventions:formal-notation]{\hookrightarrow}^\ast S'; F; \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The store may be modified even in case of an error.
\end{sphinxadmonition}

\index{import}\ignorespaces 

\subsubsection{\protect\(\mathrm{module\_imports}(\hyperref[syntax/modules:syntax-module]{\mathit{module}}) : (\hyperref[syntax/values:syntax-name]{\mathit{name}}, \hyperref[syntax/values:syntax-name]{\mathit{name}}, \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}})^\ast\protect\)}
\label{\detokenize{appendix/embedding:id6}}\label{\detokenize{appendix/embedding:embed-imports}}\label{\detokenize{appendix/embedding:index-7}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}\) is {\hyperref[\detokenize{valid/modules:valid-module}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with external import types \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast\) and external export types \({\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}'}^\ast\).

\item {} 
Let \(\hyperref[syntax/modules:syntax-import]{\mathit{import}}^\ast\) be the {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}} \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{imports}}\).

\item {} 
Assert: the length of \(\hyperref[syntax/modules:syntax-import]{\mathit{import}}^\ast\) equals the length of \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast\).

\item {} 
For each \(\hyperref[syntax/modules:syntax-import]{\mathit{import}}_i\) in \(\hyperref[syntax/modules:syntax-import]{\mathit{import}}^\ast\) and corresponding \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}_i\) in \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast\), do:

\end{enumerate}
\begin{enumerate}
\item {} 
Let \(\mathit{result}_i\) be the triple \((\hyperref[syntax/modules:syntax-import]{\mathit{import}}_i.\hyperref[syntax/modules:syntax-import]{\mathsf{module}}, \hyperref[syntax/modules:syntax-import]{\mathit{import}}_i.\hyperref[syntax/modules:syntax-import]{\mathsf{name}}, \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}_i)\).

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Return the concatenation of all \(\mathit{result}_i\), in index order.

\end{enumerate}
\begin{equation*}
\begin{split}~ \\
\begin{array}{lclll}
\mathrm{module\_imports}(m) &=& (\mathit{im}.\hyperref[syntax/modules:syntax-import]{\mathsf{module}}, \mathit{im}.\hyperref[syntax/modules:syntax-import]{\mathsf{name}}, \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}})^\ast \\
  && \qquad (\mathrel{\mbox{if}} \mathit{im}^\ast = m.\hyperref[syntax/modules:syntax-module]{\mathsf{imports}} \wedge {} \hyperref[valid/modules:valid-module]{\vdash} m : \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast \hyperref[syntax/types:syntax-functype]{\rightarrow} {\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}'}^\ast) \\
\end{array}\end{split}
\end{equation*}
\index{export}\ignorespaces 

\subsubsection{\protect\(\mathrm{module\_exports}(\hyperref[syntax/modules:syntax-module]{\mathit{module}}) : (\hyperref[syntax/values:syntax-name]{\mathit{name}}, \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}})^\ast\protect\)}
\label{\detokenize{appendix/embedding:embed-exports}}\label{\detokenize{appendix/embedding:index-8}}\label{\detokenize{appendix/embedding:id7}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}\) is {\hyperref[\detokenize{valid/modules:valid-module}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with external import types \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast\) and external export types \({\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}'}^\ast\).

\item {} 
Let \(\hyperref[syntax/modules:syntax-export]{\mathit{export}}^\ast\) be the {\hyperref[\detokenize{syntax/modules:syntax-export}]{\sphinxcrossref{\DUrole{std,std-ref}{exports}}}} \(\hyperref[syntax/modules:syntax-module]{\mathit{module}}.\hyperref[syntax/modules:syntax-module]{\mathsf{exports}}\).

\item {} 
Assert: the length of \(\hyperref[syntax/modules:syntax-export]{\mathit{export}}^\ast\) equals the length of \({\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}'}^\ast\).

\item {} 
For each \(\hyperref[syntax/modules:syntax-export]{\mathit{export}}_i\) in \(\hyperref[syntax/modules:syntax-export]{\mathit{export}}^\ast\) and corresponding \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}'_i\) in \({\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}'}^\ast\), do:

\end{enumerate}
\begin{enumerate}
\item {} 
Let \(\mathit{result}_i\) be the pair \((\hyperref[syntax/modules:syntax-export]{\mathit{export}}_i.\hyperref[syntax/modules:syntax-export]{\mathsf{name}}, \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}'_i)\).

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Return the concatenation of all \(\mathit{result}_i\), in index order.

\end{enumerate}
\begin{equation*}
\begin{split}~ \\
\begin{array}{lclll}
\mathrm{module\_exports}(m) &=& (\mathit{ex}.\hyperref[syntax/modules:syntax-export]{\mathsf{name}}, \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}')^\ast \\
  && \qquad (\mathrel{\mbox{if}} \mathit{ex}^\ast = m.\hyperref[syntax/modules:syntax-module]{\mathsf{exports}} \wedge {} \hyperref[valid/modules:valid-module]{\vdash} m : \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}^\ast \hyperref[syntax/types:syntax-functype]{\rightarrow} {\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}'}^\ast) \\
\end{array}\end{split}
\end{equation*}
\index{module}\index{store}\index{module instance}\index{export instance}\ignorespaces 

\subsection{Exports}
\label{\detokenize{appendix/embedding:index-9}}\label{\detokenize{appendix/embedding:exports}}\label{\detokenize{appendix/embedding:embed-export}}

\subsubsection{\protect\(\mathrm{get\_export}(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}, \hyperref[syntax/values:syntax-name]{\mathit{name}}) : \hyperref[exec/runtime:syntax-externval]{\mathit{externval}} ~|~ \hyperref[appendix/embedding:embed-error]{\mathit{error}}\protect\)}
\label{\detokenize{appendix/embedding:id8}}\label{\detokenize{appendix/embedding:embed-get-export}}\begin{enumerate}
\item {} 
Assert: due to {\hyperref[\detokenize{appendix/properties:valid-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{validity}}}} of the {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instance}}}} \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\), all its {\hyperref[\detokenize{exec/runtime:syntax-exportinst}]{\sphinxcrossref{\DUrole{std,std-ref}{export names}}}} are different.

\item {} 
If there exists an \(\hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}_i\) in \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{exports}}\) such that {\hyperref[\detokenize{syntax/values:syntax-name}]{\sphinxcrossref{\DUrole{std,std-ref}{name}}}} \(\hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}_i.\hyperref[exec/runtime:syntax-exportinst]{\mathsf{name}}\) equals \(\hyperref[syntax/values:syntax-name]{\mathit{name}}\), then:
\begin{enumerate}
\item {} 
Return the {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}_i.\hyperref[exec/runtime:syntax-exportinst]{\mathsf{value}}\).

\end{enumerate}

\item {} 
Else, return \(\hyperref[appendix/embedding:embed-error]{\mathsf{error}}\).

\end{enumerate}
\begin{equation*}
\begin{split}~ \\
\begin{array}{lclll}
\mathrm{get\_export}(m, \hyperref[syntax/values:syntax-name]{\mathit{name}}) &=& m.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{exports}}[i].\hyperref[exec/runtime:syntax-exportinst]{\mathsf{value}} && (\mathrel{\mbox{if}} m.\hyperref[syntax/modules:syntax-module]{\mathsf{exports}}[i].\hyperref[exec/runtime:syntax-exportinst]{\mathsf{name}} = \hyperref[syntax/values:syntax-name]{\mathit{name}}) \\
\mathrm{get\_export}(m, \hyperref[syntax/values:syntax-name]{\mathit{name}}) &=& \hyperref[appendix/embedding:embed-error]{\mathsf{error}} && (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}
\index{function}\index{host function}\index{function address}\index{function instance}\index{function type}\index{store}\ignorespaces 

\subsection{Functions}
\label{\detokenize{appendix/embedding:index-10}}\label{\detokenize{appendix/embedding:functions}}\label{\detokenize{appendix/embedding:embed-func}}

\subsubsection{\protect\(\mathrm{alloc\_func}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[syntax/types:syntax-functype]{\mathit{functype}}, \hyperref[exec/runtime:syntax-hostfunc]{\mathit{hostfunc}}) : (\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}})\protect\)}
\label{\detokenize{appendix/embedding:embed-alloc-func}}\label{\detokenize{appendix/embedding:id9}}\begin{enumerate}
\item {} 
Let \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}\) be the result of {\hyperref[\detokenize{exec/modules:alloc-func}]{\sphinxcrossref{\DUrole{std,std-ref}{allocating a host function}}}} in \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}\) with {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(\hyperref[syntax/types:syntax-functype]{\mathit{functype}}\) and host function code \(\hyperref[exec/runtime:syntax-hostfunc]{\mathit{hostfunc}}\).

\item {} 
Return the new store paired with \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{alloc\_func}(S, \mathit{ft}, \mathit{code}) &=& (S', \mathit{a}) && (\mathrel{\mbox{if}} \hyperref[exec/modules:alloc-hostfunc]{\mathrm{allochostfunc}}(S, \mathit{ft}, \mathit{code}) = S', \mathit{a}) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
This operation assumes that \(\hyperref[exec/runtime:syntax-hostfunc]{\mathit{hostfunc}}\) satisfies the {\hyperref[\detokenize{exec/instructions:exec-invoke-host}]{\sphinxcrossref{\DUrole{std,std-ref}{pre- and post-conditions}}}} required for a function instance with type \(\hyperref[syntax/types:syntax-functype]{\mathit{functype}}\).

Regular (non-host) function instances can only be created indirectly through {\hyperref[\detokenize{appendix/embedding:embed-instantiate-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module instantiation}}}}.
\end{sphinxadmonition}


\subsubsection{\protect\(\mathrm{type\_func}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}) : \hyperref[syntax/types:syntax-functype]{\mathit{functype}}\protect\)}
\label{\detokenize{appendix/embedding:embed-type-func}}\label{\detokenize{appendix/embedding:id10}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}]\) exists.

\item {} 
Assert: the {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{func}}~\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}\) is {\hyperref[\detokenize{exec/modules:valid-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}\).

\item {} 
Return \(\hyperref[syntax/types:syntax-functype]{\mathit{functype}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{type\_func}(S, a) &=& \mathit{ft} && (\mathrel{\mbox{if}} S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{func}}~a : \hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\mathit{ft}) \\
\end{array}\end{split}
\end{equation*}
\index{invocation}\index{value}\index{result}\ignorespaces 

\subsubsection{\protect\(\mathrm{invoke\_func}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}, \hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast) : (\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast ~|~ \hyperref[appendix/embedding:embed-error]{\mathit{error}})\protect\)}
\label{\detokenize{appendix/embedding:embed-invoke-func}}\label{\detokenize{appendix/embedding:index-11}}\label{\detokenize{appendix/embedding:id11}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}[\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}]\) exists.

\item {} 
Try {\hyperref[\detokenize{exec/modules:exec-invocation}]{\sphinxcrossref{\DUrole{std,std-ref}{invoking}}}} the function \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}\) in \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}\) with {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast\) as arguments:

\end{enumerate}
\begin{enumerate}
\item {} 
If it succeeds with {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} \({\hyperref[exec/runtime:syntax-val]{\mathit{val}}'}^\ast\) as results, then let \(\mathit{result}\) be \({\hyperref[exec/runtime:syntax-val]{\mathit{val}}'}^\ast\).

\item {} 
Else it has trapped, hence let \(\mathit{result}\) be \(\hyperref[appendix/embedding:embed-error]{\mathsf{error}}\).

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Return the new store paired with \(\mathit{result}\).

\end{enumerate}
\begin{equation*}
\begin{split}~ \\
\begin{array}{lclll}
\mathrm{invoke\_func}(S, a, v^\ast) &=& (S', {v'}^\ast) && (\mathrel{\mbox{if}} \hyperref[exec/modules:exec-invocation]{\mathrm{invoke}}(S, a, v^\ast) \hyperref[exec/conventions:formal-notation]{\hookrightarrow}^\ast S'; F; {v'}^\ast) \\
\mathrm{invoke\_func}(S, a, v^\ast) &=& (S', \hyperref[appendix/embedding:embed-error]{\mathsf{error}}) && (\mathrel{\mbox{if}} \hyperref[exec/modules:exec-invocation]{\mathrm{invoke}}(S, a, v^\ast) \hyperref[exec/conventions:formal-notation]{\hookrightarrow}^\ast S'; F; \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}) \\
\end{array}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
The store may be modified even in case of an error.
\end{sphinxadmonition}

\index{table}\index{table address}\index{store}\index{table instance}\index{table type}\index{element}\index{function address}\ignorespaces 

\subsection{Tables}
\label{\detokenize{appendix/embedding:index-12}}\label{\detokenize{appendix/embedding:embed-table}}\label{\detokenize{appendix/embedding:tables}}

\subsubsection{\protect\(\mathrm{alloc\_table}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}) : (\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}})\protect\)}
\label{\detokenize{appendix/embedding:id12}}\label{\detokenize{appendix/embedding:embed-alloc-table}}\begin{enumerate}
\item {} 
Let \(\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}\) be the result of {\hyperref[\detokenize{exec/modules:alloc-table}]{\sphinxcrossref{\DUrole{std,std-ref}{allocating a table}}}} in \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}\) with {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table type}}}} \(\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}\).

\item {} 
Return the new store paired with \(\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{alloc\_table}(S, \mathit{tt}) &=& (S', \mathit{a}) && (\mathrel{\mbox{if}} \hyperref[exec/modules:alloc-table]{\mathrm{alloctable}}(S, \mathit{tt}) = S', \mathit{a}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\mathrm{type\_table}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}) : \hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}\protect\)}
\label{\detokenize{appendix/embedding:embed-type-table}}\label{\detokenize{appendix/embedding:id13}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}]\) exists.

\item {} 
Assert: the {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{table}}~\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}\) is {\hyperref[\detokenize{exec/modules:valid-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}\).

\item {} 
Return \(\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{type\_table}(S, a) &=& \mathit{tt} && (\mathrel{\mbox{if}} S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{table}}~a : \hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~\mathit{tt}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\mathrm{read\_table}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}, i) : \hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}^? ~|~ \hyperref[appendix/embedding:embed-error]{\mathit{error}}\protect\)}
\label{\detokenize{appendix/embedding:embed-read-table}}\label{\detokenize{appendix/embedding:id14}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}]\) exists.

\item {} 
Assert: \(i\) is a non-negative integer.

\item {} 
Let \(\mathit{ti}\) be the {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instance}}}} \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}]\).

\item {} 
If \(i\) is larger than or equal to the length of \(\mathit{ti}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}\), then return \(\hyperref[appendix/embedding:embed-error]{\mathsf{error}}\).

\item {} 
Else, return \(\mathit{ti}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}[i]\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{read\_table}(S, a, i) &=& \mathit{fa}^? && (\mathrel{\mbox{if}} S.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[a].\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}[i] = \mathit{fa}^?) \\
\mathrm{read\_table}(S, a, i) &=& \hyperref[appendix/embedding:embed-error]{\mathsf{error}} && (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\mathrm{write\_table}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}, i, \hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}^?) : \hyperref[exec/runtime:syntax-store]{\mathit{store}} ~|~ \hyperref[appendix/embedding:embed-error]{\mathit{error}}\protect\)}
\label{\detokenize{appendix/embedding:embed-write-table}}\label{\detokenize{appendix/embedding:id15}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}]\) exists.

\item {} 
Assert: \(i\) is a non-negative integer.

\item {} 
Let \(\mathit{ti}\) be the {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instance}}}} \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}]\).

\item {} 
If \(i\) is larger than or equal to the length of \(\mathit{ti}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}\), then return \(\hyperref[appendix/embedding:embed-error]{\mathsf{error}}\).

\item {} 
Replace \(\mathit{ti}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}[i]\) with the optional {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{function address}}}} \(\mathit{fa}^?\).

\item {} 
Return the updated store.

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{write\_table}(S, a, i, \mathit{fa}^?) &=& S' && (\mathrel{\mbox{if}} S' = S \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[a].\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}[i] = \mathit{fa}^?) \\
\mathrm{write\_table}(S, a, i, \mathit{fa}^?) &=& \hyperref[appendix/embedding:embed-error]{\mathsf{error}} && (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\mathrm{size\_table}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}) : \mathit{i32}\protect\)}
\label{\detokenize{appendix/embedding:embed-size-table}}\label{\detokenize{appendix/embedding:id16}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}]\) exists.

\item {} 
Return the length of \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}].\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}\).

\end{enumerate}
\begin{equation*}
\begin{split}~ \\
\begin{array}{lclll}
\mathrm{size\_table}(S, a) &=& n &&
  (\mathrel{\mbox{if}} |S.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[a].\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}| = n) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\mathrm{grow\_table}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}, n) : \hyperref[exec/runtime:syntax-store]{\mathit{store}} ~|~ \hyperref[appendix/embedding:embed-error]{\mathit{error}}\protect\)}
\label{\detokenize{appendix/embedding:id17}}\label{\detokenize{appendix/embedding:embed-grow-table}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}]\) exists.

\item {} 
Assert: \(n\) is a non-negative integer.

\item {} 
Try {\hyperref[\detokenize{exec/modules:grow-table}]{\sphinxcrossref{\DUrole{std,std-ref}{growing}}}} the {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instance}}}} \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}]\) by \(n\) elements:
\begin{enumerate}
\item {} 
If it succeeds, return the updated store.

\item {} 
Else, return \(\hyperref[appendix/embedding:embed-error]{\mathsf{error}}\).

\end{enumerate}

\end{enumerate}
\begin{equation*}
\begin{split}~ \\
\begin{array}{lclll}
\mathrm{grow\_table}(S, a, n) &=& S' &&
  (\mathrel{\mbox{if}} S' = S \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[a] = \hyperref[exec/modules:grow-table]{\mathrm{growtable}}(S.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}[a], n)) \\
\mathrm{grow\_table}(S, a, n) &=& \hyperref[appendix/embedding:embed-error]{\mathsf{error}} && (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}
\index{memory}\index{memory address}\index{store}\index{memory instance}\index{memory type}\index{byte}\ignorespaces 

\subsection{Memories}
\label{\detokenize{appendix/embedding:index-13}}\label{\detokenize{appendix/embedding:embed-mem}}\label{\detokenize{appendix/embedding:memories}}

\subsubsection{\protect\(\mathrm{alloc\_mem}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}) : (\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}})\protect\)}
\label{\detokenize{appendix/embedding:embed-alloc-mem}}\label{\detokenize{appendix/embedding:id18}}\begin{enumerate}
\item {} 
Let \(\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}\) be the result of {\hyperref[\detokenize{exec/modules:alloc-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{allocating a memory}}}} in \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}\) with {\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory type}}}} \(\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}\).

\item {} 
Return the new store paired with \(\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{alloc\_mem}(S, \mathit{mt}) &=& (S', \mathit{a}) && (\mathrel{\mbox{if}} \hyperref[exec/modules:alloc-mem]{\mathrm{allocmem}}(S, \mathit{mt}) = S', \mathit{a}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\mathrm{type\_mem}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}) : \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}\protect\)}
\label{\detokenize{appendix/embedding:id19}}\label{\detokenize{appendix/embedding:embed-type-mem}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}]\) exists.

\item {} 
Assert: the {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{mem}}~\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}\) is {\hyperref[\detokenize{exec/modules:valid-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}\).

\item {} 
Return \(\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{type\_mem}(S, a) &=& \mathit{mt} && (\mathrel{\mbox{if}} S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{mem}}~a : \hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\mathit{mt}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\mathrm{read\_mem}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}, i) : \hyperref[syntax/values:syntax-byte]{\mathit{byte}} ~|~ \hyperref[appendix/embedding:embed-error]{\mathit{error}}\protect\)}
\label{\detokenize{appendix/embedding:id20}}\label{\detokenize{appendix/embedding:embed-read-mem}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}]\) exists.

\item {} 
Assert: \(i\) is a non-negative integer.

\item {} 
Let \(\mathit{mi}\) be the {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}} \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}]\).

\item {} 
If \(i\) is larger than or equal to the length of \(\mathit{mi}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}\), then return \(\hyperref[appendix/embedding:embed-error]{\mathsf{error}}\).

\item {} 
Else, return the  {\hyperref[\detokenize{syntax/values:syntax-byte}]{\sphinxcrossref{\DUrole{std,std-ref}{byte}}}} \(\mathit{mi}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}[i]\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{read\_mem}(S, a, i) &=& b && (\mathrel{\mbox{if}} S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}[i] = b) \\
\mathrm{read\_mem}(S, a, i) &=& \hyperref[appendix/embedding:embed-error]{\mathsf{error}} && (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\mathrm{write\_mem}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}, i, \hyperref[syntax/values:syntax-byte]{\mathit{byte}}) : \hyperref[exec/runtime:syntax-store]{\mathit{store}} ~|~ \hyperref[appendix/embedding:embed-error]{\mathit{error}}\protect\)}
\label{\detokenize{appendix/embedding:id21}}\label{\detokenize{appendix/embedding:embed-write-mem}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}]\) exists.

\item {} 
Assert: \(i\) is a non-negative integer.

\item {} 
Let \(\mathit{mi}\) be the {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}} \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}]\).

\item {} 
If \(i\) is larger than or equal to the length of \(\mathit{mi}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}\), then return \(\hyperref[appendix/embedding:embed-error]{\mathsf{error}}\).

\item {} 
Replace \(\mathit{mi}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}[i]\) with \(\hyperref[syntax/values:syntax-byte]{\mathit{byte}}\).

\item {} 
Return the updated store.

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{write\_mem}(S, a, i, b) &=& S' && (\mathrel{\mbox{if}} S' = S \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}[i] = b) \\
\mathrm{write\_mem}(S, a, i, b) &=& \hyperref[appendix/embedding:embed-error]{\mathsf{error}} && (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\mathrm{size\_mem}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}) : \mathit{i32}\protect\)}
\label{\detokenize{appendix/embedding:embed-size-mem}}\label{\detokenize{appendix/embedding:id22}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}]\) exists.

\item {} 
Return the length of \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}\) divided by the {\hyperref[\detokenize{exec/runtime:page-size}]{\sphinxcrossref{\DUrole{std,std-ref}{page size}}}}.

\end{enumerate}
\begin{equation*}
\begin{split}~ \\
\begin{array}{lclll}
\mathrm{size\_mem}(S, a) &=& n &&
  (\mathrel{\mbox{if}} |S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a].\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}| = n \cdot 64\,\mathrm{Ki}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\mathrm{grow\_mem}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}, n) : \hyperref[exec/runtime:syntax-store]{\mathit{store}} ~|~ \hyperref[appendix/embedding:embed-error]{\mathit{error}}\protect\)}
\label{\detokenize{appendix/embedding:id23}}\label{\detokenize{appendix/embedding:embed-grow-mem}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}]\) exists.

\item {} 
Assert: \(n\) is a non-negative integer.

\item {} 
Try {\hyperref[\detokenize{exec/modules:grow-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{growing}}}} the {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}} \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}]\) by \(n\) {\hyperref[\detokenize{exec/runtime:page-size}]{\sphinxcrossref{\DUrole{std,std-ref}{pages}}}}:
\begin{enumerate}
\item {} 
If it succeeds, return the updated store.

\item {} 
Else, return \(\hyperref[appendix/embedding:embed-error]{\mathsf{error}}\).

\end{enumerate}

\end{enumerate}
\begin{equation*}
\begin{split}~ \\
\begin{array}{lclll}
\mathrm{grow\_mem}(S, a, n) &=& S' &&
  (\mathrel{\mbox{if}} S' = S \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a] = \hyperref[exec/modules:grow-mem]{\mathrm{growmem}}(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}[a], n)) \\
\mathrm{grow\_mem}(S, a, n) &=& \hyperref[appendix/embedding:embed-error]{\mathsf{error}} && (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}
\index{global}\index{global address}\index{store}\index{global instance}\index{global type}\index{value}\ignorespaces 

\subsection{Globals}
\label{\detokenize{appendix/embedding:embed-global}}\label{\detokenize{appendix/embedding:globals}}\label{\detokenize{appendix/embedding:index-14}}

\subsubsection{\protect\(\mathrm{alloc\_global}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}, \hyperref[exec/runtime:syntax-val]{\mathit{val}}) : (\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}})\protect\)}
\label{\detokenize{appendix/embedding:id24}}\label{\detokenize{appendix/embedding:embed-alloc-global}}\begin{enumerate}
\item {} 
Let \(\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}\) be the result of {\hyperref[\detokenize{exec/modules:alloc-global}]{\sphinxcrossref{\DUrole{std,std-ref}{allocating a global}}}} in \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}\) with {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global type}}}} \(\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}\) and initialization value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\).

\item {} 
Return the new store paired with \(\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{alloc\_global}(S, \mathit{gt}, v) &=& (S', \mathit{a}) && (\mathrel{\mbox{if}} \hyperref[exec/modules:alloc-global]{\mathrm{allocglobal}}(S, \mathit{gt}, v) = S', \mathit{a}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\mathrm{type\_global}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}) : \hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}\protect\)}
\label{\detokenize{appendix/embedding:embed-type-global}}\label{\detokenize{appendix/embedding:id25}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}]\) exists.

\item {} 
Assert: the {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{global}}~\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}\) is {\hyperref[\detokenize{exec/modules:valid-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}\).

\item {} 
Return \(\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{type\_global}(S, a) &=& \mathit{gt} && (\mathrel{\mbox{if}} S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{global}}~a : \hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~\mathit{gt}) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\mathrm{read\_global}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}) : \hyperref[exec/runtime:syntax-val]{\mathit{val}}\protect\)}
\label{\detokenize{appendix/embedding:id26}}\label{\detokenize{appendix/embedding:embed-read-global}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}]\) exists.

\item {} 
Let \(\mathit{gi}\) be the {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{global instance}}}} \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}]\).

\item {} 
Return the {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{value}}}} \(\mathit{gi}.\hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}\).

\end{enumerate}
\begin{equation*}
\begin{split}\begin{array}{lclll}
\mathrm{read\_global}(S, a) &=& v && (\mathrel{\mbox{if}} S.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[a].\hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}} = v) \\
\end{array}\end{split}
\end{equation*}

\subsubsection{\protect\(\mathrm{write\_global}(\hyperref[exec/runtime:syntax-store]{\mathit{store}}, \hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}, \hyperref[exec/runtime:syntax-val]{\mathit{val}}) : \hyperref[exec/runtime:syntax-store]{\mathit{store}} ~|~ \hyperref[appendix/embedding:embed-error]{\mathit{error}}\protect\)}
\label{\detokenize{appendix/embedding:id27}}\label{\detokenize{appendix/embedding:embed-write-global}}\begin{enumerate}
\item {} 
Assert: \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[a]\) exists.

\item {} 
Let \(\mathit{gi}\) be the {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{global instance}}}} \(\hyperref[exec/runtime:syntax-store]{\mathit{store}}.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}]\).

\item {} 
If \(\mathit{gi}.\hyperref[exec/runtime:syntax-globalinst]{\mathsf{mut}}\) is not \(\hyperref[syntax/types:syntax-mut]{\mathsf{var}}\), then return \(\hyperref[appendix/embedding:embed-error]{\mathsf{error}}\).

\item {} 
Replace \(\mathit{gi}.\hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}\) with the {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{value}}}} \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}\).

\item {} 
Return the updated store.

\end{enumerate}
\begin{equation*}
\begin{split}~ \\
\begin{array}{lclll}
\mathrm{write\_global}(S, a, v) &=& S' && (\mathrel{\mbox{if}} S.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[a].\hyperref[exec/runtime:syntax-globalinst]{\mathsf{mut}} = \hyperref[syntax/types:syntax-mut]{\mathsf{var}} \wedge S' = S \hyperref[syntax/conventions:notation-replace]{\mathrel{\mbox{with}}} \hyperref[exec/runtime:syntax-store]{\mathsf{globals}}[a].\hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}} = v) \\
\mathrm{write\_global}(S, a, v) &=& \hyperref[appendix/embedding:embed-error]{\mathsf{error}} && (\mathrel{\mbox{otherwise}}) \\
\end{array}\end{split}
\end{equation*}
\index{implementation limitations|textbf}\index{implementation}\ignorespaces 

\section{Implementation Limitations}
\label{\detokenize{appendix/implementation:implementation-limitations}}\label{\detokenize{appendix/implementation:impl}}\label{\detokenize{appendix/implementation::doc}}\label{\detokenize{appendix/implementation:index-0}}
Implementations typically impose additional restrictions on a number of aspects of a WebAssembly module or execution.
These may stem from:
\begin{itemize}
\item {} 
physical resource limits,

\item {} 
constraints imposed by the embedder or its environment,

\item {} 
limitations of selected implementation strategies.

\end{itemize}

This section lists allowed limitations.
Where restrictions take the form of numeric limits, no minimum requirements are given,
nor are the limits assumed to be concrete, fixed numbers.
However, it is expected that all implementations have “reasonably” large limits  to enable common applications.

\begin{sphinxadmonition}{note}{Note:}
A conforming implementation is not allowed to leave out individual \sphinxstyleemphasis{features}.
However, designated subsets of WebAssembly may be specified in the future.
\end{sphinxadmonition}


\subsection{Syntactic Limits}
\label{\detokenize{appendix/implementation:syntactic-limits}}
\index{abstract syntax}\index{module}\index{type}\index{function}\index{table}\index{memory}\index{global}\index{element}\index{data}\index{import}\index{export}\index{parameter}\index{result}\index{local}\index{structured control instruction}\index{instruction}\index{name}\index{Unicode}\index{code point}\ignorespaces 

\subsubsection{Structure}
\label{\detokenize{appendix/implementation:impl-syntax}}\label{\detokenize{appendix/implementation:index-1}}\label{\detokenize{appendix/implementation:structure}}
An implementation may impose restrictions on the following dimensions of a module:
\begin{itemize}
\item {} 
the number of {\hyperref[\detokenize{syntax/types:syntax-type}]{\sphinxcrossref{\DUrole{std,std-ref}{types}}}} in a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}

\item {} 
the number of {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{functions}}}} in a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}, including imports

\item {} 
the number of {\hyperref[\detokenize{syntax/modules:syntax-table}]{\sphinxcrossref{\DUrole{std,std-ref}{tables}}}} in a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}, including imports

\item {} 
the number of {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memories}}}} in a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}, including imports

\item {} 
the number of {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{globals}}}} in a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}, including imports

\item {} 
the number of {\hyperref[\detokenize{syntax/modules:syntax-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{element segments}}}} in a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}

\item {} 
the number of {\hyperref[\detokenize{syntax/modules:syntax-data}]{\sphinxcrossref{\DUrole{std,std-ref}{data segments}}}} in a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}

\item {} 
the number of {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}} to a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}

\item {} 
the number of {\hyperref[\detokenize{syntax/modules:syntax-export}]{\sphinxcrossref{\DUrole{std,std-ref}{exports}}}} form a {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}

\item {} 
the number of parameters in a {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}}

\item {} 
the number of results in a {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}}

\item {} 
the number of {\hyperref[\detokenize{syntax/modules:syntax-local}]{\sphinxcrossref{\DUrole{std,std-ref}{locals}}}} in a {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}}

\item {} 
the size of a {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}} body

\item {} 
the size of a {\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{structured control instruction}}}}

\item {} 
the number of {\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{structured control instructions}}}} in a {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}}

\item {} 
the nesting depth of {\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{structured control instructions}}}}

\item {} 
the number of {\hyperref[\detokenize{syntax/modules:syntax-labelidx}]{\sphinxcrossref{\DUrole{std,std-ref}{label indices}}}} in a \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{br\_table}}\) instruction

\item {} 
the length of an {\hyperref[\detokenize{syntax/modules:syntax-elem}]{\sphinxcrossref{\DUrole{std,std-ref}{element segment}}}}

\item {} 
the length of a {\hyperref[\detokenize{syntax/modules:syntax-data}]{\sphinxcrossref{\DUrole{std,std-ref}{data segment}}}}

\item {} 
the length of a {\hyperref[\detokenize{syntax/values:syntax-name}]{\sphinxcrossref{\DUrole{std,std-ref}{name}}}}

\item {} 
the range of {\hyperref[\detokenize{syntax/values:syntax-codepoint}]{\sphinxcrossref{\DUrole{std,std-ref}{code points}}}} in a {\hyperref[\detokenize{syntax/values:syntax-name}]{\sphinxcrossref{\DUrole{std,std-ref}{name}}}}

\end{itemize}

If the limits of an implementation are exceeded for a given module,
then the implementation may reject the {\hyperref[\detokenize{valid/index:valid}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}}, compilation, or {\hyperref[\detokenize{exec/modules:exec-instantiation}]{\sphinxcrossref{\DUrole{std,std-ref}{instantiation}}}} of that module with an embedder-specific error.

\begin{sphinxadmonition}{note}{Note:}
The last item allows {\hyperref[\detokenize{intro/overview:embedder}]{\sphinxcrossref{\DUrole{std,std-ref}{embedders}}}} that operate in limited environments without support for
\sphinxhref{http://www.unicode.org/versions/latest/}{Unicode}%
\begin{footnote}[47]\sphinxAtStartFootnote
\sphinxnolinkurl{http://www.unicode.org/versions/latest/}
%
\end{footnote} to limit the
names of {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imports}}}} and {\hyperref[\detokenize{syntax/modules:syntax-export}]{\sphinxcrossref{\DUrole{std,std-ref}{exports}}}}
to common subsets like \sphinxhref{http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986\%5bR2012\%5d}{ASCII}%
\begin{footnote}[48]\sphinxAtStartFootnote
\sphinxnolinkurl{http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986\%5bR2012\%5d}
%
\end{footnote}.
\end{sphinxadmonition}

\index{binary format}\index{module}\index{section}\index{function}\index{code}\ignorespaces 

\subsubsection{Binary Format}
\label{\detokenize{appendix/implementation:binary-format}}\label{\detokenize{appendix/implementation:index-2}}\label{\detokenize{appendix/implementation:impl-binary}}
For a module given in {\hyperref[\detokenize{binary/index:binary}]{\sphinxcrossref{\DUrole{std,std-ref}{binary format}}}}, additional limitations may be imposed on the following dimensions:
\begin{itemize}
\item {} 
the size of a {\hyperref[\detokenize{binary/modules:binary-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}}

\item {} 
the size of any {\hyperref[\detokenize{binary/modules:binary-section}]{\sphinxcrossref{\DUrole{std,std-ref}{section}}}}

\item {} 
the size of an individual function’s {\hyperref[\detokenize{binary/modules:binary-code}]{\sphinxcrossref{\DUrole{std,std-ref}{code}}}}

\item {} 
the number of {\hyperref[\detokenize{binary/modules:binary-section}]{\sphinxcrossref{\DUrole{std,std-ref}{sections}}}}

\end{itemize}

\index{text format}\index{source text}\index{token}\index{identifier}\index{character}\index{unicode}\ignorespaces 

\subsubsection{Text Format}
\label{\detokenize{appendix/implementation:impl-text}}\label{\detokenize{appendix/implementation:text-format}}\label{\detokenize{appendix/implementation:index-3}}
For a module given in {\hyperref[\detokenize{text/index:text}]{\sphinxcrossref{\DUrole{std,std-ref}{text format}}}}, additional limitations may be imposed on the following dimensions:
\begin{itemize}
\item {} 
the size of the {\hyperref[\detokenize{text/lexical:source}]{\sphinxcrossref{\DUrole{std,std-ref}{source text}}}}

\item {} 
the size of any syntactic element

\item {} 
the size of an individual {\hyperref[\detokenize{text/lexical:text-token}]{\sphinxcrossref{\DUrole{std,std-ref}{token}}}}

\item {} 
the nesting depth of {\hyperref[\detokenize{text/instructions:text-foldedinstr}]{\sphinxcrossref{\DUrole{std,std-ref}{folded instructions}}}}

\item {} 
the length of symbolic {\hyperref[\detokenize{text/values:text-id}]{\sphinxcrossref{\DUrole{std,std-ref}{identifiers}}}}

\item {} 
the range of literal {\hyperref[\detokenize{text/lexical:text-char}]{\sphinxcrossref{\DUrole{std,std-ref}{characters}}}} (code points) allowed in the {\hyperref[\detokenize{text/lexical:source}]{\sphinxcrossref{\DUrole{std,std-ref}{source text}}}}

\end{itemize}

\index{validation}\index{function}\ignorespaces 

\subsection{Validation}
\label{\detokenize{appendix/implementation:impl-valid}}\label{\detokenize{appendix/implementation:index-4}}\label{\detokenize{appendix/implementation:validation}}
An implementation may defer {\hyperref[\detokenize{valid/index:valid}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}} of individual {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{functions}}}} until they are first {\hyperref[\detokenize{exec/instructions:exec-invoke}]{\sphinxcrossref{\DUrole{std,std-ref}{invoked}}}}.

If a function turns out to be invalid, then the invocation, and every consecutive call to the same function, results in a {\hyperref[\detokenize{intro/overview:trap}]{\sphinxcrossref{\DUrole{std,std-ref}{trap}}}}.

\begin{sphinxadmonition}{note}{Note:}
This is to allow implementations to use interpretation or just-in-time compilation for functions.
The function must still be fully validated before execution of its body begins.
\end{sphinxadmonition}

\index{execution}\index{module instance}\index{function instance}\index{table instance}\index{memory instance}\index{global instance}\index{allocation}\index{frame}\index{label}\index{value}\ignorespaces 

\subsection{Execution}
\label{\detokenize{appendix/implementation:impl-exec}}\label{\detokenize{appendix/implementation:execution}}\label{\detokenize{appendix/implementation:index-5}}
Restrictions on the following dimensions may be imposed during {\hyperref[\detokenize{exec/index:exec}]{\sphinxcrossref{\DUrole{std,std-ref}{execution}}}} of a WebAssembly program:
\begin{itemize}
\item {} 
the number of allocated {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instances}}}}

\item {} 
the number of allocated {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{function instances}}}}

\item {} 
the number of allocated {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instances}}}}

\item {} 
the number of allocated {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instances}}}}

\item {} 
the number of allocated {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{global instances}}}}

\item {} 
the size of a {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instance}}}}

\item {} 
the size of a {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}}

\item {} 
the number of {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frames}}}} on the {\hyperref[\detokenize{exec/runtime:stack}]{\sphinxcrossref{\DUrole{std,std-ref}{stack}}}}

\item {} 
the number of {\hyperref[\detokenize{exec/runtime:syntax-label}]{\sphinxcrossref{\DUrole{std,std-ref}{labels}}}} on the {\hyperref[\detokenize{exec/runtime:stack}]{\sphinxcrossref{\DUrole{std,std-ref}{stack}}}}

\item {} 
the number of {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} on the {\hyperref[\detokenize{exec/runtime:stack}]{\sphinxcrossref{\DUrole{std,std-ref}{stack}}}}

\end{itemize}

If the runtime limits of an implementation are exceeded during execution of a computation,
then it may terminate that computation and report an embedder-specific error to the invoking code.

Some of the above limits may already be verified during instantiation, in which case an implementation may report exceedance in the same manner as for {\hyperref[\detokenize{appendix/implementation:impl-syntax}]{\sphinxcrossref{\DUrole{std,std-ref}{syntactic limits}}}}.

\begin{sphinxadmonition}{note}{Note:}
Concrete limits are usually not fixed but may be dependent on specifics, interdependent, vary over time, or depend on other implementation- or embedder-specific situations or events.
\end{sphinxadmonition}

\index{validation}\index{algorithm}\index{instruction}\index{module}\index{binary format}\index{opcode}\ignorespaces 

\section{Validation Algorithm}
\label{\detokenize{appendix/algorithm:validation-algorithm}}\label{\detokenize{appendix/algorithm::doc}}\label{\detokenize{appendix/algorithm:index-0}}\label{\detokenize{appendix/algorithm:algo-valid}}
The specification of WebAssembly {\hyperref[\detokenize{valid/index:valid}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}} is purely \sphinxstyleemphasis{declarative}.
It describes the constraints that must be met by a {\hyperref[\detokenize{valid/modules:valid-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}} or {\hyperref[\detokenize{valid/instructions:valid-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instruction}}}} sequence to be valid.

This section sketches the skeleton of a sound and complete \sphinxstyleemphasis{algorithm} for effectively validating code, i.e., sequences of {\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instructions}}}}.
(Other aspects of validation are straightforward to implement.)

In fact, the algorithm is expressed over the flat sequence of opcodes as occurring in the {\hyperref[\detokenize{binary/index:binary}]{\sphinxcrossref{\DUrole{std,std-ref}{binary format}}}}, and performs only a single pass over it.
Consequently, it can be integrated directly into a decoder.

The algorithm is expressed in typed pseudo code whose semantics is intended to be self-explanatory.

\index{value type}\index{stack}\index{label}\index{frame}\index{instruction}\ignorespaces 

\subsection{Data Structures}
\label{\detokenize{appendix/algorithm:data-structures}}\label{\detokenize{appendix/algorithm:index-1}}
The algorithm uses two separate stacks: the \sphinxstyleemphasis{operand stack} and the \sphinxstyleemphasis{control stack}.
The former tracks the {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{types}}}} of operand values on the {\hyperref[\detokenize{exec/runtime:stack}]{\sphinxcrossref{\DUrole{std,std-ref}{stack}}}},
the latter surrounding {\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{structured control instructions}}}} and their associated {\hyperref[\detokenize{syntax/instructions:syntax-instr-control}]{\sphinxcrossref{\DUrole{std,std-ref}{blocks}}}}.

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{type} \PYG{n+nf}{val\PYGZus{}type} = I32 \textbar{} I64 \textbar{} F32 \textbar{} F64

\PYG{k}{type} \PYG{n+nf}{opd\PYGZus{}stack} = stack(val\PYGZus{}type \textbar{} Unknown)

\PYG{k}{type} \PYG{n+nf}{ctrl\PYGZus{}stack} = stack(ctrl\PYGZus{}frame)
\PYG{k}{type} \PYG{n+nf}{ctrl\PYGZus{}frame} = \PYGZob{}
  \PYG{n+nf}{opcode} : opcode
  \PYG{n+nf}{start\PYGZus{}types} : list(val\PYGZus{}type)
  \PYG{n+nf}{end\PYGZus{}types} : list(val\PYGZus{}type)
  \PYG{n+nf}{height} : nat
  \PYG{n+nf}{unreachable} : bool
\PYGZcb{}
\end{sphinxVerbatim}

For each value, the operand stack records its {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}}, or \sphinxcode{\sphinxupquote{Unknown}} when the type is not known.

For each entered block, the control stack records a \sphinxstyleemphasis{control frame} with the originating opcode, the types on the top of the operand stack at the start and end of the block (used to check its result as well as branches), the height of the operand stack at the start of the block (used to check that operands do not underflow the current block), and a flag recording whether the remainder of the block is unreachable (used to handle {\hyperref[\detokenize{valid/instructions:polymorphism}]{\sphinxcrossref{\DUrole{std,std-ref}{stack-polymorphic}}}} typing after branches).

For the purpose of presenting the algorithm, the operand and control stacks are simply maintained as global variables:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{var} \PYG{n+nf}{opds} : opd\PYGZus{}stack
\PYG{k}{var} \PYG{n+nf}{ctrls} : ctrl\PYGZus{}stack
\end{sphinxVerbatim}

However, these variables are not manipulated directly by the main checking function, but through a set of auxiliary functions:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{func} \PYG{n+nf}{push\PYGZus{}opd}(\PYG{n+nf}{type} : val\PYGZus{}type \textbar{} Unknown) =
  opds.push(type)

\PYG{k}{func} \PYG{n+nf}{pop\PYGZus{}opd}() : val\PYGZus{}type \textbar{} Unknown =
  \PYG{k}{if} (opds.size() = ctrls[0].height \PYGZam{}\PYGZam{} ctrls[0].unreachable) \PYG{k}{return} Unknown
  error\PYGZus{}if(opds.size() = ctrls[0].height)
  \PYG{k}{return} opds.pop()

\PYG{k}{func} \PYG{n+nf}{pop\PYGZus{}opd}(\PYG{n+nf}{expect} : val\PYGZus{}type \textbar{} Unknown) : val\PYGZus{}type \textbar{} Unknown =
  \PYG{k}{let} \PYG{n+nf}{actual} = pop\PYGZus{}opd()
  \PYG{k}{if} (actual = Unknown) \PYG{k}{return} expect
  \PYG{k}{if} (expect = Unknown) \PYG{k}{return} actual
  error\PYGZus{}if(actual =/= expect)
  \PYG{k}{return} actual

\PYG{k}{func} \PYG{n+nf}{push\PYGZus{}opds}(\PYG{n+nf}{types} : list(val\PYGZus{}type)) = \PYG{k}{foreach} (t \PYG{k}{in} types) push\PYGZus{}opd(t)
\PYG{k}{func} \PYG{n+nf}{pop\PYGZus{}opds}(\PYG{n+nf}{types} : list(val\PYGZus{}type)) = \PYG{k}{foreach} (t \PYG{k}{in} reverse(types)) pop\PYGZus{}opd(t)
\end{sphinxVerbatim}

Pushing an operand simply pushes the respective type to the operand stack.

Popping an operand checks that the operand stack does not underflow the current block and then removes one type.
But first, a special case is handled where the block contains no known operands, but has been marked as unreachable.
That can occur after an unconditional branch, when the stack is typed {\hyperref[\detokenize{valid/instructions:polymorphism}]{\sphinxcrossref{\DUrole{std,std-ref}{polymorphically}}}}.
In that case, an unknown type is returned.

A second function for popping an operand takes an expected type, which the actual operand type is checked against.
The types may differ in case one of them is Unknown.
The more specific type is returned.

Finally, there are accumulative functions for pushing or popping multiple operand types.

\begin{sphinxadmonition}{note}{Note:}
The notation \sphinxcode{\sphinxupquote{stack{[}i{]}}} is meant to index the stack from the top,
so that \sphinxcode{\sphinxupquote{ctrls{[}0{]}}} accesses the element pushed last.
\end{sphinxadmonition}

The control stack is likewise manipulated through auxiliary functions:

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{func} \PYG{n+nf}{push\PYGZus{}ctrl}(\PYG{n+nf}{opcode} : opcode, \PYG{k}{in} : list(val\PYGZus{}type), \PYG{n+nf}{out} : list(val\PYGZus{}type)) =
  \PYG{k}{let} \PYG{n+nf}{frame} = ctrl\PYGZus{}frame(opcode, \PYG{k}{in}, out, opds.size(), false)
  ctrls.push(frame)
  push\PYGZus{}opds(\PYG{k}{in})

\PYG{k}{func} \PYG{n+nf}{pop\PYGZus{}ctrl}() : ctrl\PYGZus{}frame =
  error\PYGZus{}if(ctrls.is\PYGZus{}empty())
  \PYG{k}{let} \PYG{n+nf}{frame} = ctrls[0]
  pop\PYGZus{}opds(frame.end\PYGZus{}types)
  error\PYGZus{}if(opds.size() =/= frame.height)
  ctrls.pop()
  \PYG{k}{return} frame

\PYG{k}{func} \PYG{n+nf}{label\PYGZus{}types}(\PYG{n+nf}{frame} : ctrl\PYGZus{}frame) : list(val\PYGZus{}types) =
  \PYG{k}{return} (if frame.opcode == loop then frame.start\PYGZus{}types else frame.end\PYGZus{}types)

\PYG{k}{func} \PYG{n+nf}{unreachable}() =
  opds.resize(ctrls[0].height)
  ctrls[0].unreachable := true
\end{sphinxVerbatim}

Pushing a control frame takes the types of the label and result values.
It allocates a new frame record recording them along with the current height of the operand stack and marks the block as reachable.

Popping a frame first checks that the control stack is not empty.
It then verifies that the operand stack contains the right types of values expected at the end of the exited block and pops them off the operand stack.
Afterwards, it checks that the stack has shrunk back to its initial height.

The type of the {\hyperref[\detokenize{exec/runtime:syntax-label}]{\sphinxcrossref{\DUrole{std,std-ref}{label}}}} associated with a control frame is either that of the stack at the start or the end of the frame, determined by the opcode that it originates from.

Finally, the current frame can be marked as unreachable.
In that case, all existing operand types are purged from the operand stack, in order to allow for the {\hyperref[\detokenize{valid/instructions:polymorphism}]{\sphinxcrossref{\DUrole{std,std-ref}{stack-polymorphism}}}} logic in \sphinxcode{\sphinxupquote{pop\_opd}} to take effect.

\begin{sphinxadmonition}{note}{Note:}
Even with the unreachable flag set, consecutive operands are still pushed to and popped from the operand stack.
That is necessary to detect invalid {\hyperref[\detokenize{valid/instructions:polymorphism}]{\sphinxcrossref{\DUrole{std,std-ref}{examples}}}} like \((\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{unreachable}}~(\hyperref[syntax/types:syntax-valtype]{\mathsf{i32}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}})~\hyperref[syntax/types:syntax-valtype]{\mathsf{i64}}.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{add}})\).
However, a polymorphic stack cannot underflow, but instead generates \sphinxcode{\sphinxupquote{Unknown}} types as needed.
\end{sphinxadmonition}

\index{opcode}\ignorespaces 

\subsection{Validation of Opcode Sequences}
\label{\detokenize{appendix/algorithm:index-2}}\label{\detokenize{appendix/algorithm:validation-of-opcode-sequences}}
The following function shows the validation of a number of representative instructions that manipulate the stack.
Other instructions are checked in a similar manner.

\begin{sphinxadmonition}{note}{Note:}
Various instructions not shown here will additionally require the presence of a validation {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} for checking uses of {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{indices}}}}.
That is an easy addition and therefore omitted from this presentation.
\end{sphinxadmonition}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{func} \PYG{n+nf}{validate}(opcode) =
  \PYG{k}{switch} (opcode)
    \PYG{k}{case} (i32.add)
      pop\PYGZus{}opd(I32)
      pop\PYGZus{}opd(I32)
      push\PYGZus{}opd(I32)

    \PYG{k}{case} (drop)
      pop\PYGZus{}opd()

    \PYG{k}{case} (select)
      pop\PYGZus{}opd(I32)
      \PYG{k}{let} \PYG{n+nf}{t1} = pop\PYGZus{}opd()
      \PYG{k}{let} \PYG{n+nf}{t2} = pop\PYGZus{}opd(t1)
      push\PYGZus{}opd(t2)

    \PYG{k}{case} (unreachable)
      unreachable()

    \PYG{k}{case} (block t1*\PYGZhy{}\PYGZgt{}t2*)
      pop\PYGZus{}opds([t1*])
      push\PYGZus{}ctrl(block, [t1*], [t2*])

    \PYG{k}{case} (loop t1*\PYGZhy{}\PYGZgt{}t2*)
      pop\PYGZus{}opds([t1*])
      push\PYGZus{}ctrl(loop, [t1*], [t2*])

    \PYG{k}{case} (if t1*\PYGZhy{}\PYGZgt{}t2*)
      pop\PYGZus{}opd(I32)
      pop\PYGZus{}opds([t1*])
      push\PYGZus{}ctrl(if, [t1*], [t2*])

    \PYG{k}{case} (end)
      \PYG{k}{let} \PYG{n+nf}{frame} = pop\PYGZus{}ctrl()
      push\PYGZus{}opds(frame.end\PYGZus{}types)

    \PYG{k}{case} (else)
      \PYG{k}{let} \PYG{n+nf}{frame} = pop\PYGZus{}ctrl()
      error\PYGZus{}if(frame.opcode =/= \PYG{k}{if})
      push\PYGZus{}ctrl(else, frame.start\PYGZus{}types, frame.end\PYGZus{}types)

    \PYG{k}{case} (br n)
      error\PYGZus{}if(ctrls.size() \PYGZlt{} n)
      pop\PYGZus{}opds(label\PYGZus{}types(ctrls[n]))
      unreachable()

    \PYG{k}{case} (br\PYGZus{}if n)
      error\PYGZus{}if(ctrls.size() \PYGZlt{} n)
      pop\PYGZus{}opd(I32)
      pop\PYGZus{}opds(label\PYGZus{}types(ctrls[n]))
      push\PYGZus{}opds(label\PYGZus{}types(ctrls[n]))

    \PYG{k}{case} (br\PYGZus{}table n* m)
      error\PYGZus{}if(ctrls.size() \PYGZlt{} m)
      \PYG{k}{foreach} (n \PYG{k}{in} n*)
        error\PYGZus{}if(ctrls.size() \PYGZlt{} n \textbar{}\textbar{} label\PYGZus{}types(ctrls[n]) =/= label\PYGZus{}types(ctrls[m]))
      pop\PYGZus{}opd(I32)
      pop\PYGZus{}opds(label\PYGZus{}types(ctrls[m]))
      unreachable()
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
It is an invariant under the current WebAssembly instruction set that an operand of \sphinxcode{\sphinxupquote{Unknown}} type is never duplicated on the stack.
This would change if the language were extended with stack operators like \sphinxcode{\sphinxupquote{dup}}.
Under such an extension, the above algorithm would need to be refined by replacing the \sphinxcode{\sphinxupquote{Unknown}} type with proper \sphinxstyleemphasis{type variables} to ensure that all uses are consistent.
\end{sphinxadmonition}

\index{custom section}\index{section}\index{binary format}\ignorespaces 

\section{Custom Sections}
\label{\detokenize{appendix/custom::doc}}\label{\detokenize{appendix/custom:index-0}}\label{\detokenize{appendix/custom:custom-sections}}
This appendix defines dedicated {\hyperref[\detokenize{binary/modules:binary-customsec}]{\sphinxcrossref{\DUrole{std,std-ref}{custom sections}}}} for WebAssembly’s {\hyperref[\detokenize{binary/index:binary}]{\sphinxcrossref{\DUrole{std,std-ref}{binary format}}}}.
Such sections do not contribute to, or otherwise affect, the WebAssembly semantics, and like any custom section they may be ignored by an implementation.
However, they provide useful meta data that implementations can make use of to improve user experience or take compilation hints.

Currently, only one dedicated custom section is defined, the {\hyperref[\detokenize{appendix/custom:binary-namesec}]{\sphinxcrossref{\DUrole{std,std-ref}{name section}}}}.

\index{name section|textbf}\index{name}\index{Unicode UTF-8}\ignorespaces 

\subsection{Name Section}
\label{\detokenize{appendix/custom:name-section}}\label{\detokenize{appendix/custom:binary-namesec}}\label{\detokenize{appendix/custom:index-1}}
The \sphinxstyleemphasis{name section} is a {\hyperref[\detokenize{binary/modules:binary-customsec}]{\sphinxcrossref{\DUrole{std,std-ref}{custom section}}}} whose name string is itself \(\def\mathdef119#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef119{name}\).
The name section should appear only once in a module, and only after the {\hyperref[\detokenize{binary/modules:binary-datasec}]{\sphinxcrossref{\DUrole{std,std-ref}{data section}}}}.

The purpose of this section is to attach printable names to definitions in a module, which e.g. can be used by a debugger or when parts of the module are to be rendered in {\hyperref[\detokenize{text/index:text}]{\sphinxcrossref{\DUrole{std,std-ref}{text form}}}}.

\begin{sphinxadmonition}{note}{Note:}
All {\hyperref[\detokenize{binary/values:binary-name}]{\sphinxcrossref{\DUrole{std,std-ref}{names}}}} are represented in \sphinxhref{http://www.unicode.org/versions/latest/}{Unicode}%
\begin{footnote}[49]\sphinxAtStartFootnote
\sphinxnolinkurl{http://www.unicode.org/versions/latest/}
%
\end{footnote} encoded in UTF-8.
Names need not be unique.
\end{sphinxadmonition}


\subsubsection{Subsections}
\label{\detokenize{appendix/custom:subsections}}\label{\detokenize{appendix/custom:binary-namesubsection}}
The {\hyperref[\detokenize{binary/modules:binary-customsec}]{\sphinxcrossref{\DUrole{std,std-ref}{data}}}} of a name section consists of a sequence of \sphinxstyleemphasis{subsections}.
Each subsection consists of a
\begin{itemize}
\item {} 
a one-byte subsection \sphinxstyleemphasis{id},

\item {} 
the \(\hyperref[syntax/values:syntax-int]{\def\mathdef66#1{{\mathit{u}#1}}\mathdef66{\mathit{32}}}\) \sphinxstyleemphasis{size} of the contents, in bytes,

\item {} 
the actual \sphinxstyleemphasis{contents}, whose structure is depended on the subsection id.

\end{itemize}
\begin{equation*}
\begin{split}\begin{array}{llcll}
\def\mathdef60#1{{}}\mathdef60{name section} & \hyperref[appendix/custom:binary-namesubsection]{\mathtt{namesec}} &::=&
  \hyperref[binary/modules:binary-section]{\mathtt{section}}_0(\hyperref[appendix/custom:binary-namesubsection]{\mathtt{namedata}}) \\
\def\mathdef60#1{{}}\mathdef60{name data} & \hyperref[appendix/custom:binary-namesubsection]{\mathtt{namedata}} &::=&
  n{:}\hyperref[binary/values:binary-name]{\mathtt{name}}~~\hyperref[appendix/custom:binary-namesubsection]{\mathtt{namesubsection}}^\ast & (\mathrel{\mbox{if}} n = \def\mathdef120#1{\mbox{‘}\mathtt{#1}\mbox{’}}\mathdef120{name}) \\
\def\mathdef60#1{{}}\mathdef60{name subsection} & \hyperref[appendix/custom:binary-namesubsection]{\mathtt{namesubsection}}_N(\mathtt{B}) &::=&
  N{:}\hyperref[binary/values:binary-byte]{\mathtt{byte}}~~\mathit{size}{:}\hyperref[binary/values:binary-int]{\def\mathdef87#1{{\mathtt{u}#1}}\mathdef87{\mathtt{32}}}~~\mathtt{B}
    & (\mathrel{\mbox{if}} \mathit{size} = ||\mathtt{B}||) \\
\end{array}\end{split}
\end{equation*}
The following subsection ids are used:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
Id
&\sphinxstyletheadfamily 
Subsection
\\
\hline
0
&
{\hyperref[\detokenize{appendix/custom:binary-modulenamesec}]{\sphinxcrossref{\DUrole{std,std-ref}{module name}}}}
\\
\hline
1
&
{\hyperref[\detokenize{appendix/custom:binary-funcnamesec}]{\sphinxcrossref{\DUrole{std,std-ref}{function names}}}}
\\
\hline
2
&
{\hyperref[\detokenize{appendix/custom:binary-localnamesec}]{\sphinxcrossref{\DUrole{std,std-ref}{local names}}}}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\index{name map|textbf}\index{index}\index{index space}\ignorespaces \phantomsection\label{\detokenize{appendix/custom:binary-indirectnamemap}}

\subsubsection{Name Maps}
\label{\detokenize{appendix/custom:binary-namemap}}\label{\detokenize{appendix/custom:index-2}}\label{\detokenize{appendix/custom:name-maps}}\label{\detokenize{appendix/custom:binary-indirectnamemap}}
A \sphinxstyleemphasis{name map} assigns {\hyperref[\detokenize{syntax/values:syntax-name}]{\sphinxcrossref{\DUrole{std,std-ref}{names}}}} to {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{indices}}}} in a given {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{index space}}}}.
It consists of a {\hyperref[\detokenize{binary/conventions:binary-vec}]{\sphinxcrossref{\DUrole{std,std-ref}{vector}}}} of index/name pairs in order of increasing index value.
Each index must be unique, but the assigned names need not be.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef60#1{{}}\mathdef60{name map} & \hyperref[appendix/custom:binary-namemap]{\mathtt{namemap}} &::=&
  \hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[appendix/custom:binary-namemap]{\mathtt{nameassoc}}) \\
\def\mathdef60#1{{}}\mathdef60{name association} & \hyperref[appendix/custom:binary-namemap]{\mathtt{nameassoc}} &::=&
  \hyperref[binary/modules:binary-index]{\mathtt{idx}}~\hyperref[binary/values:binary-name]{\mathtt{name}} \\
\end{array}\end{split}
\end{equation*}
An \sphinxstyleemphasis{indirect name map} assigns {\hyperref[\detokenize{syntax/values:syntax-name}]{\sphinxcrossref{\DUrole{std,std-ref}{names}}}} to a two-dimensional {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{index space}}}}, where secondary indices are \sphinxstyleemphasis{grouped} by primary indices.
It consists of a vector of primary index/name map pairs in order of increasing index value, where each name map in turn maps secondary indices to names.
Each primary index must be unique, and likewise each secondary index per individual name map.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef60#1{{}}\mathdef60{indirect name map} & \hyperref[appendix/custom:binary-indirectnamemap]{\mathtt{indirectnamemap}} &::=&
  \hyperref[binary/conventions:binary-vec]{\mathtt{vec}}(\hyperref[appendix/custom:binary-indirectnamemap]{\mathtt{indirectnameassoc}}) \\
\def\mathdef60#1{{}}\mathdef60{indirect name association} & \hyperref[appendix/custom:binary-indirectnamemap]{\mathtt{indirectnameassoc}} &::=&
  \hyperref[binary/modules:binary-index]{\mathtt{idx}}~\hyperref[appendix/custom:binary-namemap]{\mathtt{namemap}} \\
\end{array}\end{split}
\end{equation*}
\index{module}\ignorespaces 

\subsubsection{Module Names}
\label{\detokenize{appendix/custom:module-names}}\label{\detokenize{appendix/custom:binary-modulenamesec}}\label{\detokenize{appendix/custom:index-3}}
The \sphinxstyleemphasis{module name subsection} has the id 0.
It simply consists of a single {\hyperref[\detokenize{binary/values:binary-name}]{\sphinxcrossref{\DUrole{std,std-ref}{name}}}} that is assigned to the module itself.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef60#1{{}}\mathdef60{module name subsection} & \hyperref[appendix/custom:binary-modulenamesec]{\mathtt{modulenamesubsec}} &::=&
  \hyperref[appendix/custom:binary-namesubsection]{\mathtt{namesubsection}}_0(\hyperref[binary/values:binary-name]{\mathtt{name}}) \\
\end{array}\end{split}
\end{equation*}
\index{function}\index{function index}\ignorespaces 

\subsubsection{Function Names}
\label{\detokenize{appendix/custom:function-names}}\label{\detokenize{appendix/custom:binary-funcnamesec}}\label{\detokenize{appendix/custom:index-4}}
The \sphinxstyleemphasis{function name subsection} has the id 1.
It consists of a {\hyperref[\detokenize{appendix/custom:binary-namemap}]{\sphinxcrossref{\DUrole{std,std-ref}{name map}}}} assigning function names to {\hyperref[\detokenize{syntax/modules:syntax-funcidx}]{\sphinxcrossref{\DUrole{std,std-ref}{function indices}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef60#1{{}}\mathdef60{function name subsection} & \hyperref[appendix/custom:binary-funcnamesec]{\mathtt{funcnamesubsec}} &::=&
  \hyperref[appendix/custom:binary-namesubsection]{\mathtt{namesubsection}}_1(\hyperref[appendix/custom:binary-namemap]{\mathtt{namemap}}) \\
\end{array}\end{split}
\end{equation*}
\index{function}\index{local}\index{function index}\index{local index}\ignorespaces 

\subsubsection{Local Names}
\label{\detokenize{appendix/custom:local-names}}\label{\detokenize{appendix/custom:binary-localnamesec}}\label{\detokenize{appendix/custom:index-5}}
The \sphinxstyleemphasis{local name subsection} has the id 2.
It consists of an {\hyperref[\detokenize{appendix/custom:binary-indirectnamemap}]{\sphinxcrossref{\DUrole{std,std-ref}{indirect name map}}}} assigning local names to {\hyperref[\detokenize{syntax/modules:syntax-localidx}]{\sphinxcrossref{\DUrole{std,std-ref}{local indices}}}} grouped by {\hyperref[\detokenize{syntax/modules:syntax-funcidx}]{\sphinxcrossref{\DUrole{std,std-ref}{function indices}}}}.
\begin{equation*}
\begin{split}\begin{array}{llclll}
\def\mathdef60#1{{}}\mathdef60{local name subsection} & \hyperref[appendix/custom:binary-localnamesec]{\mathtt{localnamesubsec}} &::=&
  \hyperref[appendix/custom:binary-namesubsection]{\mathtt{namesubsection}}_2(\hyperref[appendix/custom:binary-indirectnamemap]{\mathtt{indirectnamemap}}) \\
\end{array}\end{split}
\end{equation*}
\index{soundness|textbf}\index{type system}\ignorespaces 

\section{Soundness}
\label{\detokenize{appendix/properties:id1}}\label{\detokenize{appendix/properties::doc}}\label{\detokenize{appendix/properties:index-0}}\label{\detokenize{appendix/properties:soundness}}
The {\hyperref[\detokenize{valid/conventions:type-system}]{\sphinxcrossref{\DUrole{std,std-ref}{type system}}}} of WebAssembly is \sphinxstyleemphasis{sound}, implying both \sphinxstyleemphasis{type safety} and \sphinxstyleemphasis{memory safety} with respect to the WebAssembly semantics. For example:
\begin{itemize}
\item {} 
All types declared and derived during validation are respected at run time;
e.g., every {\hyperref[\detokenize{syntax/modules:syntax-local}]{\sphinxcrossref{\DUrole{std,std-ref}{local}}}} or {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}} variable will only contain type-correct values, every {\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instruction}}}} will only be applied to operands of the expected type, and every {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}} {\hyperref[\detokenize{exec/modules:exec-invocation}]{\sphinxcrossref{\DUrole{std,std-ref}{invocation}}}} always evaluates to a result of the right type (if it does not {\hyperref[\detokenize{intro/overview:trap}]{\sphinxcrossref{\DUrole{std,std-ref}{trap}}}} or diverge).

\item {} 
No memory location will be read or written except those explicitly defined by the program, i.e., as a {\hyperref[\detokenize{syntax/modules:syntax-local}]{\sphinxcrossref{\DUrole{std,std-ref}{local}}}}, a {\hyperref[\detokenize{syntax/modules:syntax-global}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}}, an element in a {\hyperref[\detokenize{syntax/modules:syntax-table}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}}, or a location within a linear {\hyperref[\detokenize{syntax/modules:syntax-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{memory}}}}.

\item {} 
There is no undefined behavior,
i.e., the {\hyperref[\detokenize{exec/index:exec}]{\sphinxcrossref{\DUrole{std,std-ref}{execution rules}}}} cover all possible cases that can occur in a {\hyperref[\detokenize{valid/index:valid}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} program, and the rules are mutually consistent.

\end{itemize}

Soundness also is instrumental in ensuring additional properties, most notably, \sphinxstyleemphasis{encapsulation} of function and module scopes: no {\hyperref[\detokenize{syntax/modules:syntax-local}]{\sphinxcrossref{\DUrole{std,std-ref}{locals}}}} can be accessed outside their own function and no {\hyperref[\detokenize{syntax/modules:syntax-module}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}} components can be accessed outside their own module unless they are explicitly {\hyperref[\detokenize{syntax/modules:syntax-export}]{\sphinxcrossref{\DUrole{std,std-ref}{exported}}}} or {\hyperref[\detokenize{syntax/modules:syntax-import}]{\sphinxcrossref{\DUrole{std,std-ref}{imported}}}}.

The typing rules defining WebAssembly {\hyperref[\detokenize{valid/index:valid}]{\sphinxcrossref{\DUrole{std,std-ref}{validation}}}} only cover the \sphinxstyleemphasis{static} components of a WebAssembly program.
In order to state and prove soundness precisely, the typing rules must be extended to the \sphinxstyleemphasis{dynamic} components of the abstract {\hyperref[\detokenize{exec/runtime:syntax-runtime}]{\sphinxcrossref{\DUrole{std,std-ref}{runtime}}}}, that is, the {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}}, {\hyperref[\detokenize{exec/runtime:syntax-config}]{\sphinxcrossref{\DUrole{std,std-ref}{configurations}}}}, and {\hyperref[\detokenize{exec/runtime:syntax-instr-admin}]{\sphinxcrossref{\DUrole{std,std-ref}{administrative instructions}}}}. %
\begin{footnote}[50]\sphinxAtStartFootnote
The formalization and theorems are derived from the following article:
Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke Wagner, Alon Zakai, JF Bastien, Michael Holman. \sphinxhref{https://dl.acm.org/citation.cfm?doid=3062341.3062363}{Bringing the Web up to Speed with WebAssembly}. Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.
%
\end{footnote}

\index{value}\index{value type}\index{result}\index{result type}\index{trap}\ignorespaces \phantomsection\label{\detokenize{appendix/properties:valid-val}}

\subsection{Values and Results}
\label{\detokenize{appendix/properties:valid-val}}\label{\detokenize{appendix/properties:values-and-results}}\label{\detokenize{appendix/properties:valid-result}}\label{\detokenize{appendix/properties:index-1}}
{\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{Values}}}} and {\hyperref[\detokenize{exec/runtime:syntax-result}]{\sphinxcrossref{\DUrole{std,std-ref}{results}}}} can be classified by {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} and {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result types}}}} as follows.


\subsubsection{Values \protect\(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c\protect\)}
\label{\detokenize{appendix/properties:values}}\begin{itemize}
\item {} 
The value is valid with {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  \hyperref[appendix/properties:valid-val]{\vdash} t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c : t
}\end{split}
\end{equation*}

\subsubsection{Results \protect\(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast\protect\)}
\label{\detokenize{appendix/properties:results}}\begin{itemize}
\item {} 
For each {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{value}}}} \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}_i\) in \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast\):
\begin{itemize}
\item {} 
The value \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}_i\) is {\hyperref[\detokenize{appendix/properties:valid-val}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t_i\).

\end{itemize}

\item {} 
Let \(t^\ast\) be the concatenation of all \(t_i\).

\item {} 
Then the result is valid with {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t^\ast]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  (\hyperref[appendix/properties:valid-val]{\vdash} \hyperref[exec/runtime:syntax-val]{\mathit{val}} : t)^\ast
}{
  \hyperref[appendix/properties:valid-result]{\vdash} \hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast : [t^\ast]
}\end{split}
\end{equation*}

\subsubsection{Results \protect\(\hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}\protect\)}
\label{\detokenize{appendix/properties:id3}}\begin{itemize}
\item {} 
The result is valid with {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t^\ast]\), for any sequence \(t^\ast\) of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}}.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  \hyperref[appendix/properties:valid-result]{\vdash} \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}} : [t^\ast]
}\end{split}
\end{equation*}\phantomsection\label{\detokenize{appendix/properties:module-context}}

\subsection{Store Validity}
\label{\detokenize{appendix/properties:valid-store}}\label{\detokenize{appendix/properties:store-validity}}\label{\detokenize{appendix/properties:module-context}}
The following typing rules specify when a runtime {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} \(S\) is \sphinxstyleemphasis{valid}.
A valid store must consist of
{\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}}, {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}}, {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory}}}}, {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}}, and {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module}}}} instances that are themselves valid, relative to \(S\).

To that end, each kind of instance is classified by a respective {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}}, {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table}}}}, {\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory}}}}, or {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global}}}} type.
Module instances are classified by \sphinxstyleemphasis{module contexts}, which are regular {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{contexts}}}} repurposed as module types describing the {\hyperref[\detokenize{syntax/modules:syntax-index}]{\sphinxcrossref{\DUrole{std,std-ref}{index spaces}}}} defined by a module.

\index{store}\index{function instance}\index{table instance}\index{memory instance}\index{global instance}\index{function type}\index{table type}\index{memory type}\index{global type}\ignorespaces 

\subsubsection{Store \protect\(S\protect\)}
\label{\detokenize{appendix/properties:index-2}}\label{\detokenize{appendix/properties:store}}\begin{itemize}
\item {} 
Each {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{function instance}}}} \(\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}_i\) in \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}\) must be {\hyperref[\detokenize{appendix/properties:valid-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(\hyperref[syntax/types:syntax-functype]{\mathit{functype}}_i\).

\item {} 
Each {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instance}}}} \(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}_i\) in \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}\) must be {\hyperref[\detokenize{appendix/properties:valid-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table type}}}} \(\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}_i\).

\item {} 
Each {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}} \(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}_i\) in \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}\) must be {\hyperref[\detokenize{appendix/properties:valid-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory type}}}} \(\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}_i\).

\item {} 
Each {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{global instance}}}} \(\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}_i\) in \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}\) must be {\hyperref[\detokenize{appendix/properties:valid-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some  {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global type}}}} \(\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}_i\).

\item {} 
Then the store is valid.

\end{itemize}
\begin{equation*}
\begin{split}~\\[-1ex]
\frac{
  \begin{array}{@{}c@{}}
  (S \hyperref[appendix/properties:valid-funcinst]{\vdash} \hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}} : \hyperref[syntax/types:syntax-functype]{\mathit{functype}})^\ast
  \qquad
  (S \hyperref[appendix/properties:valid-tableinst]{\vdash} \hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}} : \hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}})^\ast
  \\
  (S \hyperref[appendix/properties:valid-meminst]{\vdash} \hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}} : \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}})^\ast
  \qquad
  (S \hyperref[appendix/properties:valid-globalinst]{\vdash} \hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}} : \hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}})^\ast
  \\
  S = \{
    \hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}~\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}^\ast,
    \hyperref[exec/runtime:syntax-store]{\mathsf{tables}}~\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}^\ast,
    \hyperref[exec/runtime:syntax-store]{\mathsf{mems}}~\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}^\ast,
    \hyperref[exec/runtime:syntax-store]{\mathsf{globals}}~\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}^\ast \}
  \end{array}
}{
  \hyperref[appendix/properties:valid-store]{\vdash} S \mathrel{\mbox{ok}}
}\end{split}
\end{equation*}
\index{function type}\index{function instance}\ignorespaces 

\subsubsection{Function Instances \protect\(\{\hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}, \hyperref[exec/runtime:syntax-funcinst]{\mathsf{module}}~\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}, \hyperref[exec/runtime:syntax-funcinst]{\mathsf{code}}~\hyperref[syntax/modules:syntax-func]{\mathit{func}}\}\protect\)}
\label{\detokenize{appendix/properties:function-instances}}\label{\detokenize{appendix/properties:valid-funcinst}}\label{\detokenize{appendix/properties:index-3}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instance}}}} \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\) must be {\hyperref[\detokenize{appendix/properties:valid-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} \(C\).

\item {} 
Under {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} \(C\), the {\hyperref[\detokenize{syntax/modules:syntax-func}]{\sphinxcrossref{\DUrole{std,std-ref}{function}}}} \(\hyperref[syntax/modules:syntax-func]{\mathit{func}}\) must be {\hyperref[\detokenize{valid/modules:valid-func}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(\hyperref[syntax/types:syntax-functype]{\mathit{functype}}\).

\item {} 
Then the function instance is valid with {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(\hyperref[syntax/types:syntax-functype]{\mathit{functype}}\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  S \hyperref[appendix/properties:valid-moduleinst]{\vdash} \hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}} : C
  \qquad
  C \hyperref[valid/modules:valid-func]{\vdash} \hyperref[syntax/modules:syntax-func]{\mathit{func}} : \hyperref[syntax/types:syntax-functype]{\mathit{functype}}
}{
  S \hyperref[appendix/properties:valid-funcinst]{\vdash} \{\hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}, \hyperref[exec/runtime:syntax-funcinst]{\mathsf{module}}~\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}, \hyperref[exec/runtime:syntax-funcinst]{\mathsf{code}}~\hyperref[syntax/modules:syntax-func]{\mathit{func}}\} : \hyperref[syntax/types:syntax-functype]{\mathit{functype}}
}\end{split}
\end{equation*}
\index{function type}\index{function instance}\index{host function}\ignorespaces 

\subsubsection{Host Function Instances \protect\(\{\hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}, \hyperref[exec/runtime:syntax-funcinst]{\mathsf{hostcode}}~\mathit{hf}\}\protect\)}
\label{\detokenize{appendix/properties:index-4}}\label{\detokenize{appendix/properties:valid-hostfuncinst}}\label{\detokenize{appendix/properties:host-function-instances}}\begin{itemize}
\item {} 
Let \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\) be the {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(\hyperref[syntax/types:syntax-functype]{\mathit{functype}}\).

\item {} 
For every {\hyperref[\detokenize{appendix/properties:valid-store}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} \(S_1\) {\hyperref[\detokenize{appendix/properties:extend-store}]{\sphinxcrossref{\DUrole{std,std-ref}{extending}}}} \(S\) and every sequence \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast\) of {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{values}}}} whose {\hyperref[\detokenize{appendix/properties:valid-val}]{\sphinxcrossref{\DUrole{std,std-ref}{types}}}} coincide with \(t_1^\ast\):
\begin{itemize}
\item {} 
{\hyperref[\detokenize{exec/instructions:exec-invoke-host}]{\sphinxcrossref{\DUrole{std,std-ref}{Executing}}}} \(\mathit{hf}\) in store \(S_1\) with arguments \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast\) has a non-empty set of possible outcomes.

\item {} 
For every element \(R\) of this set:
\begin{itemize}
\item {} 
Either \(R\) must be \(\bot\) (i.e., divergence).

\item {} 
Or \(R\) consists of a {\hyperref[\detokenize{appendix/properties:valid-store}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} \(S_2\) {\hyperref[\detokenize{appendix/properties:extend-store}]{\sphinxcrossref{\DUrole{std,std-ref}{extending}}}} \(S_1\) and a {\hyperref[\detokenize{exec/runtime:syntax-result}]{\sphinxcrossref{\DUrole{std,std-ref}{result}}}} \(\hyperref[exec/runtime:syntax-result]{\mathit{result}}\) whose {\hyperref[\detokenize{appendix/properties:valid-result}]{\sphinxcrossref{\DUrole{std,std-ref}{type}}}} coincides with \([t_2^\ast]\).

\end{itemize}

\end{itemize}

\item {} 
Then the function instance is valid with {\hyperref[\detokenize{syntax/types:syntax-functype}]{\sphinxcrossref{\DUrole{std,std-ref}{function type}}}} \(\hyperref[syntax/types:syntax-functype]{\mathit{functype}}\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \begin{array}[b]{@{}l@{}}
  \forall S_1, \hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast,~
    {\hyperref[appendix/properties:valid-store]{\vdash} S_1 \mathrel{\mbox{ok}}} \wedge
    {\hyperref[appendix/properties:extend-store]{\vdash} S \hyperref[appendix/properties:extend]{\preceq} S_1} \wedge
    {\hyperref[appendix/properties:valid-result]{\vdash} \hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast : [t_1^\ast]}
    \Longrightarrow {} \\ \qquad
    \mathit{hf}(S_1; \hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast) \supset \emptyset \wedge {} \\ \qquad
  \forall R \in \mathit{hf}(S_1; \hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast),~
    R = \bot \vee {} \\ \qquad\qquad
    \exists S_2, \hyperref[exec/runtime:syntax-result]{\mathit{result}},~
    {\hyperref[appendix/properties:valid-store]{\vdash} S_2 \mathrel{\mbox{ok}}} \wedge
    {\hyperref[appendix/properties:extend-store]{\vdash} S_1 \hyperref[appendix/properties:extend]{\preceq} S_2} \wedge
    {\hyperref[appendix/properties:valid-result]{\vdash} \hyperref[exec/runtime:syntax-result]{\mathit{result}} : [t_2^\ast]} \wedge
    R = (S_2; \hyperref[exec/runtime:syntax-result]{\mathit{result}})
  \end{array}
}{
  S \hyperref[appendix/properties:valid-funcinst]{\vdash} \{\hyperref[exec/runtime:syntax-funcinst]{\mathsf{type}}~[t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast], \hyperref[exec/runtime:syntax-funcinst]{\mathsf{hostcode}}~\mathit{hf}\} : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}
\begin{sphinxadmonition}{note}{Note:}
This rule states that, if appropriate pre-conditions about store and arguments are satisfied, then executing the host function must satisfy appropriate post-conditions about store and results.
The post-conditions match the ones in the {\hyperref[\detokenize{exec/instructions:exec-invoke-host}]{\sphinxcrossref{\DUrole{std,std-ref}{execution rule}}}} for invoking host functions.

Any store under which the function is invoked is assumed to be an extension of the current store.
That way, the function itself is able to make sufficient assumptions about future stores.
\end{sphinxadmonition}

\index{table type}\index{table instance}\index{limits}\index{function address}\ignorespaces 

\subsubsection{Table Instances \protect\(\{ \hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}~(\mathit{fa}^?)^n, \hyperref[exec/runtime:syntax-tableinst]{\mathsf{max}}~m^? \}\protect\)}
\label{\detokenize{appendix/properties:valid-tableinst}}\label{\detokenize{appendix/properties:table-instances}}\label{\detokenize{appendix/properties:index-5}}\begin{itemize}
\item {} 
For each optional {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{function address}}}} \(\mathit{fa}^?_i\) in the table elements \((\mathit{fa}^?)^n\):
\begin{itemize}
\item {} 
Either \(\mathit{fa}^?_i\) is empty.

\item {} 
Or the {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{func}}~\mathit{fa}\) must be {\hyperref[\detokenize{exec/modules:valid-externval-func}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\mathit{ft}\).

\end{itemize}

\item {} 
The {\hyperref[\detokenize{syntax/types:syntax-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{limits}}}} \(\{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\}\) must be {\hyperref[\detokenize{valid/types:valid-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}.

\item {} 
Then the table instance is valid with {\hyperref[\detokenize{syntax/types:syntax-tabletype}]{\sphinxcrossref{\DUrole{std,std-ref}{table type}}}} \(\{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\}~\hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}}\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  ((S \vdash \hyperref[exec/runtime:syntax-externval]{\mathsf{func}}~\mathit{fa} : \hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}})^?)^n
  \qquad
  \hyperref[valid/types:valid-limits]{\vdash} \{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\} \mathrel{\mbox{ok}}
}{
  S \hyperref[appendix/properties:valid-tableinst]{\vdash} \{ \hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}~(\mathit{fa}^?)^n, \hyperref[exec/runtime:syntax-tableinst]{\mathsf{max}}~m^? \} : \{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\}~\hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}}
}\end{split}
\end{equation*}
\index{memory type}\index{memory instance}\index{limits}\index{byte}\ignorespaces 

\subsubsection{Memory Instances \protect\(\{ \hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}~b^n, \hyperref[exec/runtime:syntax-meminst]{\mathsf{max}}~m^? \}\protect\)}
\label{\detokenize{appendix/properties:valid-meminst}}\label{\detokenize{appendix/properties:memory-instances}}\label{\detokenize{appendix/properties:index-6}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{syntax/types:syntax-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{limits}}}} \(\{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\}\) must be {\hyperref[\detokenize{valid/types:valid-limits}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}.

\item {} 
Then the memory instance is valid with {\hyperref[\detokenize{syntax/types:syntax-memtype}]{\sphinxcrossref{\DUrole{std,std-ref}{memory type}}}} \(\{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\}\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \hyperref[valid/types:valid-limits]{\vdash} \{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\} \mathrel{\mbox{ok}}
}{
  S \hyperref[appendix/properties:valid-meminst]{\vdash} \{ \hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}~b^n, \hyperref[exec/runtime:syntax-meminst]{\mathsf{max}}~m^? \} : \{\hyperref[syntax/types:syntax-limits]{\mathsf{min}}~n, \hyperref[syntax/types:syntax-limits]{\mathsf{max}}~m^?\}
}\end{split}
\end{equation*}
\index{global type}\index{global instance}\index{value}\index{mutability}\ignorespaces 

\subsubsection{Global Instances \protect\(\{ \hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}~(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c), \hyperref[exec/runtime:syntax-globalinst]{\mathsf{mut}}~\hyperref[syntax/types:syntax-mut]{\mathit{mut}} \}\protect\)}
\label{\detokenize{appendix/properties:global-instances}}\label{\detokenize{appendix/properties:valid-globalinst}}\label{\detokenize{appendix/properties:index-7}}\begin{itemize}
\item {} 
The global instance is valid with {\hyperref[\detokenize{syntax/types:syntax-globaltype}]{\sphinxcrossref{\DUrole{std,std-ref}{global type}}}} \(\hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  S \hyperref[appendix/properties:valid-globalinst]{\vdash} \{ \hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}~(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c), \hyperref[exec/runtime:syntax-globalinst]{\mathsf{mut}}~\hyperref[syntax/types:syntax-mut]{\mathit{mut}} \} : \hyperref[syntax/types:syntax-mut]{\mathit{mut}}~t
}\end{split}
\end{equation*}
\index{external type}\index{export instance}\index{name}\index{external value}\ignorespaces 

\subsubsection{Export Instances \protect\(\{ \hyperref[exec/runtime:syntax-exportinst]{\mathsf{name}}~\hyperref[syntax/values:syntax-name]{\mathit{name}}, \hyperref[exec/runtime:syntax-exportinst]{\mathsf{value}}~\hyperref[exec/runtime:syntax-externval]{\mathit{externval}} \}\protect\)}
\label{\detokenize{appendix/properties:valid-exportinst}}\label{\detokenize{appendix/properties:export-instances}}\label{\detokenize{appendix/properties:index-8}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathit{externval}}\) must be {\hyperref[\detokenize{exec/modules:valid-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}\).

\item {} 
Then the export instance is valid.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathit{externval}} : \hyperref[syntax/types:syntax-externtype]{\mathit{externtype}}
}{
  S \hyperref[appendix/properties:valid-exportinst]{\vdash} \{ \hyperref[exec/runtime:syntax-exportinst]{\mathsf{name}}~\hyperref[syntax/values:syntax-name]{\mathit{name}}, \hyperref[exec/runtime:syntax-exportinst]{\mathsf{value}}~\hyperref[exec/runtime:syntax-externval]{\mathit{externval}} \} \mathrel{\mbox{ok}}
}\end{split}
\end{equation*}
\index{module instance}\index{context}\ignorespaces 

\subsubsection{Module Instances \protect\(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\protect\)}
\label{\detokenize{appendix/properties:index-9}}\label{\detokenize{appendix/properties:valid-moduleinst}}\label{\detokenize{appendix/properties:module-instances}}\begin{itemize}
\item {} 
For each {\hyperref[\detokenize{exec/runtime:syntax-funcaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{function address}}}} \(\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}_i\) in \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}}\), the {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{func}}~\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}_i\) must be {\hyperref[\detokenize{exec/modules:valid-externval-func}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}'_i\).

\item {} 
For each {\hyperref[\detokenize{exec/runtime:syntax-tableaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{table address}}}} \(\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}_i\) in \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{tableaddrs}}\), the {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{table}}~\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}_i\) must be {\hyperref[\detokenize{exec/modules:valid-externval-table}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}_i\).

\item {} 
For each {\hyperref[\detokenize{exec/runtime:syntax-memaddr}]{\sphinxcrossref{\DUrole{std,std-ref}{memory address}}}} \(\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}_i\) in \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}}\), the {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{mem}}~\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}_i\) must be {\hyperref[\detokenize{exec/modules:valid-externval-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}_i\).

\item {} 
For each {\hyperref[\detokenize{exec/runtime:syntax-globaladdr}]{\sphinxcrossref{\DUrole{std,std-ref}{global address}}}} \(\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}_i\) in \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{globaladdrs}}\), the {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{global}}~\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}_i\) must be {\hyperref[\detokenize{exec/modules:valid-externval-global}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}_i\).

\item {} 
Each {\hyperref[\detokenize{exec/runtime:syntax-exportinst}]{\sphinxcrossref{\DUrole{std,std-ref}{export instance}}}} \(\hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}_i\) in \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{exports}}\) must be {\hyperref[\detokenize{appendix/properties:valid-exportinst}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}.

\item {} 
For each {\hyperref[\detokenize{exec/runtime:syntax-exportinst}]{\sphinxcrossref{\DUrole{std,std-ref}{export instance}}}} \(\hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}_i\) in \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{exports}}\), the {\hyperref[\detokenize{syntax/values:syntax-name}]{\sphinxcrossref{\DUrole{std,std-ref}{name}}}} \(\hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}_i.\hyperref[exec/runtime:syntax-exportinst]{\mathsf{name}}\) must be different from any other name occurring in \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}.\hyperref[exec/runtime:syntax-moduleinst]{\mathsf{exports}}\).

\item {} 
Let \({\hyperref[syntax/types:syntax-functype]{\mathit{functype}}'}^\ast\) be the concatenation of all \(\hyperref[syntax/types:syntax-functype]{\mathit{functype}}'_i\) in order.

\item {} 
Let \(\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}^\ast\) be the concatenation of all \(\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}_i\) in order.

\item {} 
Let \(\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}^\ast\) be the concatenation of all \(\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}_i\) in order.

\item {} 
Let \(\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}^\ast\) be the concatenation of all \(\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}_i\) in order.

\item {} 
Then the module instance is valid with {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} \(\{\hyperref[valid/conventions:context]{\mathsf{types}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}^\ast, \hyperref[valid/conventions:context]{\mathsf{funcs}}~{\hyperref[syntax/types:syntax-functype]{\mathit{functype}}'}^\ast, \hyperref[valid/conventions:context]{\mathsf{tables}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}^\ast, \hyperref[valid/conventions:context]{\mathsf{mems}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}^\ast, \hyperref[valid/conventions:context]{\mathsf{globals}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}^\ast\}\).

\end{itemize}
\begin{equation*}
\begin{split}~\\[-1ex]
\frac{
  \begin{array}{@{}c@{}}
  (S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{func}}~\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}} : \hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~\hyperref[syntax/types:syntax-functype]{\mathit{functype}}')^\ast
  \qquad
  (S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{table}}~\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}} : \hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~\hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}})^\ast
  \\
  (S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{mem}}~\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}} : \hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\hyperref[syntax/types:syntax-memtype]{\mathit{memtype}})^\ast
  \qquad
  (S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{global}}~\hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}} : \hyperref[syntax/types:syntax-externtype]{\mathsf{global}}~\hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}})^\ast
  \\
  (S \hyperref[appendix/properties:valid-exportinst]{\vdash} \hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}} \mathrel{\mbox{ok}})^\ast
  \qquad
  (\hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}.\hyperref[exec/runtime:syntax-exportinst]{\mathsf{name}})^\ast ~\mbox{disjoint}
  \end{array}
}{
  S \hyperref[appendix/properties:valid-moduleinst]{\vdash} \{
    \begin{array}[t]{@{}l@{~}l@{}}
    \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{types}} & \hyperref[syntax/types:syntax-functype]{\mathit{functype}}^\ast, \\
    \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{funcaddrs}} & \hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}^\ast, \\
    \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{tableaddrs}} & \hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}^\ast, \\
    \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{memaddrs}} & \hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}^\ast, \\
    \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{globaladdrs}} & \hyperref[exec/runtime:syntax-globaladdr]{\mathit{globaladdr}}^\ast \\
    \hyperref[exec/runtime:syntax-moduleinst]{\mathsf{exports}} & \hyperref[exec/runtime:syntax-exportinst]{\mathit{exportinst}}^\ast ~\} : \{
      \begin{array}[t]{@{}l@{~}l@{}}
      \hyperref[valid/conventions:context]{\mathsf{types}} & \hyperref[syntax/types:syntax-functype]{\mathit{functype}}^\ast, \\
      \hyperref[valid/conventions:context]{\mathsf{funcs}} & {\hyperref[syntax/types:syntax-functype]{\mathit{functype}}'}^\ast, \\
      \hyperref[valid/conventions:context]{\mathsf{tables}} & \hyperref[syntax/types:syntax-tabletype]{\mathit{tabletype}}^\ast, \\
      \hyperref[valid/conventions:context]{\mathsf{mems}} & \hyperref[syntax/types:syntax-memtype]{\mathit{memtype}}^\ast, \\
      \hyperref[valid/conventions:context]{\mathsf{globals}} & \hyperref[syntax/types:syntax-globaltype]{\mathit{globaltype}}^\ast ~\}
      \end{array}
    \end{array}
}\end{split}
\end{equation*}
\index{configuration}\index{administrative instruction}\index{store}\index{frame}\ignorespaces \phantomsection\label{\detokenize{appendix/properties:frame-context}}

\subsection{Configuration Validity}
\label{\detokenize{appendix/properties:configuration-validity}}\label{\detokenize{appendix/properties:frame-context}}\label{\detokenize{appendix/properties:index-10}}\label{\detokenize{appendix/properties:valid-config}}
To relate the WebAssembly {\hyperref[\detokenize{valid/index:valid}]{\sphinxcrossref{\DUrole{std,std-ref}{type system}}}} to its {\hyperref[\detokenize{exec/index:exec}]{\sphinxcrossref{\DUrole{std,std-ref}{execution semantics}}}}, the {\hyperref[\detokenize{valid/instructions:valid-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{typing rules for instructions}}}} must be extended to {\hyperref[\detokenize{exec/runtime:syntax-config}]{\sphinxcrossref{\DUrole{std,std-ref}{configurations}}}} \(S;T\),
which relates the {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} to execution {\hyperref[\detokenize{exec/runtime:syntax-thread}]{\sphinxcrossref{\DUrole{std,std-ref}{threads}}}}.

Configurations and threads are classified by their {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}}.
In addition to the store \(S\), threads are typed under a \sphinxstyleemphasis{return type} \(\hyperref[syntax/types:syntax-resulttype]{\mathit{resulttype}}^?\), which controls whether and with which type a \(\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{return}}\) instruction is allowed.
This type is absent (\(\epsilon\)) except for instruction sequences inside an administrative \(\hyperref[exec/runtime:syntax-frame]{\mathsf{frame}}\) instruction.

Finally, {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frames}}}} are classified with \sphinxstyleemphasis{frame contexts}, which extend the {\hyperref[\detokenize{appendix/properties:module-context}]{\sphinxcrossref{\DUrole{std,std-ref}{module contexts}}}} of a frame’s associated {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instance}}}} with the {\hyperref[\detokenize{syntax/modules:syntax-local}]{\sphinxcrossref{\DUrole{std,std-ref}{locals}}}} that the frame contains.

\index{result type}\index{thread}\ignorespaces 

\subsubsection{Configurations \protect\(S;T\protect\)}
\label{\detokenize{appendix/properties:index-11}}\label{\detokenize{appendix/properties:configurations}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} \(S\) must be {\hyperref[\detokenize{appendix/properties:valid-store}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}}.

\item {} 
Under no allowed return type,
the {\hyperref[\detokenize{exec/runtime:syntax-thread}]{\sphinxcrossref{\DUrole{std,std-ref}{thread}}}} \(T\) must be {\hyperref[\detokenize{appendix/properties:valid-thread}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t^?]\).

\item {} 
Then the configuration is valid with the {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t^?]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \hyperref[appendix/properties:valid-store]{\vdash} S \mathrel{\mbox{ok}}
  \qquad
  S; \epsilon \hyperref[appendix/properties:valid-thread]{\vdash} T : [t^?]
}{
  \hyperref[appendix/properties:valid-config]{\vdash} S; T : [t^?]
}\end{split}
\end{equation*}
\index{thread}\index{frame}\index{instruction}\index{result type}\index{context}\ignorespaces 

\subsubsection{Threads \protect\(F;\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\protect\)}
\label{\detokenize{appendix/properties:valid-thread}}\label{\detokenize{appendix/properties:index-12}}\label{\detokenize{appendix/properties:threads}}\begin{itemize}
\item {} 
Let \(\hyperref[syntax/types:syntax-resulttype]{\mathit{resulttype}}^?\) be the current allowed return type.

\item {} 
The {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{frame}}}} \(F\) must be {\hyperref[\detokenize{appendix/properties:valid-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with a {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} \(C\).

\item {} 
Let \(C'\) be the same {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} as \(C\), but with \(\hyperref[valid/conventions:context]{\mathsf{return}}\) set to \(\hyperref[syntax/types:syntax-resulttype]{\mathit{resulttype}}^?\).

\item {} 
Under context \(C'\),
the instruction sequence \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\) must be {\hyperref[\detokenize{valid/instructions:valid-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some type \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t^?]\).

\item {} 
Then the thread is valid with the {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t^?]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  S \hyperref[appendix/properties:valid-frame]{\vdash} F : C
  \qquad
  S; C,\hyperref[valid/conventions:context]{\mathsf{return}}~\hyperref[syntax/types:syntax-resulttype]{\mathit{resulttype}}^? \hyperref[valid/instructions:valid-instr-seq]{\vdash} \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast : [] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t^?]
}{
  S; \hyperref[syntax/types:syntax-resulttype]{\mathit{resulttype}}^? \hyperref[appendix/properties:valid-thread]{\vdash} F; \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast : [t^?]
}\end{split}
\end{equation*}
\index{frame}\index{local}\index{module instance}\index{value}\index{value type}\index{context}\ignorespaces 

\subsubsection{Frames \protect\(\{\hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}~\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast, \hyperref[exec/runtime:syntax-frame]{\mathsf{module}}~\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\}\protect\)}
\label{\detokenize{appendix/properties:valid-frame}}\label{\detokenize{appendix/properties:frames}}\label{\detokenize{appendix/properties:index-13}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instance}}}} \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\) must be {\hyperref[\detokenize{appendix/properties:valid-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{appendix/properties:module-context}]{\sphinxcrossref{\DUrole{std,std-ref}{module context}}}} \(C\).

\item {} 
Each {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{value}}}} \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}_i\) in \(\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast\) must be {\hyperref[\detokenize{appendix/properties:valid-val}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} \(t_i\).

\item {} 
Let \(t^\ast\) the concatenation of all \(t_i\) in order.

\item {} 
Let \(C'\) be the same {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} as \(C\), but with the {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} \(t^\ast\) prepended to the \(\hyperref[valid/conventions:context]{\mathsf{locals}}\) vector.

\item {} 
Then the frame is valid with {\hyperref[\detokenize{appendix/properties:frame-context}]{\sphinxcrossref{\DUrole{std,std-ref}{frame context}}}} \(C'\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  S \hyperref[appendix/properties:valid-moduleinst]{\vdash} \hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}} : C
  \qquad
  (\hyperref[appendix/properties:valid-val]{\vdash} \hyperref[exec/runtime:syntax-val]{\mathit{val}} : t)^\ast
}{
  S \hyperref[appendix/properties:valid-frame]{\vdash} \{\hyperref[exec/runtime:syntax-frame]{\mathsf{locals}}~\hyperref[exec/runtime:syntax-val]{\mathit{val}}^\ast, \hyperref[exec/runtime:syntax-frame]{\mathsf{module}}~\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\} : (C, \hyperref[valid/conventions:context]{\mathsf{locals}}~t^\ast)
}\end{split}
\end{equation*}
\index{administrative instruction}\index{value type}\index{context}\index{store}\ignorespaces 

\subsection{Administrative Instructions}
\label{\detokenize{appendix/properties:administrative-instructions}}\label{\detokenize{appendix/properties:index-14}}\label{\detokenize{appendix/properties:valid-instr-admin}}
Typing rules for {\hyperref[\detokenize{exec/runtime:syntax-instr-admin}]{\sphinxcrossref{\DUrole{std,std-ref}{administrative instructions}}}} are specified as follows.
In addition to the {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} \(C\), typing of these instructions is defined under a given {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} \(S\).
To that end, all previous typing judgements \(C \vdash \mathit{prop}\) are generalized to include the store, as in \(S; C \vdash \mathit{prop}\), by implicitly adding \(S\) to all rules \textendash{} \(S\) is never modified by the pre-existing rules, but it is accessed in the extra rules for {\hyperref[\detokenize{appendix/properties:valid-instr-admin}]{\sphinxcrossref{\DUrole{std,std-ref}{administrative instructions}}}} given below.

\index{trap}\ignorespaces 

\subsubsection{\protect\(\hyperref[exec/runtime:syntax-trap]{\mathsf{trap}}\protect\)}
\label{\detokenize{appendix/properties:id4}}\label{\detokenize{appendix/properties:index-15}}\begin{itemize}
\item {} 
The instruction is valid with type \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\), for any sequences of {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value types}}}} \(t_1^\ast\) and \(t_2^\ast\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  S; C \hyperref[appendix/properties:valid-instr-admin]{\vdash} \hyperref[exec/runtime:syntax-trap]{\mathsf{trap}} : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}
\index{function address}\index{extern value}\index{extern type}\index{function type}\ignorespaces 

\subsubsection{\protect\(\hyperref[exec/runtime:syntax-invoke]{\mathsf{invoke}}~\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}\protect\)}
\label{\detokenize{appendix/properties:index-16}}\label{\detokenize{appendix/properties:id5}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external function value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{func}}~\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}}\) must be {\hyperref[\detokenize{exec/modules:valid-externval-func}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external function type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{func}} ([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast])\).

\item {} 
Then the instruction is valid with type \([t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{func}}~\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}} : \hyperref[syntax/types:syntax-externtype]{\mathsf{func}}~[t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}{
  S; C \hyperref[appendix/properties:valid-instr-admin]{\vdash} \hyperref[exec/runtime:syntax-invoke]{\mathsf{invoke}}~\hyperref[exec/runtime:syntax-funcaddr]{\mathit{funcaddr}} : [t_1^\ast] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^\ast]
}\end{split}
\end{equation*}
\index{element}\index{table}\index{table address}\index{module instance}\index{function index}\ignorespaces 

\subsubsection{\protect\(\hyperref[exec/runtime:syntax-init-elem]{\mathsf{init\_elem}}~\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}~o~x^n\protect\)}
\label{\detokenize{appendix/properties:id6}}\label{\detokenize{appendix/properties:index-17}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external table value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{table}}~\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}\) must be {\hyperref[\detokenize{exec/modules:valid-externval-table}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external table type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~\hyperref[syntax/types:syntax-limits]{\mathit{limits}}~\hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}}\).

\item {} 
The index \(o + n\) must be smaller than or equal to \(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}.\hyperref[syntax/types:syntax-limits]{\mathsf{min}}\).

\item {} 
The {\hyperref[\detokenize{exec/runtime:syntax-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{module instance}}}} \(\hyperref[exec/runtime:syntax-moduleinst]{\mathit{moduleinst}}\) must be {\hyperref[\detokenize{appendix/properties:valid-moduleinst}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} \(C\).

\item {} 
Each {\hyperref[\detokenize{syntax/modules:syntax-funcidx}]{\sphinxcrossref{\DUrole{std,std-ref}{function index}}}} \(x_i\) in \(x^n\) must be defined in the context \(C\).

\item {} 
Then the instruction is valid.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{table}}~\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}} : \hyperref[syntax/types:syntax-externtype]{\mathsf{table}}~\hyperref[syntax/types:syntax-limits]{\mathit{limits}}~\hyperref[syntax/types:syntax-elemtype]{\mathsf{funcref}}
  \qquad
  o + n \leq \hyperref[syntax/types:syntax-limits]{\mathit{limits}}.\hyperref[syntax/types:syntax-limits]{\mathsf{min}}
  \qquad
  (C.\hyperref[valid/conventions:context]{\mathsf{funcs}}[x] = \hyperref[syntax/types:syntax-functype]{\mathit{functype}})^n
}{
  S; C \hyperref[appendix/properties:valid-instr-admin]{\vdash} \hyperref[exec/runtime:syntax-init-elem]{\mathsf{init\_elem}}~\hyperref[exec/runtime:syntax-tableaddr]{\mathit{tableaddr}}~o~x^n \mathrel{\mbox{ok}}
}\end{split}
\end{equation*}
\index{data}\index{memory}\index{memory address}\index{byte}\ignorespaces 

\subsubsection{\protect\(\hyperref[exec/runtime:syntax-init-data]{\mathsf{init\_data}}~\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}~o~b^n\protect\)}
\label{\detokenize{appendix/properties:id7}}\label{\detokenize{appendix/properties:index-18}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{exec/runtime:syntax-externval}]{\sphinxcrossref{\DUrole{std,std-ref}{external memory value}}}} \(\hyperref[exec/runtime:syntax-externval]{\mathsf{mem}}~\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}\) must be {\hyperref[\detokenize{exec/modules:valid-externval-mem}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some {\hyperref[\detokenize{syntax/types:syntax-externtype}]{\sphinxcrossref{\DUrole{std,std-ref}{external memory type}}}} \(\hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\hyperref[syntax/types:syntax-limits]{\mathit{limits}}\).

\item {} 
The index \(o + n\) must be smaller than or equal to \(\hyperref[syntax/types:syntax-limits]{\mathit{limits}}.\hyperref[syntax/types:syntax-limits]{\mathsf{min}}\) divided by the {\hyperref[\detokenize{exec/runtime:page-size}]{\sphinxcrossref{\DUrole{std,std-ref}{page size}}}} \(64\,\mathrm{Ki}\).

\item {} 
Then the instruction is valid.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  S \hyperref[exec/modules:valid-externval]{\vdash} \hyperref[exec/runtime:syntax-externval]{\mathsf{mem}}~\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}} : \hyperref[syntax/types:syntax-externtype]{\mathsf{mem}}~\hyperref[syntax/types:syntax-limits]{\mathit{limits}}
  \qquad
  o + n \leq \hyperref[syntax/types:syntax-limits]{\mathit{limits}}.\hyperref[syntax/types:syntax-limits]{\mathsf{min}} \cdot 64\,\mathrm{Ki}
}{
  S; C \hyperref[appendix/properties:valid-instr-admin]{\vdash} \hyperref[exec/runtime:syntax-init-data]{\mathsf{init\_data}}~\hyperref[exec/runtime:syntax-memaddr]{\mathit{memaddr}}~o~b^n \mathrel{\mbox{ok}}
}\end{split}
\end{equation*}
\index{label}\index{instruction}\index{result type}\ignorespaces 

\subsubsection{\protect\(\hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_0^\ast\}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\protect\)}
\label{\detokenize{appendix/properties:id8}}\label{\detokenize{appendix/properties:index-19}}\begin{itemize}
\item {} 
The instruction sequence \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_0^\ast\) must be {\hyperref[\detokenize{valid/instructions:valid-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with some type \([t_1^n] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^?]\).

\item {} 
Let \(C'\) be the same {\hyperref[\detokenize{valid/conventions:context}]{\sphinxcrossref{\DUrole{std,std-ref}{context}}}} as \(C\), but with the {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t_1^n]\) prepended to the \(\hyperref[valid/conventions:context]{\mathsf{labels}}\) vector.

\item {} 
Under context \(C'\),
the instruction sequence \(\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\) must be {\hyperref[\detokenize{valid/instructions:valid-instr-seq}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with type \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^?]\).

\item {} 
Then the compound instruction is valid with type \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^?]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  S; C \hyperref[valid/instructions:valid-instr-seq]{\vdash} \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_0^\ast : [t_1^n] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^?]
  \qquad
  S; C,\hyperref[valid/conventions:context]{\mathsf{labels}}\,[t_1^n] \hyperref[valid/instructions:valid-instr-seq]{\vdash} \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast : [] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^?]
}{
  S; C \hyperref[appendix/properties:valid-instr-admin]{\vdash} \hyperref[exec/runtime:syntax-label]{\mathsf{label}}_n\{\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}_0^\ast\}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} : [] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t_2^?]
}\end{split}
\end{equation*}
\index{frame}\index{instruction}\index{result type}\ignorespaces 

\subsubsection{\protect\(\hyperref[exec/runtime:syntax-frame]{\mathsf{frame}}_n\{F\}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}}\protect\)}
\label{\detokenize{appendix/properties:index-20}}\label{\detokenize{appendix/properties:id9}}\begin{itemize}
\item {} 
Under the return type \([t^n]\),
the {\hyperref[\detokenize{exec/runtime:syntax-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{thread}}}} \(F; \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast\) must be {\hyperref[\detokenize{appendix/properties:valid-frame}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t^n]\).

\item {} 
Then the compound instruction is valid with type \([] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t^n]\).

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  S; [t^n] \hyperref[valid/instructions:valid-instr-seq]{\vdash} F; \hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast : [t^n]
}{
  S; C \hyperref[appendix/properties:valid-instr-admin]{\vdash} \hyperref[exec/runtime:syntax-frame]{\mathsf{frame}}_n\{F\}~\hyperref[syntax/instructions:syntax-instr]{\mathit{instr}}^\ast~\hyperref[syntax/instructions:syntax-instr-control]{\mathsf{end}} : [] \hyperref[syntax/types:syntax-functype]{\rightarrow} [t^n]
}\end{split}
\end{equation*}
\index{store extension|textbf}\index{store}\ignorespaces 

\subsection{Store Extension}
\label{\detokenize{appendix/properties:store-extension}}\label{\detokenize{appendix/properties:index-21}}\label{\detokenize{appendix/properties:extend}}
Programs can mutate the {\hyperref[\detokenize{exec/runtime:syntax-store}]{\sphinxcrossref{\DUrole{std,std-ref}{store}}}} and its contained instances.
Any such modification must respect certain invariants, such as not removing allocated instances or changing immutable definitions.
While these invariants are inherent to the execution semantics of WebAssembly {\hyperref[\detokenize{exec/instructions:exec-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instructions}}}} and {\hyperref[\detokenize{exec/modules:exec-instantiation}]{\sphinxcrossref{\DUrole{std,std-ref}{modules}}}},
{\hyperref[\detokenize{exec/runtime:syntax-hostfunc}]{\sphinxcrossref{\DUrole{std,std-ref}{host functions}}}} do not automatically adhere to them. Consequently, the required invariants must be stated as explicit constraints on the {\hyperref[\detokenize{exec/instructions:exec-invoke-host}]{\sphinxcrossref{\DUrole{std,std-ref}{invocation}}}} of host functions.
Soundness only holds when the {\hyperref[\detokenize{intro/overview:embedder}]{\sphinxcrossref{\DUrole{std,std-ref}{embedder}}}} ensures these constraints.

The necessary constraints are codified by the notion of store \sphinxstyleemphasis{extension}:
a store state \(S'\) extends state \(S\), written \(S \hyperref[appendix/properties:extend]{\preceq} S'\), when the following rules hold.

\begin{sphinxadmonition}{note}{Note:}
Extension does not imply that the new store is valid, which is defined separately {\hyperref[\detokenize{appendix/properties:valid-store}]{\sphinxcrossref{\DUrole{std,std-ref}{above}}}}.
\end{sphinxadmonition}

\index{store}\index{function instance}\index{table instance}\index{memory instance}\index{global instance}\ignorespaces 

\subsubsection{Store \protect\(S\protect\)}
\label{\detokenize{appendix/properties:extend-store}}\label{\detokenize{appendix/properties:index-22}}\label{\detokenize{appendix/properties:id10}}\begin{itemize}
\item {} 
The length of \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}\) must not shrink.

\item {} 
The length of \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}\) must not shrink.

\item {} 
The length of \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}\) must not shrink.

\item {} 
The length of \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}\) must not shrink.

\item {} 
For each {\hyperref[\detokenize{exec/runtime:syntax-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{function instance}}}} \(\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}_i\) in the original \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}}\), the new function instance must be an {\hyperref[\detokenize{appendix/properties:extend-funcinst}]{\sphinxcrossref{\DUrole{std,std-ref}{extension}}}} of the old.

\item {} 
For each {\hyperref[\detokenize{exec/runtime:syntax-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{table instance}}}} \(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}_i\) in the original \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}}\), the new table instance must be an {\hyperref[\detokenize{appendix/properties:extend-tableinst}]{\sphinxcrossref{\DUrole{std,std-ref}{extension}}}} of the old.

\item {} 
For each {\hyperref[\detokenize{exec/runtime:syntax-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{memory instance}}}} \(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}_i\) in the original \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}}\), the new memory instance must be an {\hyperref[\detokenize{appendix/properties:extend-meminst}]{\sphinxcrossref{\DUrole{std,std-ref}{extension}}}} of the old.

\item {} 
For each {\hyperref[\detokenize{exec/runtime:syntax-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{global instance}}}} \(\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}_i\) in the original \(S.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}}\), the new global instance must be an {\hyperref[\detokenize{appendix/properties:extend-globalinst}]{\sphinxcrossref{\DUrole{std,std-ref}{extension}}}} of the old.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \begin{array}{@{}ccc@{}}
  S_1.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}} = \hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}_1^\ast &
  S_2.\hyperref[exec/runtime:syntax-store]{\mathsf{funcs}} = {\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}'_1}^\ast~\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}_2^\ast &
  (\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}_1 \hyperref[appendix/properties:extend]{\preceq} \hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}'_1)^\ast \\
  S_1.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}} = \hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}_1^\ast &
  S_2.\hyperref[exec/runtime:syntax-store]{\mathsf{tables}} = {\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}'_1}^\ast~\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}_2^\ast &
  (\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}_1 \hyperref[appendix/properties:extend]{\preceq} \hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}'_1)^\ast \\
  S_1.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}} = \hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}_1^\ast &
  S_2.\hyperref[exec/runtime:syntax-store]{\mathsf{mems}} = {\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}'_1}^\ast~\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}_2^\ast &
  (\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}_1 \hyperref[appendix/properties:extend]{\preceq} \hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}'_1)^\ast \\
  S_1.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}} = \hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}_1^\ast &
  S_2.\hyperref[exec/runtime:syntax-store]{\mathsf{globals}} = {\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}'_1}^\ast~\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}_2^\ast &
  (\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}_1 \hyperref[appendix/properties:extend]{\preceq} \hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}'_1)^\ast \\
  \end{array}
}{
  \hyperref[appendix/properties:extend-store]{\vdash} S_1 \hyperref[appendix/properties:extend]{\preceq} S_2
}\end{split}
\end{equation*}
\index{function instance}\ignorespaces 

\subsubsection{Function Instance \protect\(\hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}\protect\)}
\label{\detokenize{appendix/properties:extend-funcinst}}\label{\detokenize{appendix/properties:function-instance}}\label{\detokenize{appendix/properties:index-23}}\begin{itemize}
\item {} 
A function instance must remain unchanged.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
}{
  \hyperref[appendix/properties:extend-funcinst]{\vdash} \hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}} \hyperref[appendix/properties:extend]{\preceq} \hyperref[exec/runtime:syntax-funcinst]{\mathit{funcinst}}
}\end{split}
\end{equation*}
\index{table instance}\ignorespaces 

\subsubsection{Table Instance \protect\(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}\protect\)}
\label{\detokenize{appendix/properties:extend-tableinst}}\label{\detokenize{appendix/properties:index-24}}\label{\detokenize{appendix/properties:table-instance}}\begin{itemize}
\item {} 
The length of \(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}\) must not shrink.

\item {} 
The value of \(\hyperref[exec/runtime:syntax-tableinst]{\mathit{tableinst}}.\hyperref[exec/runtime:syntax-tableinst]{\mathsf{max}}\) must remain unchanged.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  n_1 \leq n_2
}{
  \hyperref[appendix/properties:extend-tableinst]{\vdash} \{\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}~(\mathit{fa}_1^?)^{n_1}, \hyperref[exec/runtime:syntax-tableinst]{\mathsf{max}}~m\} \hyperref[appendix/properties:extend]{\preceq} \{\hyperref[exec/runtime:syntax-tableinst]{\mathsf{elem}}~(\mathit{fa}_2^?)^{n_2}, \hyperref[exec/runtime:syntax-tableinst]{\mathsf{max}}~m\}
}\end{split}
\end{equation*}
\index{memory instance}\ignorespaces 

\subsubsection{Memory Instance \protect\(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}\protect\)}
\label{\detokenize{appendix/properties:extend-meminst}}\label{\detokenize{appendix/properties:index-25}}\label{\detokenize{appendix/properties:memory-instance}}\begin{itemize}
\item {} 
The length of \(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}\) must not shrink.

\item {} 
The value of \(\hyperref[exec/runtime:syntax-meminst]{\mathit{meminst}}.\hyperref[exec/runtime:syntax-meminst]{\mathsf{max}}\) must remain unchanged.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  n_1 \leq n_2
}{
  \hyperref[appendix/properties:extend-meminst]{\vdash} \{\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}~b_1^{n_1}, \hyperref[exec/runtime:syntax-meminst]{\mathsf{max}}~m\} \hyperref[appendix/properties:extend]{\preceq} \{\hyperref[exec/runtime:syntax-meminst]{\mathsf{data}}~b_2^{n_2}, \hyperref[exec/runtime:syntax-meminst]{\mathsf{max}}~m\}
}\end{split}
\end{equation*}
\index{global instance}\index{value}\index{mutability}\ignorespaces 

\subsubsection{Global Instance \protect\(\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}\protect\)}
\label{\detokenize{appendix/properties:extend-globalinst}}\label{\detokenize{appendix/properties:global-instance}}\label{\detokenize{appendix/properties:index-26}}\begin{itemize}
\item {} 
The {\hyperref[\detokenize{syntax/types:syntax-mut}]{\sphinxcrossref{\DUrole{std,std-ref}{mutability}}}} \(\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}.\hyperref[exec/runtime:syntax-globalinst]{\mathsf{mut}}\) must remain unchanged.

\item {} 
The {\hyperref[\detokenize{syntax/types:syntax-valtype}]{\sphinxcrossref{\DUrole{std,std-ref}{value type}}}} of the {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{value}}}} \(\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}.\hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}\) must remain unchanged.

\item {} 
If \(\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}.\hyperref[exec/runtime:syntax-globalinst]{\mathsf{mut}}\) is \(\hyperref[syntax/types:syntax-mut]{\mathsf{const}}\), then the {\hyperref[\detokenize{exec/runtime:syntax-val}]{\sphinxcrossref{\DUrole{std,std-ref}{value}}}} \(\hyperref[exec/runtime:syntax-globalinst]{\mathit{globalinst}}.\hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}\) must remain unchanged.

\end{itemize}
\begin{equation*}
\begin{split}\frac{
  \hyperref[syntax/types:syntax-mut]{\mathit{mut}} = \hyperref[syntax/types:syntax-mut]{\mathsf{var}} \vee c_1 = c_2
}{
  \hyperref[appendix/properties:extend-globalinst]{\vdash} \{\hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}~(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_1), \hyperref[exec/runtime:syntax-globalinst]{\mathsf{mut}}~\hyperref[syntax/types:syntax-mut]{\mathit{mut}}\} \hyperref[appendix/properties:extend]{\preceq} \{\hyperref[exec/runtime:syntax-globalinst]{\mathsf{value}}~(t.\hyperref[syntax/instructions:syntax-instr-numeric]{\mathsf{const}}~c_2), \hyperref[exec/runtime:syntax-globalinst]{\mathsf{mut}}~\hyperref[syntax/types:syntax-mut]{\mathit{mut}}\}
}\end{split}
\end{equation*}
\index{preservation|textbf}\index{progress|textbf}\index{soundness}\index{configuration}\index{thread}\index{terminal configuration}\index{instantiation}\index{invocation}\index{validity}\index{module}\ignorespaces 

\subsection{Theorems}
\label{\detokenize{appendix/properties:soundness-statement}}\label{\detokenize{appendix/properties:index-27}}\label{\detokenize{appendix/properties:theorems}}
Given the definition of {\hyperref[\detokenize{appendix/properties:valid-config}]{\sphinxcrossref{\DUrole{std,std-ref}{valid configurations}}}},
the standard soundness theorems hold. %
\begin{footnote}[52]\sphinxAtStartFootnote
A machine-verified version of the formalization and soundness proof is described in the following article:
Conrad Watt. \sphinxhref{https://dl.acm.org/citation.cfm?id=3167082}{Mechanising and Verifying the WebAssembly Specification}. Proceedings of the 7th ACM SIGPLAN Conference on Certified Programs and Proofs (CPP 2018). ACM 2018.
%
\end{footnote}

\sphinxstylestrong{Theorem (Preservation).}
If a {\hyperref[\detokenize{exec/runtime:syntax-config}]{\sphinxcrossref{\DUrole{std,std-ref}{configuration}}}} \(S;T\) is {\hyperref[\detokenize{appendix/properties:valid-config}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} with {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t^\ast]\) (i.e., \(\hyperref[appendix/properties:valid-config]{\vdash} S;T : [t^\ast]\)),
and steps to \(S';T'\) (i.e., \(S;T \hyperref[exec/conventions:formal-notation]{\hookrightarrow} S';T'\)),
then \(S';T'\) is a valid configuration with the same result type (i.e., \(\hyperref[appendix/properties:valid-config]{\vdash} S';T' : [t^\ast]\)).
Furthermore, \(S'\) is an {\hyperref[\detokenize{appendix/properties:extend-store}]{\sphinxcrossref{\DUrole{std,std-ref}{extension}}}} of \(S\) (i.e., \(\hyperref[appendix/properties:extend-store]{\vdash} S \hyperref[appendix/properties:extend]{\preceq} S'\)).

A \sphinxstyleemphasis{terminal} {\hyperref[\detokenize{exec/runtime:syntax-thread}]{\sphinxcrossref{\DUrole{std,std-ref}{thread}}}} is one whose sequence of {\hyperref[\detokenize{syntax/instructions:syntax-instr}]{\sphinxcrossref{\DUrole{std,std-ref}{instructions}}}} is a {\hyperref[\detokenize{exec/runtime:syntax-result}]{\sphinxcrossref{\DUrole{std,std-ref}{result}}}}.
A terminal configuration is a configuration whose thread is terminal.

\sphinxstylestrong{Theorem (Progress).}
If a {\hyperref[\detokenize{exec/runtime:syntax-config}]{\sphinxcrossref{\DUrole{std,std-ref}{configuration}}}} \(S;T\) is {\hyperref[\detokenize{appendix/properties:valid-config}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} (i.e., \(\hyperref[appendix/properties:valid-config]{\vdash} S;T : [t^\ast]\) for some {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t^\ast]\)),
then either it is terminal,
or it can step to some configuration \(S';T'\) (i.e., \(S;T \hyperref[exec/conventions:formal-notation]{\hookrightarrow} S';T'\)).

From Preservation and Progress the soundness of the WebAssembly type system follows directly.

\sphinxstylestrong{Corollary (Soundness).}
If a {\hyperref[\detokenize{exec/runtime:syntax-config}]{\sphinxcrossref{\DUrole{std,std-ref}{configuration}}}} \(S;T\) is {\hyperref[\detokenize{appendix/properties:valid-config}]{\sphinxcrossref{\DUrole{std,std-ref}{valid}}}} (i.e., \(\hyperref[appendix/properties:valid-config]{\vdash} S;T : [t^\ast]\) for some {\hyperref[\detokenize{syntax/types:syntax-resulttype}]{\sphinxcrossref{\DUrole{std,std-ref}{result type}}}} \([t^\ast]\)),
then it either diverges or takes a finite number of steps to reach a terminal configuration \(S';T'\) (i.e., \(S;T \hyperref[exec/conventions:formal-notation]{\hookrightarrow}^\ast S';T'\)) that is valid with the same result type (i.e., \(\hyperref[appendix/properties:valid-config]{\vdash} S';T' : [t^\ast]\))
and where \(S'\) is an {\hyperref[\detokenize{appendix/properties:extend-store}]{\sphinxcrossref{\DUrole{std,std-ref}{extension}}}} of \(S\) (i.e., \(\hyperref[appendix/properties:extend-store]{\vdash} S \hyperref[appendix/properties:extend]{\preceq} S'\)).

In other words, every thread in a valid configuration either runs forever, traps, or terminates with a result that has the expected type.
Consequently, given a {\hyperref[\detokenize{appendix/properties:valid-store}]{\sphinxcrossref{\DUrole{std,std-ref}{valid store}}}}, no computation defined by {\hyperref[\detokenize{exec/modules:exec-instantiation}]{\sphinxcrossref{\DUrole{std,std-ref}{instantiation}}}} or {\hyperref[\detokenize{exec/modules:exec-invocation}]{\sphinxcrossref{\DUrole{std,std-ref}{invocation}}}} of a valid module can “crash” or otherwise (mis)behave in ways not covered by the {\hyperref[\detokenize{exec/index:exec}]{\sphinxcrossref{\DUrole{std,std-ref}{execution}}}} semantics given in this specification.



\renewcommand{\indexname}{Index}
\printindex
\end{document}